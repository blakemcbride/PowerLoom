;;; -*- Mode: Lisp; Package: PLI; Syntax: COMMON-LISP; Base: 10 -*-

;;; pli.slisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2023      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)
  (CL:UNLESS (CL:FIND-PACKAGE "PLI")
     (CL:DEFPACKAGE "PLI" (:USE))))

(CL:IN-PACKAGE "PLI")

;;; Auxiliary variables:

(CL:DEFVAR SGT-PLI-PLI-ENVIRONMENT STELLA::NULL)
(CL:DEFVAR SYM-PLI-LOGIC-LEVEL STELLA::NULL)
(CL:DEFVAR SGT-PLI-PLI-PL-ITERATOR STELLA::NULL)
(CL:DEFVAR SYM-PLI-STELLA-CURSOR STELLA::NULL)
(CL:DEFVAR SGT-PLI-STELLA-CONS STELLA::NULL)
(CL:DEFVAR SGT-PLI-STELLA-LIST STELLA::NULL)
(CL:DEFVAR SGT-PLI-STELLA-VECTOR STELLA::NULL)
(CL:DEFVAR SYM-PLI-STELLA-NULL STELLA::NULL)
(CL:DEFVAR SGT-PLI-LOGIC-SKOLEM STELLA::NULL)
(CL:DEFVAR SGT-PLI-LOGIC-LOGIC-OBJECT STELLA::NULL)
(CL:DEFVAR SGT-PLI-STELLA-GENERALIZED-SYMBOL STELLA::NULL)
(CL:DEFVAR SGT-PLI-STELLA-MODULE STELLA::NULL)
(CL:DEFVAR SGT-PLI-STELLA-CONTEXT STELLA::NULL)
(CL:DEFVAR SGT-PLI-LOGIC-COMPUTED-PROCEDURE STELLA::NULL)
(CL:DEFVAR SGT-PLI-STELLA-LITERAL-WRAPPER STELLA::NULL)
(CL:DEFVAR SGT-PLI-LOGIC-NAMED-DESCRIPTION STELLA::NULL)
(CL:DEFVAR SYM-PLI-PLI-?R STELLA::NULL)
(CL:DEFVAR SYM-PLI-PLI-?I STELLA::NULL)
(CL:DEFVAR SYM-PLI-PLI-?V STELLA::NULL)
(CL:DEFVAR SYM-PLI-PLI-F-GET-INFERRED-BINARY-PROPOSITION-VALUES-QUERY-000 STELLA::NULL)
(CL:DEFVAR SYM-PLI-LOGIC-ALL STELLA::NULL)
(CL:DEFVAR SYM-PLI-LOGIC-?X STELLA::NULL)
(CL:DEFVAR SYM-PLI-STELLA-AND STELLA::NULL)
(CL:DEFVAR SYM-PLI-LOGIC-FAIL STELLA::NULL)
(CL:DEFVAR SYM-PLI-STELLA-EXISTS STELLA::NULL)
(CL:DEFVAR SYM-PLI-LOGIC-?Y STELLA::NULL)
(CL:DEFVAR SYM-PLI-PLI-PROPER-SUBRELATION STELLA::NULL)
(CL:DEFVAR SYM-PLI-STELLA-TRUE STELLA::NULL)
(CL:DEFVAR SYM-PLI-STELLA-FALSE STELLA::NULL)
(CL:DEFVAR KWD-PLI-CASE-SENSITIVE? STELLA::NULL)
(CL:DEFVAR KWD-PLI-SUBSET-OF STELLA::NULL)
(CL:DEFVAR KWD-PLI-ERROR STELLA::NULL)
(CL:DEFVAR KWD-PLI-RETRACT-TRUE STELLA::NULL)
(CL:DEFVAR KWD-PLI-ASSERT-TRUE STELLA::NULL)
(CL:DEFVAR SGT-PLI-LOGIC-PROPOSITION STELLA::NULL)
(CL:DEFVAR SGT-PLI-LOGIC-DESCRIPTION STELLA::NULL)
(CL:DEFVAR SGT-PLI-PL-KERNEL-KB-NTH-DOMAIN STELLA::NULL)
(CL:DEFVAR KWD-PLI-MODULE STELLA::NULL)
(CL:DEFVAR SGT-PLI-LOGIC-PATTERN-VARIABLE STELLA::NULL)
(CL:DEFVAR SGT-PLI-STELLA-INTEGER-WRAPPER STELLA::NULL)
(CL:DEFVAR SGT-PLI-STELLA-FLOAT-WRAPPER STELLA::NULL)
(CL:DEFVAR SGT-PLI-STELLA-NUMBER-WRAPPER STELLA::NULL)
(CL:DEFVAR SGT-PLI-STELLA-STRING-WRAPPER STELLA::NULL)
(CL:DEFVAR SYM-PLI-STELLA-ITERATOR STELLA::NULL)
(CL:DEFVAR SGT-PLI-PLI-OBJECT-REGISTRY-LIST STELLA::NULL)
(CL:DEFVAR SYM-PLI-PLI-REGISTRY-LENGTH STELLA::NULL)
(CL:DEFVAR SYM-PLI-PLI-N-FREE-CELLS STELLA::NULL)
(CL:DEFVAR KWD-PLI-DOCUMENTATION STELLA::NULL)
(CL:DEFVAR SYM-PLI-PLI-STARTUP-PLI STELLA::NULL)
(CL:DEFVAR SYM-PLI-STELLA-METHOD-STARTUP-CLASSNAME STELLA::NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL STELLA::*STARTUP-TIME-PHASE* STELLA::*QUERYITERATOR*
  STELLA::NULL-CHARACTER STELLA::INCONSISTENT-TRUTH-VALUE
  STELLA::UNKNOWN-TRUTH-VALUE STELLA::FALSE-TRUTH-VALUE
  STELLA::DEFAULT-FALSE-TRUTH-VALUE STELLA::STANDARD-OUTPUT STELLA::EOL
  STELLA::KEYWORD-SYM STELLA::TRUE-TRUTH-VALUE
  STELLA::DEFAULT-TRUE-TRUTH-VALUE STELLA::*CONTEXT*
  STELLA::*REVERSEPOLARITY?* STELLA::*ROOT-MODULE*
  STELLA::*LOGIC-MODULE* STELLA::*KIF-SENTENCE-OPERATORS*
  STELLA::*KIF-TERM-OPERATORS* STELLA::NULL-INTEGER STELLA::*MODULE*
  STELLA::TRUE-WRAPPER STELLA::FALSE-WRAPPER STELLA::NIL
  STELLA::*POWERLOOM-LOCK* STELLA::*BOOTSTRAP-LOCK*))

;;; (DEFGLOBAL *POWERLOOM-INITIALIZED?* ...)

(CL:DEFVAR *POWERLOOM-INITIALIZED?* CL:NIL)

;;; (DEFUN INITIALIZE ...)

(CL:DEFUN INITIALIZE ()
  "Initialize the PowerLoom logic system.  This function
needs to be called by all applications before using PowerLoom.  If it
is called more than once, every call after the first one is a no-op."
  (STELLA::WITH-PROCESS-LOCK STELLA::*BOOTSTRAP-LOCK*
   (CL:WHEN (CL:NOT *POWERLOOM-INITIALIZED?*)
    (STELLA::STARTUP-LOGIC-SYSTEM))))

;;; (DEFUN RESET-POWERLOOM ...)

(CL:DEFUN RESET-POWERLOOM ()
  "Reset PowerLoom to its initial state.
CAUTION: This will destroy all loaded knowledge bases and might break other
loaded STELLA systems if they do reference PowerLoom symbols in their code."
  (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
   (STELLA::RESET-POWERLOOM)))

;;; (DEFUN CLEAR-CACHES ...)

(CL:DEFUN CLEAR-CACHES ()
  "Clear all query and memoization caches."
  (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
   (STELLA::CLEAR-CACHES)))

(CL:DEFUN NEW-ENVIRONMENT ()
  (CL:LET* ((SELF STELLA::NULL)) (CL:SETQ SELF (%MAKE-ENVIRONMENT))
   (CL:SETF (%ENVIRONMENT.LEVEL SELF) STELLA::NULL-STRING) SELF))

(CL:DEFMETHOD STELLA::PRIMARY-TYPE ((SELF ENVIRONMENT))
  SGT-PLI-PLI-ENVIRONMENT)

(CL:DEFUN ACCESS-ENVIRONMENT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PLI-LOGIC-LEVEL)
    (CL:IF SETVALUE?
     (CL:SETF (%ENVIRONMENT.LEVEL SELF)
      (STELLA::%STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (STELLA::WRAP-STRING (%ENVIRONMENT.LEVEL SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
     (STELLA::%%PRINT-STREAM
      (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
      SLOTNAME "' is not a valid case option")
     (CL:ERROR
      (STELLA::NEW-STELLA-EXCEPTION
       (STELLA::THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFMETHOD STELLA::PRINT-OBJECT ((SELF ENVIRONMENT) STREAM)
  (STELLA::%%PRINT-STREAM STREAM "|ENV|" (%ENVIRONMENT.LEVEL SELF)))

;;; (DEFCONSTANT ASSERTION-ENV ...)

(CL:DEFVAR ASSERTION-ENV STELLA::NULL)

;;; (DEFCONSTANT TAXONOMIC-ENV ...)

(CL:DEFVAR TAXONOMIC-ENV STELLA::NULL)

;;; (DEFCONSTANT INFERENCE-ENV ...)

(CL:DEFVAR INFERENCE-ENV STELLA::NULL)

;;; (DEFUN (TEST-ENVIRONMENT-LEVEL? BOOLEAN) ...)

(CL:DEFUN TEST-ENVIRONMENT-LEVEL? (ENV LEVEL)
  "Test if `env' has level set to `level'"
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LEVEL))
  #+MCL
  (CL:CHECK-TYPE LEVEL CL:SIMPLE-STRING)
  (CL:AND (CL:NOT (CL:EQ ENV STELLA::NULL))
   (STELLA::STRING-EQL? (%ENVIRONMENT.LEVEL ENV) LEVEL)))

(CL:DEFUN NEW-PL-ITERATOR ()
  (CL:LET* ((SELF STELLA::NULL)) (CL:SETQ SELF (%MAKE-PL-ITERATOR))
   (CL:SETF (%PL-ITERATOR.FIRST-ITERATION? SELF) CL:T)
   (CL:SETF (%PL-ITERATOR.VALUE SELF) STELLA::NULL)
   (CL:SETF (%PL-ITERATOR.CURSOR SELF) STELLA::NULL) SELF))

(CL:DEFMETHOD STELLA::PRIMARY-TYPE ((SELF PL-ITERATOR))
  SGT-PLI-PLI-PL-ITERATOR)

(CL:DEFUN ACCESS-PL-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PLI-STELLA-CURSOR)
    (CL:IF SETVALUE? (CL:SETF (%PL-ITERATOR.CURSOR SELF) VALUE)
     (CL:SETQ VALUE (%PL-ITERATOR.CURSOR SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
     (STELLA::%%PRINT-STREAM
      (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
      SLOTNAME "' is not a valid case option")
     (CL:ERROR
      (STELLA::NEW-STELLA-EXCEPTION
       (STELLA::THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD STELLA::NEXT? ((SELF PL-ITERATOR))
  "Advance the PL-Iterator `self' and return `true' if more
elements are available, `false' otherwise."
  (CL:LET* ((CURSOR (%PL-ITERATOR.CURSOR SELF)))
   (CL:WHEN (CL:EQ CURSOR STELLA::NIL)
    (CL:SETF (%PL-ITERATOR.VALUE SELF) STELLA::NULL)
    (CL:RETURN-FROM STELLA::NEXT? CL:NIL))
   (CL:SETF (%PL-ITERATOR.VALUE SELF) (STELLA::%%VALUE CURSOR))
   (CL:SETF (%PL-ITERATOR.CURSOR SELF) (STELLA::%%REST CURSOR)) CL:T))

;;; (DEFUN (PL-ITERATOR-VALUE OBJECT) ...)

(CL:DEFUN PL-ITERATOR-VALUE (SELF)
  "C-callable iterator `value'-slot accessor."
  (%PL-ITERATOR.VALUE SELF))

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD STELLA::EMPTY? ((SELF PL-ITERATOR))
  "Return TRUE if the iterator `self' has no more elements."
  (CL:EQ (%PL-ITERATOR.CURSOR SELF) STELLA::NIL))

;;; (DEFUN (PL-ITERATOR-IS-EMPTY BOOLEAN) ...)

(CL:DEFUN PL-ITERATOR-IS-EMPTY (SELF)
  "Return TRUE if the iterator `self' has no more elements.
This is here primarily to support the `is-...' naming convention for tests."
  (CL:EQ (%PL-ITERATOR.CURSOR SELF) STELLA::NIL))

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD STELLA::LENGTH ((SELF PL-ITERATOR))
  "Number of items remaining in `self'.  Non destructive."
  (STELLA::LENGTH (%PL-ITERATOR.CURSOR SELF)))

;;; (DEFGLOBAL EMPTY-PL-ITERATOR ...)

(CL:DEFVAR EMPTY-PL-ITERATOR STELLA::NULL
  "Iterator that generates no values.")

;;; (DEFUN (CONS-TO-PL-ITERATOR PL-ITERATOR) ...)

(CL:DEFUN CONS-TO-PL-ITERATOR (SELF)
  "Convert a STELLA cons list into an API iterator."
  (CL:IF (CL:EQ SELF STELLA::NIL) EMPTY-PL-ITERATOR
   (CL:LET* ((SELF-000 (NEW-PL-ITERATOR)))
    (CL:SETF (%PL-ITERATOR.CURSOR SELF-000) SELF)
    (CL:LET* ((VALUE-000 SELF-000)) VALUE-000))))

;;; (DEFUN (LIST-TO-PL-ITERATOR PL-ITERATOR) ...)

(CL:DEFUN LIST-TO-PL-ITERATOR (SELF)
  "Convert a STELLA list into an API iterator."
  (CL:IF (STELLA::EMPTY? SELF) EMPTY-PL-ITERATOR
   (CONS-TO-PL-ITERATOR (STELLA::%LIST.THE-CONS-LIST SELF))))

;;; (DEFUN (ITERATOR-TO-PL-ITERATOR PL-ITERATOR) ...)

(CL:DEFUN ITERATOR-TO-PL-ITERATOR (SELF)
  "Convert an arbitrary STELLA iterator into an API iterator.
This will first exhaust `self' and then create an API iterator that will
iterate over the previously generated values."
  (CONS-TO-PL-ITERATOR (STELLA::CONSIFY SELF)))

;;; (DEFMETHOD (LISTIFY LIST) ...)

(CL:DEFMETHOD STELLA::LISTIFY ((SELF PL-ITERATOR))
  "Convert `self' into a Stella LIST."
  (CL:LET* ((SELF-000 (STELLA::NEW-LIST)))
   (CL:LET* ((VALUE-001 STELLA::NIL))
    (CL:LET*
     ((X STELLA::NULL) (ITER-000 SELF) (COLLECT-000 STELLA::NULL))
     (CL:LOOP WHILE (STELLA::NEXT? ITER-000) DO
      (CL:SETQ X (%PL-ITERATOR.VALUE ITER-000))
      (CL:IF (CL:EQ COLLECT-000 STELLA::NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (STELLA::CONS X STELLA::NIL))
        (CL:IF (CL:EQ VALUE-001 STELLA::NIL)
         (CL:SETQ VALUE-001 COLLECT-000)
         (STELLA::ADD-CONS-TO-END-OF-CONS-LIST VALUE-001 COLLECT-000)))
       (CL:PROGN
        (CL:SETF (STELLA::%%REST COLLECT-000)
         (STELLA::CONS X STELLA::NIL))
        (CL:SETQ COLLECT-000 (STELLA::%%REST COLLECT-000))))))
    (CL:SETF (STELLA::%LIST.THE-CONS-LIST SELF-000) VALUE-001))
   (CL:LET* ((VALUE-000 SELF-000)) VALUE-000)))

;;; (DEFMETHOD (CONSIFY CONS) ...)

(CL:DEFMETHOD STELLA::CONSIFY ((SELF PL-ITERATOR))
  "Convert `self' into a Stella CONS."
  (CL:LET* ((VALUE-000 STELLA::NIL))
   (CL:LET*
    ((X STELLA::NULL) (ITER-000 SELF) (COLLECT-000 STELLA::NULL))
    (CL:LOOP WHILE (STELLA::NEXT? ITER-000) DO
     (CL:SETQ X (%PL-ITERATOR.VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 STELLA::NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (STELLA::CONS X STELLA::NIL))
       (CL:IF (CL:EQ VALUE-000 STELLA::NIL)
        (CL:SETQ VALUE-000 COLLECT-000)
        (STELLA::ADD-CONS-TO-END-OF-CONS-LIST VALUE-000 COLLECT-000)))
      (CL:PROGN
       (CL:SETF (STELLA::%%REST COLLECT-000)
        (STELLA::CONS X STELLA::NIL))
       (CL:SETQ COLLECT-000 (STELLA::%%REST COLLECT-000))))))
   (CL:LET* ((VALUE-001 VALUE-000)) VALUE-001)))

;;; (DEFUN (CREATE-CONS CONS) ...)

(CL:DEFUN CREATE-CONS (FIRST REST)
  "Create a STELLA CONS-cell whose value points to `first' and tail points to `rest'.
If `rest' is NULL, it will point to the empty list (available as a constructor in C)."
  (CL:WHEN (CL:EQ REST STELLA::NULL) (CL:SETQ REST STELLA::NIL))
  (STELLA::CONS FIRST REST))

;;; (DEFUN (CREATE-CONS-LIST CONS) ...)

(CL:DEFUN CREATE-CONS-LIST (LENGTH)
  "Create a STELLA CONS-list of `length' with elements initialized to NULL (available as a constructor in C)."
  (CL:DECLARE (CL:TYPE CL:FIXNUM LENGTH))
  #+MCL
  (CL:CHECK-TYPE LENGTH CL:FIXNUM)
  (CL:LET* ((LIST STELLA::NIL))
   (CL:LOOP WHILE (CL:> LENGTH 0) DO
    (CL:SETQ LIST (STELLA::CONS STELLA::NULL LIST))
    (CL:SETQ LENGTH (CL:1- LENGTH)))
   LIST))

;;; (DEFUN (CONS-LENGTH INTEGER) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM) CONS-LENGTH))
(CL:DEFUN CONS-LENGTH (SELF)
  "Return the length of the CONS-list `self' (available to support access in C)."
  (STELLA::LENGTH SELF))

;;; (DEFUN (CONS-IS-EMPTY BOOLEAN) ...)

(CL:DEFUN CONS-IS-EMPTY (SELF)
  "Return TRUE if the CONS-list `self' is empty (available to support access in C)."
  (CL:EQ SELF STELLA::NIL))

;;; (DEFUN (CONS-FIRST (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFUN CONS-FIRST (SELF)
  "Access the first element of the CONS-list `self' (available to support access in C)."
  (STELLA::%%VALUE SELF))

;;; (DEFUN (CONS-REST (LIKE SELF)) ...)

(CL:DEFUN CONS-REST (SELF)
  "Access the rest (tail) of the CONS-list `self' (available to support access in C)."
  (STELLA::%%REST SELF))

;;; (DEFUN (CONS-NTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFUN CONS-NTH (SELF N)
  "Access the `n'-th element of the CONS-list `self' (available to support access in C)."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (STELLA::NTH SELF N))

;;; (DEFUN (CONS-NTH-REST (LIKE SELF)) ...)

(CL:DEFUN CONS-NTH-REST (SELF N)
  "Access the `n'-th rest (tail) of the CONS-list `self' (available to support access in C)."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (STELLA::NTH-REST SELF N))

;;; (DEFUN CONS-SET-FIRST ...)

(CL:DEFUN CONS-SET-FIRST (SELF VALUE)
  "Set the first element of the CONS-list `self' to `value' (available to support access in C)."
  (CL:SETF (STELLA::%%VALUE SELF) VALUE))

;;; (DEFUN CONS-SET-REST ...)

(CL:DEFUN CONS-SET-REST (SELF REST)
  "Set the rest (tail) of the CONS-list `self' to `rest' (available to support access in C).
If `rest' is NULL, it will point to the empty list."
  (CL:WHEN (CL:EQ REST STELLA::NULL) (CL:SETQ REST STELLA::NIL))
  (CL:SETF (STELLA::%%REST SELF) REST))

;;; (DEFUN CONS-SET-NTH ...)

(CL:DEFUN CONS-SET-NTH (SELF N VALUE)
  "Set the `n'-th element of the CONS-list `self' to `value' (available to support access in C).
The run-time complexity of this operation is O(n)."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (STELLA::NTH-SETTER SELF VALUE N))

;;; (DEFUN CONS-SET-NTH-REST ...)

(CL:DEFUN CONS-SET-NTH-REST (SELF N REST)
  "Set the `n'-th rest (tail) of the CONS-list `self' to `rest' (available to support access in C).
If `rest' is NULL, it will point to the empty list.  The run-time complexity of this operation is O(n)."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (CL:WHEN (CL:EQ REST STELLA::NULL) (CL:SETQ REST STELLA::NIL))
  (STELLA::NTH-REST-SETTER SELF REST N))

;;; (DEFUN (LIST-FIRST (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFUN LIST-FIRST (SELF)
  "Access the first element of the list `self' (available to support access in C)."
  (STELLA::FIRST SELF))

;;; (DEFUN (LIST-REST (CONS OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFUN LIST-REST (SELF)
  "Access the rest (tail) of the list `self' (available to support access in C).
NOTE: the rest of a STELLA list is a CONS-list not a LIST."
  (STELLA::REST SELF))

;;; (DEFUN (LIST-NTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFUN LIST-NTH (SELF N)
  "Access the `n'-th element of the list `self' (available to support access in C)."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (STELLA::NTH SELF N))

;;; (DEFUN (CREATE-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  CREATE-STRING))
(CL:DEFUN CREATE-STRING (CONTENT)
  "Create a PowerLoom copy of the string `content' which uses PowerLoom memory
management and garbage collection.  This is primarily necessary in C environments when a string
is passed to a PowerLoom PLI function which might then be pointed to by a PowerLoom result
object such as a string wrapper.  If such an argument string is later explicitly freed or
overwritten, the result object would have a dangling reference or its content destroyed."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING CONTENT))
  #+MCL
  (CL:CHECK-TYPE CONTENT CL:SIMPLE-STRING)
  (STELLA::COPY CONTENT))

;;; (DEFUN (CREATE-STRING-WRAPPER STRING-WRAPPER) ...)

(CL:DEFUN CREATE-STRING-WRAPPER (SELF)
  "Create a STELLA string wrapper for `self'.  This automatically copies `self'
before the wrapper is allocated to avoid garbage collection issues in case `self' is freed."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF))
  #+MCL
  (CL:CHECK-TYPE SELF CL:SIMPLE-STRING)
  (STELLA::WRAP-STRING (STELLA::COPY SELF)))

;;; (DEFUN (CREATE-DIRECT-STRING-WRAPPER STRING-WRAPPER) ...)

(CL:DEFUN CREATE-DIRECT-STRING-WRAPPER (SELF)
  "Create a STELLA string wrapper for `self'.  This wraps `self' directly
and does not allocate a PowerLoom copy first, hence, memory management of `self' needs to
be carefully handled by the caller."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF))
  #+MCL
  (CL:CHECK-TYPE SELF CL:SIMPLE-STRING)
  (STELLA::WRAP-STRING SELF))

;;; (DEFUN (CREATE-INTEGER-WRAPPER INTEGER-WRAPPER) ...)

(CL:DEFUN CREATE-INTEGER-WRAPPER (SELF)
  "Create a STELLA integer wrapper for `self'."
  (CL:DECLARE (CL:TYPE CL:FIXNUM SELF))
  #+MCL
  (CL:CHECK-TYPE SELF CL:FIXNUM)
  (STELLA::WRAP-INTEGER SELF))

;;; (DEFUN (CREATE-LONG-INTEGER-WRAPPER LONG-INTEGER-WRAPPER) ...)

(CL:DEFUN CREATE-LONG-INTEGER-WRAPPER (SELF)
  "Create a STELLA long-integer wrapper for `self'."
  (STELLA::WRAP-LONG-INTEGER SELF))

;;; (DEFUN (CREATE-FLOAT-WRAPPER FLOAT-WRAPPER) ...)

(CL:DEFUN CREATE-FLOAT-WRAPPER (SELF)
  "Create a STELLA float wrapper for `self'."
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SELF))
  #+MCL
  (CL:CHECK-TYPE SELF CL:DOUBLE-FLOAT)
  (STELLA::WRAP-FLOAT SELF))

;;; (DEFUN (CREATE-BOOLEAN-WRAPPER BOOLEAN-WRAPPER) ...)

(CL:DEFUN CREATE-BOOLEAN-WRAPPER (SELF)
  "Create a STELLA boolean wrapper for `self'."
  (CL:IF SELF STELLA::TRUE-WRAPPER STELLA::FALSE-WRAPPER))

;;; (DEFUN (SAFELY-GET-OBJECT OBJECT) ...)

(CL:DEFUN SAFELY-GET-OBJECT (NAME MODULE ENVIRONMENT)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ NAME STELLA::NULL-STRING)
   (CL:RETURN-FROM SAFELY-GET-OBJECT STELLA::NULL))
  (CL:LET* ((OBJECT (GET-OBJECT NAME MODULE ENVIRONMENT)))
   (CL:IF (CL:EQ OBJECT STELLA::NULL)
    (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
     (STELLA::%%PRINT-STREAM
      (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "Can't find an object named `" NAME "'")
     (CL:ERROR
      (STELLA::NEW-NO-SUCH-OBJECT-EXCEPTION
       (STELLA::THE-STRING-READER STREAM-000))))
    OBJECT)))

;;; (DEFUN (SAFELY-GET-CONCEPT OBJECT) ...)

(CL:DEFUN SAFELY-GET-CONCEPT (NAME MODULE ENVIRONMENT)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ NAME STELLA::NULL-STRING)
   (CL:RETURN-FROM SAFELY-GET-CONCEPT STELLA::NULL))
  (CL:LET* ((OBJECT (GET-CONCEPT NAME MODULE ENVIRONMENT)))
   (CL:IF (CL:EQ OBJECT STELLA::NULL)
    (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
     (STELLA::%%PRINT-STREAM
      (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "Can't find a concept named `" NAME "'")
     (CL:ERROR
      (STELLA::NEW-NO-SUCH-OBJECT-EXCEPTION
       (STELLA::THE-STRING-READER STREAM-000))))
    OBJECT)))

;;; (DEFUN (SAFELY-GET-RELATION OBJECT) ...)

(CL:DEFUN SAFELY-GET-RELATION (NAME MODULE ENVIRONMENT)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ NAME STELLA::NULL-STRING)
   (CL:RETURN-FROM SAFELY-GET-RELATION STELLA::NULL))
  (CL:LET* ((OBJECT (GET-RELATION NAME MODULE ENVIRONMENT)))
   (CL:IF (CL:EQ OBJECT STELLA::NULL)
    (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
     (STELLA::%%PRINT-STREAM
      (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "Can't find a relation named `" NAME "'")
     (CL:ERROR
      (STELLA::NEW-NO-SUCH-OBJECT-EXCEPTION
       (STELLA::THE-STRING-READER STREAM-000))))
    OBJECT)))

;;; (DEFUN (SAFELY-GET-MODULE CONTEXT) ...)

(CL:DEFUN SAFELY-GET-MODULE (NAME ENVIRONMENT)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:SETQ ENVIRONMENT ENVIRONMENT)
  (CL:WHEN
   (CL:OR (CL:EQ NAME STELLA::NULL-STRING)
    (STELLA::STRING-EQL? NAME ""))
   (CL:RETURN-FROM SAFELY-GET-MODULE STELLA::*MODULE*))
  (STELLA::GET-STELLA-MODULE NAME CL:T))

;;; (DEFUN (SAFELY-GET-OBJECT-OR-NULL OBJECT) ...)

(CL:DEFUN SAFELY-GET-OBJECT-OR-NULL (NAME MODULE ENVIRONMENT)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:WHEN
   (CL:OR (CL:EQ MODULE STELLA::NULL) (CL:EQ NAME STELLA::NULL-STRING)
    (STELLA::STRING-EQL? NAME "") (STELLA::STRING-EQUAL? NAME "null"))
   (CL:RETURN-FROM SAFELY-GET-OBJECT-OR-NULL STELLA::NULL))
  (CL:HANDLER-CASE
   (CL:RETURN-FROM SAFELY-GET-OBJECT-OR-NULL
    (GET-OBJECT NAME MODULE ENVIRONMENT))
   (STELLA::NO-SUCH-OBJECT-EXCEPTION () STELLA::NULL)))

;;; (DEFUN (SEQUENCE-TO-CONS-LIST CONS) ...)

(CL:DEFUN SEQUENCE-TO-CONS-LIST (SEQUENCE)
  (CL:LET* ((TEST-VALUE-000 (STELLA::SAFE-PRIMARY-TYPE SEQUENCE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 SGT-PLI-STELLA-CONS) (CL:PROGN SEQUENCE))
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-STELLA-LIST)
     (CL:PROGN (STELLA::%LIST.THE-CONS-LIST SEQUENCE)))
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-STELLA-VECTOR)
     (CL:PROGN
      (CL:LET* ((RESULT STELLA::NIL))
       (CL:LET*
        ((I STELLA::NULL-INTEGER) (ITER-000 0)
         (UPPER-BOUND-000 (STELLA::LENGTH SEQUENCE))
         (COLLECT-000 STELLA::NULL))
        (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
        (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
         (CL:SETQ I ITER-000)
         (CL:IF (CL:EQ COLLECT-000 STELLA::NULL)
          (CL:PROGN
           (CL:SETQ COLLECT-000
            (STELLA::CONS
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR
               (STELLA::%VECTOR.THE-ARRAY SEQUENCE))
              I)
             STELLA::NIL))
           (CL:IF (CL:EQ RESULT STELLA::NIL)
            (CL:SETQ RESULT COLLECT-000)
            (STELLA::ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-000)))
          (CL:PROGN
           (CL:SETF (STELLA::%%REST COLLECT-000)
            (STELLA::CONS
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR
               (STELLA::%VECTOR.THE-ARRAY SEQUENCE))
              I)
             STELLA::NIL))
           (CL:SETQ COLLECT-000 (STELLA::%%REST COLLECT-000))))
         (CL:SETQ ITER-000 (CL:1+ ITER-000))))
       RESULT)))
    (CL:T
     (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
      (STELLA::%%PRINT-STREAM
       (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "Don't know how to convert object of type `"
       (STELLA::PRIMARY-TYPE SEQUENCE) "' into a cons list.")
      (CL:ERROR
       (STELLA::NEW-STELLA-EXCEPTION
        (STELLA::THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (EXPLODE-STRING-LIST CONS) ...)

(CL:DEFUN EXPLODE-STRING-LIST (STRINGLIST MODULE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGLIST))
  #+MCL
  (CL:CHECK-TYPE STRINGLIST CL:SIMPLE-STRING)
  (CL:LET*
   ((STELLA::*MODULE* MODULE) (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:LET*
    ((EXPRESSION (STELLA::READ-S-EXPRESSION-FROM-STRING STRINGLIST))
     (TERM STELLA::NULL) (RESULT STELLA::NIL))
    (CL:LET*
     ((REF STELLA::NULL) (ITER-000 EXPRESSION)
      (COLLECT-000 STELLA::NULL))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 STELLA::NIL)) DO
      (CL:SETQ REF (STELLA::%%VALUE ITER-000))
      (CL:SETQ TERM
       (CL:IF (CL:EQ REF SYM-PLI-STELLA-NULL) STELLA::NULL
        (STELLA::EVALUATE-TERM REF)))
      (CL:IF (CL:EQ COLLECT-000 STELLA::NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (STELLA::CONS TERM STELLA::NIL))
        (CL:IF (CL:EQ RESULT STELLA::NIL) (CL:SETQ RESULT COLLECT-000)
         (STELLA::ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-000)))
       (CL:PROGN
        (CL:SETF (STELLA::%%REST COLLECT-000)
         (STELLA::CONS TERM STELLA::NIL))
        (CL:SETQ COLLECT-000 (STELLA::%%REST COLLECT-000))))
      (CL:SETQ ITER-000 (STELLA::%%REST ITER-000))))
    RESULT)))

;;; (DEFUN (LEGAL-OPERATOR? BOOLEAN) ...)

(CL:DEFUN LEGAL-OPERATOR? (OPERATOR)
  (CL:OR (STELLA::MEMBER? STELLA::*KIF-SENTENCE-OPERATORS* OPERATOR)
   (STELLA::MEMBER? STELLA::*KIF-TERM-OPERATORS* OPERATOR)
   (STELLA::MEMBER?
    (STELLA::GET-QUOTED-TREE
     "((<=>> <<=> <<=>> <~> <~>> <<~> <<~>> ABOUT <<= =>> <~ ~> <<~ ~>>) \"/PLI\")"
     "/PLI")
    OPERATOR)))

;;; (DEFUN (GET-KEYWORD KEYWORD) ...)

(CL:DEFUN GET-KEYWORD (NAME)
  "Returns the Stella KEYWORD `name' if it exists.  Case sensitive."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (STELLA::LOOKUP-KEYWORD NAME))

;;; (DEFUN (GET-SYMBOL SYMBOL) ...)

(CL:DEFUN GET-SYMBOL (NAME MODULE ENVIRONMENT)
  "Returns the Stella SYMBOL `name' visible in `module' if it
exists.  `name' is ALWAYS treated literally and case sensitively."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (STELLA::LOOKUP-SYMBOL NAME))))

;;; (DEFUN (GET-OPERATOR SYMBOL) ...)

(CL:DEFUN GET-OPERATOR (NAME)
  "Returns the logical operator object (a Stella SYMBOL) for `name'.
If no such operator exists then a `no-such-object' exception is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:WHEN (CL:NOT (STELLA::ALL-UPPER-CASE-STRING? NAME))
   (CL:SETQ NAME (STELLA::STRING-UPCASE NAME)))
  (CL:LET*
   ((OPERATOR
     (STELLA::LOOKUP-SYMBOL-IN-MODULE NAME STELLA::*LOGIC-MODULE*
      CL:NIL)))
   (CL:IF
    (CL:AND (CL:NOT (CL:EQ OPERATOR STELLA::NULL))
     (LEGAL-OPERATOR? OPERATOR))
    OPERATOR
    (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
     (STELLA::%%PRINT-STREAM
      (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "No operator named `" NAME "'")
     (CL:ERROR
      (STELLA::NEW-NO-SUCH-OBJECT-EXCEPTION
       (STELLA::THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (GET-OBJECT OBJECT) ...)

(CL:DEFUN GET-OBJECT (NAME MODULE ENVIRONMENT)
  "Look for an object named `name' that is local to
or visible from the module `module'.  `name' is not taken literally
but will be parsed first with the PowerLoom symbol reader and, hence,
can contain escape characters, module prefixes, etc."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (STELLA::GET-INSTANCE (STELLA::LOOKUP-STELLA-NAME NAME)))))

;;; (DEFUN (S-GET-OBJECT OBJECT) ...)

(CL:DEFUN S-GET-OBJECT (NAME MODULE-NAME ENVIRONMENT)
  "Look for an object named `name' that is local to
or visible from the module `module-name'.  A module name of `null' or the
empty string refers to the current module.  If no module can be found
with the name `module-name', then a STELLA `no-such-context-exception' is thrown.
`name' is not taken literally but will be parsed first (see `get-object')."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (GET-OBJECT NAME (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT)
   ENVIRONMENT))

;;; (DEFUN (GET-CONCEPT LOGIC-OBJECT) ...)

(CL:DEFUN GET-CONCEPT (NAME MODULE ENVIRONMENT)
  "Return a class/concept named `name' that is local to
or visible from the module `module'.  `name' is not taken literally but
will be parsed first (see `get-object')."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (STELLA::GET-CLASS (STELLA::LOOKUP-STELLA-NAME NAME)))))

;;; (DEFUN (S-GET-CONCEPT LOGIC-OBJECT) ...)

(CL:DEFUN S-GET-CONCEPT (NAME MODULE-NAME ENVIRONMENT)
  "Return a class/concept named `name' that is local to
or visible from the module `module-name'.  A module name of `null' or the
empty string refers to the current module.  If no module can be found
with the name `module-name', then a Stella `no-such-context-exception' is thrown.
`name' is not taken literally but will be parsed first (see `get-object')."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (GET-CONCEPT NAME (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT)
   ENVIRONMENT))

;;; (DEFUN (GET-RELATION LOGIC-OBJECT) ...)

(CL:DEFUN GET-RELATION (NAME MODULE ENVIRONMENT)
  "Return a concept or relation named `name' that is local to
or visible from the module `module'.  `name' is not taken literally but will
be parsed first (see `get-object')."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (STELLA::GET-RELATION (STELLA::LOOKUP-STELLA-NAME NAME)))))

;;; (DEFUN (S-GET-RELATION LOGIC-OBJECT) ...)

(CL:DEFUN S-GET-RELATION (NAME MODULE-NAME ENVIRONMENT)
  "Return a concept or relation named `name' that is local to
or visible from the module `module-name'.  A module name of `null' or the
empty string refers to the current module.  If no module can be found
with the name `module-name', then a Stella `no-such-context-exception' is thrown.
`name' is not taken literally but will be parsed first (see `get-object')."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (GET-RELATION NAME (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT)
   ENVIRONMENT))

;;; (DEFUN (GET-UNDEFINED-RELATIONS (PL-ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN GET-UNDEFINED-RELATIONS (MODULE ENVIRONMENT)
  "Return relations that have been referenced but not defined in `module'."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:SETQ MODULE STELLA::*MODULE*)
    (CONS-TO-PL-ITERATOR
     (STELLA::CALL-LIST-UNDEFINED-RELATIONS MODULE CL:NIL)))))

;;; (DEFUN (GET-NAME-IN-MODULE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T CL:T) CL:SIMPLE-STRING)
  GET-NAME-IN-MODULE))
(CL:DEFUN GET-NAME-IN-MODULE (OBJ MODULE ENVIRONMENT)
  "Return the name, qualified as necessary, so that `obj' can be found from
`module'.  If there is no name for the object return `null'."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:LET* ((TEST-VALUE-000 (STELLA::SAFE-PRIMARY-TYPE OBJ)))
     (CL:COND
      ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-LOGIC-SKOLEM)
       (CL:PROGN STELLA::NULL-STRING))
      ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-LOGIC-LOGIC-OBJECT)
       (CL:PROGN (STELLA::STRINGIFY (STELLA::OBJECT-NAME OBJ))))
      ((STELLA::SUBTYPE-OF? TEST-VALUE-000
        SGT-PLI-STELLA-GENERALIZED-SYMBOL)
       (CL:PROGN (STELLA::STRINGIFY OBJ)))
      ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-STELLA-MODULE)
       (CL:PROGN (STELLA::%MODULE.MODULE-FULL-NAME OBJ)))
      ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-STELLA-CONTEXT)
       (CL:PROGN (STELLA::CONTEXT-NAME OBJ)))
      ((STELLA::SUBTYPE-OF? TEST-VALUE-000
        SGT-PLI-LOGIC-COMPUTED-PROCEDURE)
       (CL:PROGN
        (STELLA::STRINGIFY
         (STELLA::%COMPUTED-PROCEDURE.SURROGATE-VALUE-INVERSE OBJ))))
      (CL:T STELLA::NULL-STRING))))))

;;; (DEFUN (GET-NAME STRING) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) GET-NAME))
(CL:DEFUN GET-NAME (OBJ)
  "Return the fully qualified name of `obj', if it has one.  Otherwise return `null'."
  (GET-NAME-IN-MODULE OBJ STELLA::*ROOT-MODULE* STELLA::NULL))

;;; (DEFUN (GET-SHORT-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) GET-SHORT-NAME))
(CL:DEFUN GET-SHORT-NAME (OBJ)
  "Return the short name of `obj', if it has one.  Otherwise return `null'."
  (CL:LET* ((TEST-VALUE-000 (STELLA::SAFE-PRIMARY-TYPE OBJ)))
   (CL:COND
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-LOGIC-SKOLEM)
     (CL:PROGN STELLA::NULL-STRING))
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-LOGIC-LOGIC-OBJECT)
     (CL:PROGN (STELLA::OBJECT-NAME-STRING OBJ)))
    ((STELLA::SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
     (CL:PROGN
      (STELLA::CONCATENATE ":" (STELLA::%KEYWORD.SYMBOL-NAME OBJ))))
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000
      SGT-PLI-STELLA-GENERALIZED-SYMBOL)
     (CL:PROGN (STELLA::%GENERALIZED-SYMBOL.SYMBOL-NAME OBJ)))
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-STELLA-CONTEXT)
     (CL:PROGN (STELLA::CONTEXT-NAME OBJ)))
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000
      SGT-PLI-LOGIC-COMPUTED-PROCEDURE)
     (CL:PROGN
      (STELLA::%SURROGATE.SYMBOL-NAME
       (STELLA::%COMPUTED-PROCEDURE.SURROGATE-VALUE-INVERSE OBJ))))
    (CL:T STELLA::NULL-STRING))))

;;; (DEFUN (GET-SKOLEM-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) GET-SKOLEM-NAME))
(CL:DEFUN GET-SKOLEM-NAME (SKOLEM)
  "Return the fully qualified name of `skolem'.  Note that skolems are anonymous objects
which cannot be referenced by their name in logic expressions, so this function is only useful in special
circumstances such as inside specialist computations, etc."
  (GET-NAME-IN-MODULE (STELLA::%SKOLEM.SKOLEM-NAME SKOLEM)
   STELLA::*ROOT-MODULE* STELLA::NULL))

;;; (DEFUN (GET-SKOLEM-SHORT-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) GET-SKOLEM-SHORT-NAME))
(CL:DEFUN GET-SKOLEM-SHORT-NAME (SKOLEM)
  "Return the unqualified name of `skolem'.  Note that skolems are anonymous objects which
cannot be referenced by their name in logic expressions, so this function is only useful in special
circumstances such as inside specialist computations, etc."
  (STELLA::%SYMBOL.SYMBOL-NAME (STELLA::%SKOLEM.SKOLEM-NAME SKOLEM)))

;;; (DEFUN (GET-VARIABLE-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) GET-VARIABLE-NAME))
(CL:DEFUN GET-VARIABLE-NAME (VARIABLE)
  "Return the fully qualified name of `variable'."
  (GET-NAME-IN-MODULE (STELLA::%PATTERN-VARIABLE.SKOLEM-NAME VARIABLE)
   STELLA::*ROOT-MODULE* STELLA::NULL))

;;; (DEFUN (GET-VARIABLE-SHORT-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  GET-VARIABLE-SHORT-NAME))
(CL:DEFUN GET-VARIABLE-SHORT-NAME (VARIABLE)
  "Return the unqualified name of `variable'."
  (STELLA::%SYMBOL.SYMBOL-NAME
   (STELLA::%PATTERN-VARIABLE.SKOLEM-NAME VARIABLE)))

;;; (DEFUN (OBJECT-TO-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) OBJECT-TO-STRING))
(CL:DEFUN OBJECT-TO-STRING (SELF)
  "Return a printed representation of the term `self' as a string."
  (CL:IF (CL:EQ SELF STELLA::NULL) STELLA::NULL-STRING
   (CL:LET* ((STELLA::*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL STELLA::*PRINTREADABLY?*))
    (CL:LET* ((TEST-VALUE-000 (STELLA::SAFE-PRIMARY-TYPE SELF)))
     (CL:COND
      ((STELLA::SUBTYPE-OF-STRING? TEST-VALUE-000)
       (CL:PROGN (STELLA::%STRING-WRAPPER.WRAPPER-VALUE SELF)))
      ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-LOGIC-SKOLEM)
       (CL:PROGN
        (CL:LET* ((VALUE (STELLA::VALUE-OF SELF)))
         (CL:IF (CL:EQ VALUE SELF) (STELLA::STRINGIFY SELF)
          (OBJECT-TO-STRING VALUE)))))
      ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-PLI-PL-ITERATOR)
       (CL:PROGN (STELLA::STRINGIFY (STELLA::CONSIFY SELF))))
      (CL:T (STELLA::STRINGIFY SELF)))))))

;;; (DEFUN (OBJECT-TO-INTEGER INTEGER) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM) OBJECT-TO-INTEGER))
(CL:DEFUN OBJECT-TO-INTEGER (SELF)
  "Coerce `self' to an integer, or throw a Stella Exception if the coersion is not feasible.
Floating point values will be coerced by rounding."
  (CL:LET* ((TEST-VALUE-000 (STELLA::SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:LET* ((VALUE (STELLA::VALUE-OF SELF)))
       (CL:IF (CL:EQ VALUE SELF)
        (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
         (STELLA::%%PRINT-STREAM
          (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
          "Can't coerce `" SELF "' to an integer.")
         (CL:ERROR
          (STELLA::NEW-STELLA-EXCEPTION
           (STELLA::THE-STRING-READER STREAM-000))))
        (OBJECT-TO-INTEGER VALUE)))))
    ((STELLA::SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN (STELLA::%INTEGER-WRAPPER.WRAPPER-VALUE SELF)))
    ((STELLA::SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN
      (STELLA::ROUND (STELLA::%FLOAT-WRAPPER.WRAPPER-VALUE SELF))))
    (CL:T
     (CL:LET* ((STREAM-001 (STELLA::NEW-OUTPUT-STRING-STREAM)))
      (STELLA::%%PRINT-STREAM
       (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
       "Can't coerce `" SELF "' to an integer.")
      (CL:ERROR
       (STELLA::NEW-STELLA-EXCEPTION
        (STELLA::THE-STRING-READER STREAM-001))))))))

;;; (DEFUN (OBJECT-TO-FLOAT FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:DOUBLE-FLOAT) OBJECT-TO-FLOAT))
(CL:DEFUN OBJECT-TO-FLOAT (SELF)
  "Coerce `self' to a float, or throw a Stella Exception if the coersion is not feasible."
  (CL:LET* ((TEST-VALUE-000 (STELLA::SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:LET* ((VALUE (STELLA::VALUE-OF SELF)))
       (CL:IF (CL:EQ VALUE SELF)
        (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
         (STELLA::%%PRINT-STREAM
          (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
          "Can't coerce `" SELF "' to a float.")
         (CL:ERROR
          (STELLA::NEW-STELLA-EXCEPTION
           (STELLA::THE-STRING-READER STREAM-000))))
        (OBJECT-TO-FLOAT VALUE)))))
    ((STELLA::SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN (STELLA::NUMBER-WRAPPER-TO-FLOAT SELF)))
    ((STELLA::SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN (STELLA::%FLOAT-WRAPPER.WRAPPER-VALUE SELF)))
    (CL:T
     (CL:LET* ((STREAM-001 (STELLA::NEW-OUTPUT-STRING-STREAM)))
      (STELLA::%%PRINT-STREAM
       (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
       "Can't coerce `" SELF "' to a float.")
      (CL:ERROR
       (STELLA::NEW-STELLA-EXCEPTION
        (STELLA::THE-STRING-READER STREAM-001))))))))

;;; (DEFUN (OBJECT-TO-PARSABLE-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  OBJECT-TO-PARSABLE-STRING))
(CL:DEFUN OBJECT-TO-PARSABLE-STRING (SELF)
  "Return a string representing a printed
representation of the object `self'.  Like `object-to-string', but puts
escaped double quotes around strings."
  (CL:COND
   ((STELLA::SUBTYPE-OF-STRING? (STELLA::SAFE-PRIMARY-TYPE SELF))
    (CL:PROGN
     (STELLA::CONCATENATE "\""
      (STELLA::%STRING-WRAPPER.WRAPPER-VALUE SELF) "\"")))
   (CL:T (OBJECT-TO-STRING SELF))))

;;; (DEFUN (GET-STELLA-TYPE SYMBOL) ...)

(CL:DEFUN GET-STELLA-TYPE (SELF)
  "Return the name symbol of the STELLA class of which `self' is a direct instance."
  (STELLA::TYPE-TO-SYMBOL (STELLA::PRIMARY-TYPE SELF)))

;;; (DEFUN (GET-LOGIC-TYPE SYMBOL) ...)

(CL:DEFUN GET-LOGIC-TYPE (SELF)
  "Return the name symbol of the logic object type of `self'.  This type describes the basic
role this object plays in the logic system such as 'PROPOSITION', 'CONCEPT', 'THING', etc., as indicated by
its native object type, it does not have anything to do with type propositions asserted about `self'."
  (STELLA::TYPE-TO-SYMBOL (STELLA::LOGICAL-TYPE SELF)))

;;; (DEFUN (GET-STELLA-TYPE-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) GET-STELLA-TYPE-NAME))
(CL:DEFUN GET-STELLA-TYPE-NAME (SELF)
  "Return the qualified name of the STELLA class of which `self' is a direct instance."
  (CL:LET* ((TYPE (STELLA::PRIMARY-TYPE SELF)))
   (STELLA::COMPUTE-FULL-NAME (STELLA::%SURROGATE.SYMBOL-NAME TYPE)
    (STELLA::%SURROGATE.HOME-CONTEXT TYPE))))

;;; (DEFUN (GET-STELLA-TYPE-SHORT-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  GET-STELLA-TYPE-SHORT-NAME))
(CL:DEFUN GET-STELLA-TYPE-SHORT-NAME (SELF)
  "Return the unqualified name of the STELLA class of which `self' is a direct instance."
  (STELLA::%SURROGATE.SYMBOL-NAME (STELLA::PRIMARY-TYPE SELF)))

;;; (DEFUN (GET-LOGIC-TYPE-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) GET-LOGIC-TYPE-NAME))
(CL:DEFUN GET-LOGIC-TYPE-NAME (SELF)
  "Return the qualified name of the logic type of `self'."
  (CL:LET* ((TYPE (STELLA::LOGICAL-TYPE SELF)))
   (STELLA::COMPUTE-FULL-NAME (STELLA::%SURROGATE.SYMBOL-NAME TYPE)
    (STELLA::%SURROGATE.HOME-CONTEXT TYPE))))

;;; (DEFUN (GET-LOGIC-TYPE-SHORT-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  GET-LOGIC-TYPE-SHORT-NAME))
(CL:DEFUN GET-LOGIC-TYPE-SHORT-NAME (SELF)
  "Return the unqualified name of the logic type of `self'."
  (STELLA::%SURROGATE.SYMBOL-NAME (STELLA::LOGICAL-TYPE SELF)))

;;; (DEFGLOBAL *LITERAL-CONCEPT* ...)

(CL:DEFVAR *LITERAL-CONCEPT* STELLA::NULL)

;;; (DEFGLOBAL *STRING-CONCEPT* ...)

(CL:DEFVAR *STRING-CONCEPT* STELLA::NULL)

;;; (DEFGLOBAL *INTEGER-CONCEPT* ...)

(CL:DEFVAR *INTEGER-CONCEPT* STELLA::NULL)

;;; (DEFGLOBAL *FLOAT-CONCEPT* ...)

(CL:DEFVAR *FLOAT-CONCEPT* STELLA::NULL)

;;; (DEFUN (STRING-TO-OBJECT OBJECT) ...)

(CL:DEFUN STRING-TO-OBJECT (STRING TYPE MODULE ENVIRONMENT)
  "Evaluate `string' with respect to `module' and `environment'
and return the corresponding logical term.  `type' is a concept used to assist the
correct interpretation of `string'.

Currently `type' only has an effect on the interpretation of literal types."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
  #+MCL
  (CL:CHECK-TYPE STRING CL:SIMPLE-STRING)
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:SETQ MODULE STELLA::*MODULE*)
    (CL:LET* ((OBJ (STELLA::READ-S-EXPRESSION-FROM-STRING STRING)))
     (CL:COND
      ((STELLA::SUBTYPE-OF? (STELLA::SAFE-PRIMARY-TYPE OBJ)
        SGT-PLI-STELLA-LITERAL-WRAPPER)
       (CL:PROGN
        (CL:WHEN (CL:EQ TYPE STELLA::NULL)
         (CL:RETURN-FROM STRING-TO-OBJECT OBJ))
        (CL:LET* ((TEST-VALUE-000 (STELLA::SAFE-PRIMARY-TYPE OBJ)))
         (CL:COND
          ((STELLA::SUBTYPE-OF-STRING? TEST-VALUE-000)
           (CL:PROGN
            (CL:IF (STELLA::SUBRELATION-OF? TYPE *STRING-CONCEPT*) OBJ
             (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
              (STELLA::%%PRINT-STREAM
               (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
               "String argument found, but `" TYPE
               "' is not a subconcept of `" *STRING-CONCEPT* "'")
              (CL:ERROR
               (STELLA::NEW-PARSING-ERROR
                (STELLA::THE-STRING-READER STREAM-000)))))))
          ((STELLA::SUBTYPE-OF-INTEGER? TEST-VALUE-000)
           (CL:PROGN
            (CL:COND
             ((STELLA::SUBRELATION-OF? TYPE *INTEGER-CONCEPT*) OBJ)
             ((STELLA::SUBRELATION-OF? TYPE *FLOAT-CONCEPT*)
              (STELLA::WRAP-FLOAT
               (CL:FLOAT (STELLA::%INTEGER-WRAPPER.WRAPPER-VALUE OBJ)
                0.0d0)))
             (CL:T (GET-OBJECT STRING MODULE ENVIRONMENT)))))
          ((STELLA::SUBTYPE-OF-FLOAT? TEST-VALUE-000)
           (CL:PROGN
            (CL:COND
             ((STELLA::SUBRELATION-OF? TYPE *FLOAT-CONCEPT*) OBJ)
             (CL:T (GET-OBJECT STRING MODULE ENVIRONMENT)))))
          (CL:T
           (CL:LET* ((STREAM-001 (STELLA::NEW-OUTPUT-STRING-STREAM)))
            (STELLA::%%PRINT-STREAM
             (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
             "`" TEST-VALUE-000 "' is not a valid case option")
            (CL:ERROR
             (STELLA::NEW-STELLA-EXCEPTION
              (STELLA::THE-STRING-READER STREAM-001)))))))))
      (CL:T
       (CL:COND
        ((CL:EQ TYPE STELLA::NULL)
         (GET-OBJECT STRING MODULE ENVIRONMENT))
        ((STELLA::SUBRELATION-OF? TYPE *STRING-CONCEPT*)
         (STELLA::WRAP-STRING (STELLA::COPY STRING)))
        ((STELLA::SUBRELATION-OF? TYPE *LITERAL-CONCEPT*)
         (CL:LET* ((STREAM-002 (STELLA::NEW-OUTPUT-STRING-STREAM)))
          (STELLA::%%PRINT-STREAM
           (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002) "`"
           STRING "' is a non-literal, but `" TYPE
           "' is a subconcept of `" *LITERAL-CONCEPT* "'")
          (CL:ERROR
           (STELLA::NEW-PARSING-ERROR
            (STELLA::THE-STRING-READER STREAM-002)))))
        (CL:T (GET-OBJECT STRING MODULE ENVIRONMENT)))))))))

;;; (DEFUN (STRING-TO-STELLA-EXPRESSION OBJECT) ...)

(CL:DEFUN STRING-TO-STELLA-EXPRESSION (EXPRESSION MODULE ENVIRONMENT)
  "Read the STELLA `expression' in `module' and return the result.
Raises a reader exception in case of incorrect STELLA syntax."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING EXPRESSION))
  #+MCL
  (CL:CHECK-TYPE EXPRESSION CL:SIMPLE-STRING)
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (STELLA::READ-S-EXPRESSION-FROM-STRING EXPRESSION))))

;;; (DEFUN (HELP-GET-TRUE-EXTENSION-MEMBERS (CONS OF PROPOSITION)) ...)

(CL:DEFUN HELP-GET-TRUE-EXTENSION-MEMBERS (RELATION SPECIALIZE?)
  (CL:LET* ((VALUE-000 STELLA::NIL))
   (CL:LET*
    ((P STELLA::NULL)
     (ITER-000 (STELLA::ALL-EXTENSION-MEMBERS RELATION))
     (COLLECT-000 STELLA::NULL))
    (CL:LOOP WHILE (STELLA::NEXT? ITER-000) DO
     (CL:SETQ P (STELLA::%ITERATOR.VALUE ITER-000))
     (CL:WHEN
      (CL:AND (CL:NOT (STELLA::DELETED? P))
       (CL:IF STELLA::*REVERSEPOLARITY?* (STELLA::FALSE? P)
        (CL:OR (STELLA::TRUE? P)
         (STELLA::FUNCTION-WITH-DEFINED-VALUE? P))))
      (CL:IF (CL:EQ COLLECT-000 STELLA::NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (STELLA::CONS P STELLA::NIL))
        (CL:IF (CL:EQ VALUE-000 STELLA::NIL)
         (CL:SETQ VALUE-000 COLLECT-000)
         (STELLA::ADD-CONS-TO-END-OF-CONS-LIST VALUE-000 COLLECT-000)))
       (CL:PROGN
        (CL:SETF (STELLA::%%REST COLLECT-000)
         (STELLA::CONS P STELLA::NIL))
        (CL:SETQ COLLECT-000 (STELLA::%%REST COLLECT-000)))))))
   (CL:LET* ((RESULT VALUE-000))
    (CL:WHEN SPECIALIZE?
     (CL:LET*
      ((SUB STELLA::NULL)
       (ITER-001 (STELLA::ALL-SUBCOLLECTIONS RELATION)))
      (CL:LOOP WHILE (STELLA::NEXT? ITER-001) DO
       (CL:SETQ SUB (STELLA::%ITERATOR.VALUE ITER-001))
       (CL:WHEN (STELLA::ISA? SUB SGT-PLI-LOGIC-NAMED-DESCRIPTION)
        (CL:LET*
         ((P STELLA::NULL)
          (ITER-002 (STELLA::ALL-EXTENSION-MEMBERS SUB)))
         (CL:LOOP WHILE (STELLA::NEXT? ITER-002) DO
          (CL:SETQ P (STELLA::%ITERATOR.VALUE ITER-002))
          (CL:WHEN
           (CL:AND (CL:NOT (STELLA::DELETED? P))
            (CL:IF STELLA::*REVERSEPOLARITY?* (STELLA::FALSE? P)
             (CL:OR (STELLA::TRUE? P)
              (STELLA::FUNCTION-WITH-DEFINED-VALUE? P))))
           (CL:SETQ RESULT (STELLA::CONS P RESULT))))))))
     (CL:RETURN-FROM HELP-GET-TRUE-EXTENSION-MEMBERS
      (STELLA::REMOVE-DUPLICATES RESULT)))
    RESULT)))

;;; (DEFUN (HELP-GET-PROPOSITIONS (CONS OF PROPOSITION)) ...)

(CL:DEFUN HELP-GET-PROPOSITIONS (RELATION ARGUMENTS LIMIT MODULE ENVIRONMENT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM LIMIT))
  #+MCL
  (CL:CHECK-TYPE LIMIT CL:FIXNUM)
  (CL:WHEN (CL:EQ RELATION STELLA::NULL)
   (CL:RETURN-FROM HELP-GET-PROPOSITIONS STELLA::NIL))
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:LET*
     ((ASSERTIONSONLY?
       (CL:AND (CL:NOT (CL:EQ ENVIRONMENT STELLA::NULL))
        (STELLA::STRING-EQL? (%ENVIRONMENT.LEVEL ENVIRONMENT)
         "ASSERTION")))
      (SPECIALIZE? (CL:NOT ASSERTIONSONLY?)))
     (CL:LET* ((VALUE-000 STELLA::NULL))
      (CL:LET* ((ARG STELLA::NULL) (ITER-000 ARGUMENTS))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 STELLA::NIL)) DO
        (CL:SETQ ARG (STELLA::%%VALUE ITER-000))
        (CL:WHEN
         (CL:AND (CL:NOT (CL:EQ ARG STELLA::NULL))
          (STELLA::ISA? ARG SGT-PLI-LOGIC-LOGIC-OBJECT))
         (CL:SETQ VALUE-000 ARG) (CL:RETURN))
        (CL:SETQ ITER-000 (STELLA::%%REST ITER-000))))
      (CL:LET*
       ((ARGUMENTWITHBACKLINKS VALUE-000)
        (ITERATOR
         (CL:IF (CL:NOT (CL:EQ ARGUMENTWITHBACKLINKS STELLA::NULL))
          (STELLA::ALL-TRUE-DEPENDENT-PROPOSITIONS
           ARGUMENTWITHBACKLINKS
           (STELLA::%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE RELATION)
           SPECIALIZE?)
          (STELLA::ALLOCATE-ITERATOR
           (HELP-GET-TRUE-EXTENSION-MEMBERS RELATION SPECIALIZE?))))
        (RESULTS STELLA::NIL))
       (CL:WHEN (CL:NOT ASSERTIONSONLY?)
        (CL:SETQ STELLA::*CONTEXT*
         (STELLA::GET-PROPERTY-TEST-CONTEXT)))
       (CL:LET* ((P STELLA::NULL) (ITER-001 ITERATOR))
        (CL:LOOP WHILE (STELLA::NEXT? ITER-001) DO
         (CL:SETQ P (STELLA::%ITERATOR.VALUE ITER-001))
         (CL:LET* ((TEST-VALUE-000 CL:NIL))
          (CL:LET* ((ALWAYS?-000 CL:T))
           (CL:LET*
            ((INPUTARG STELLA::NULL) (ITER-002 ARGUMENTS)
             (ARG2 STELLA::NULL)
             (VECTOR-000 (STELLA::%PROPOSITION.ARGUMENTS P))
             (INDEX-000 0) (LENGTH-000 (STELLA::LENGTH VECTOR-000)))
            (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
            (CL:LOOP WHILE
             (CL:AND (CL:NOT (CL:EQ ITER-002 STELLA::NIL))
              (CL:< INDEX-000 LENGTH-000))
             DO (CL:SETQ INPUTARG (STELLA::%%VALUE ITER-002))
             (CL:SETQ ARG2
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR
                (STELLA::%VECTOR.THE-ARRAY VECTOR-000))
               INDEX-000))
             (CL:WHEN
              (CL:NOT
               (CL:OR (CL:EQ INPUTARG STELLA::NULL)
                (STELLA::EQL? INPUTARG (STELLA::VALUE-OF ARG2))))
              (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
             (CL:SETQ ITER-002 (STELLA::%%REST ITER-002))
             (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
           (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
          (CL:WHEN TEST-VALUE-000
           (CL:SETQ TEST-VALUE-000
            (CL:= (STELLA::LENGTH ARGUMENTS)
             (STELLA::LENGTH (STELLA::%PROPOSITION.ARGUMENTS P)))))
          (CL:WHEN TEST-VALUE-000
           (CL:SETQ RESULTS (STELLA::CONS P RESULTS))
           (CL:SETQ LIMIT (CL:1- LIMIT))
           (CL:WHEN (CL:= LIMIT 0) (CL:RETURN))))))
       RESULTS))))))

;;; (DEFUN (GET-PROPOSITION PROPOSITION) ...)

(CL:DEFUN GET-PROPOSITION (RELATION-AND-ARGUMENTS MODULE ENVIRONMENT)
  "Return a proposition matching `relation-and-arguments' that
has been asserted (or inferred by forward chaining).  `relation-and-arguments'
is a sequence containing objects and nulls.  The first argument must be the
name of a relation.  A null value acts like a wild card.  If more than one 
proposition matches the input criteria, the selection among satisficing
propositions is arbitrary.  This procedure is normally applied to single-valued
relations or functions."
  (CL:LET*
   ((LIST (SEQUENCE-TO-CONS-LIST RELATION-AND-ARGUMENTS))
    (RELATION (STELLA::%%VALUE LIST))
    (ARGUMENTS (STELLA::%%REST LIST)))
   (STELLA::%%VALUE
    (HELP-GET-PROPOSITIONS RELATION ARGUMENTS 1 MODULE ENVIRONMENT))))

;;; (DEFUN (S-GET-PROPOSITION PROPOSITION) ...)

(CL:DEFUN S-GET-PROPOSITION (RELATION-AND-ARGUMENTS MODULE-NAME ENVIRONMENT)
  "Return a proposition matching `relation-and-arguments' that
has been asserted (or inferred by forward chaining).  `relation-and-arguments'
is a string that begins with a left parenthesis, followed by a relation name, 
one or more argument identifiers, and terminated by a right parenthesis.  Each
argument identifier can be the name of a logical constant, a literal reference
such as a number, or the null identifier which acts like a wild card.
If more than one proposition matches the input criteria, the selection among
satisficing propositions is arbitrary.  This procedure is normally applied to
single-valued relations or functions.

A module name of `null' or the empty string refers to the current module.  If no module
with name `module-name' can be found, a STELLA `no-such-context-exception' is thrown."
  (CL:DECLARE
   (CL:TYPE CL:SIMPLE-STRING RELATION-AND-ARGUMENTS MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE RELATION-AND-ARGUMENTS CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (ELEMENTS (EXPLODE-STRING-LIST RELATION-AND-ARGUMENTS MODULE))
    (RELATION (STELLA::%%VALUE ELEMENTS))
    (ARGUMENTS (STELLA::%%REST ELEMENTS)))
   (STELLA::%%VALUE
    (HELP-GET-PROPOSITIONS RELATION ARGUMENTS 1 MODULE ENVIRONMENT))))

;;; (DEFUN (GET-PROPOSITIONS (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN GET-PROPOSITIONS (RELATION-AND-ARGUMENTS MODULE ENVIRONMENT)
  "Return propositions matching `relation-and-arguments' that
have been asserted (or inferred by forward chaining).  `relation-and-arguments'
is a sequence containing objects and nulls.  The first argument must be the
name of a relation.  A null value acts like a wild card."
  (CL:LET*
   ((LIST (SEQUENCE-TO-CONS-LIST RELATION-AND-ARGUMENTS))
    (RELATION (STELLA::%%VALUE LIST))
    (ARGUMENTS (STELLA::%%REST LIST)))
   (CONS-TO-PL-ITERATOR
    (HELP-GET-PROPOSITIONS RELATION ARGUMENTS 0 MODULE ENVIRONMENT))))

;;; (DEFUN (S-GET-PROPOSITIONS (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN S-GET-PROPOSITIONS (RELATION-AND-ARGUMENTS MODULE-NAME ENVIRONMENT)
  "Return propositions matching `relation-and-arguments' that
have been asserted (or inferred by forward chaining).  `relation-and-arguments'
is a string that begins with a left parenthesis, followed by a relation name, 
one or more argument identifiers, and terminated by a right parenthesis.  Each
argument identifier can be the name of a logical constant, a literal 
reference (e.g., a number), or the null identifier which acts like a wild card.

A module name of `null' or the empty string refers to the current module.  If no module
with name `module-name' can be found, a STELLA `no-such-context-exception' is thrown."
  (CL:DECLARE
   (CL:TYPE CL:SIMPLE-STRING RELATION-AND-ARGUMENTS MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE RELATION-AND-ARGUMENTS CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (ELEMENTS (EXPLODE-STRING-LIST RELATION-AND-ARGUMENTS MODULE))
    (RELATION (STELLA::%%VALUE ELEMENTS))
    (ARGUMENTS (STELLA::%%REST ELEMENTS)))
   (CONS-TO-PL-ITERATOR
    (HELP-GET-PROPOSITIONS RELATION ARGUMENTS 0 MODULE ENVIRONMENT))))

;;; (DEFUN (GET-INCONSISTENT-PROPOSITIONS (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN GET-INCONSISTENT-PROPOSITIONS (MODULE ENVIRONMENT)
  "Return inconsistent propositions visible in `module'."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:SETQ MODULE STELLA::*MODULE*)
    (ITERATOR-TO-PL-ITERATOR
     (STELLA::ALL-INCONSISTENT-PROPOSITIONS MODULE CL:NIL)))))

;;; (DEFUN (GET-UNARY-PROPOSITIONS (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN GET-UNARY-PROPOSITIONS (RELATION ARG MODULE ENVIRONMENT)
  "Return propositions such that (`relation' `arg')
is true.  The `relation' argument must be bound to a relation.  `arg' may be
set to NULL, which is interpreted as a wildcard."
  (CONS-TO-PL-ITERATOR
   (HELP-GET-PROPOSITIONS RELATION (STELLA::CONS-LIST ARG) 0 MODULE
    ENVIRONMENT)))

;;; (DEFUN (GET-BINARY-PROPOSITION PROPOSITION) ...)

(CL:DEFUN GET-BINARY-PROPOSITION (RELATION ARG1 ARG2 MODULE ENVIRONMENT)
  "Return a proposition such that (`relation' `arg1' `arg2')
is true.  The `relation' argument must be bound to a relation.  One or both
of the `arg1' and `arg2' arguments may be set to NULL, which is interpreted
as a wildcard. If more than one proposition matches the input criteria,
the selection is arbitrary.  This procedure is normally applied to single-valued
relations or functions."
  (STELLA::%%VALUE
   (HELP-GET-PROPOSITIONS RELATION (STELLA::CONS-LIST ARG1 ARG2) 1
    MODULE ENVIRONMENT)))

;;; (DEFUN (GET-BINARY-PROPOSITIONS (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN GET-BINARY-PROPOSITIONS (RELATION ARG1 ARG2 MODULE ENVIRONMENT)
  "Return propositions such that (`relation' `arg1' `arg2')
is true.  The `relation' argument must be bound to a relation.  One or both
of the `arg1' and `arg2' arguments may be set to NULL, which is interpreted
as a wildcard."
  (CONS-TO-PL-ITERATOR
   (HELP-GET-PROPOSITIONS RELATION (STELLA::CONS-LIST ARG1 ARG2) 0
    MODULE ENVIRONMENT)))

;;; (DEFUN (GET-INFERRED-BINARY-PROPOSITION-VALUES PL-ITERATOR) ...)

(CL:DEFUN GET-INFERRED-BINARY-PROPOSITION-VALUES (RELATION ARG MODULE ENVIRONMENT)
  "Return all values `v' such that (`relation' `arg' `v')
has been asserted or can be inferred via a general PowerLoom `retrieve'.
Both `relation' and `arg' have to be non-NULL."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:IF
     (CL:AND (CL:NOT (CL:EQ RELATION STELLA::NULL))
      (CL:NOT (CL:EQ ARG STELLA::NULL)))
     (CONS-TO-PL-ITERATOR
      (STELLA::APPLY-CACHED-RETRIEVE
       (STELLA::LIST* SYM-PLI-PLI-?R SYM-PLI-PLI-?I SYM-PLI-PLI-?V
        STELLA::NIL)
       (STELLA::LIST* SYM-PLI-PLI-?R SYM-PLI-PLI-?I SYM-PLI-PLI-?V
        STELLA::NIL)
       (STELLA::CONS-LIST RELATION ARG STELLA::NULL)
       (STELLA::CONS-LIST)
       SYM-PLI-PLI-F-GET-INFERRED-BINARY-PROPOSITION-VALUES-QUERY-000))
     EMPTY-PL-ITERATOR))))

;;; (DEFUN (S-GET-INFERRED-BINARY-PROPOSITION-VALUES PL-ITERATOR) ...)

(CL:DEFUN S-GET-INFERRED-BINARY-PROPOSITION-VALUES (RELATION-NAME ARG-NAME MODULE-NAME ENVIRONMENT)
  "Return all values `v' such that (`relation-name' `arg-name' `v')
has been asserted or can be inferred via a general PowerLoom `retrieve'.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a STELLA
`no-such-context-exception' is thrown."
  (CL:DECLARE
   (CL:TYPE CL:SIMPLE-STRING RELATION-NAME ARG-NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE RELATION-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE ARG-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (RELATION (SAFELY-GET-RELATION RELATION-NAME MODULE ENVIRONMENT))
    (OBJECT (SAFELY-GET-OBJECT ARG-NAME MODULE ENVIRONMENT)))
   (GET-INFERRED-BINARY-PROPOSITION-VALUES RELATION OBJECT MODULE
    ENVIRONMENT)))

;;; (DEFUN (GET-PROPOSITIONS-OF (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN GET-PROPOSITIONS-OF (OBJECT MODULE ENVIRONMENT)
  "Return all propositions that have `object' among their arguments,
and that are TRUE in the scope of the module `module'."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:IF (CL:NOT (CL:EQ OBJECT STELLA::NULL))
     (LIST-TO-PL-ITERATOR
      (STELLA::ALL-FACTS-OF-INSTANCE OBJECT CL:NIL CL:NIL))
     EMPTY-PL-ITERATOR))))

;;; (DEFUN (S-GET-PROPOSITIONS-OF (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN S-GET-PROPOSITIONS-OF (OBJECT-NAME MODULE-NAME ENVIRONMENT)
  "Return all propositions that have the object named `object-name' among
their arguments, and that are TRUE in the scope of the module `module-name'.
A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING OBJECT-NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE OBJECT-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (OBJECT (SAFELY-GET-OBJECT OBJECT-NAME MODULE ENVIRONMENT)))
   (GET-PROPOSITIONS-OF OBJECT MODULE ENVIRONMENT)))

;;; (DEFUN (GET-PROPOSITIONS-IN-MODULE (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN GET-PROPOSITIONS-IN-MODULE (MODULE ENVIRONMENT)
  "Return propositions that have been locally conceived in
the module `module' (but are not necessarily true)."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:SETQ MODULE STELLA::*MODULE*)
    (CONS-TO-PL-ITERATOR
     (STELLA::CONSIFY (STELLA::ALL-PROPOSITIONS MODULE CL:T))))))

;;; (DEFUN (IS-TRUE-UNARY-PROPOSITION BOOLEAN) ...)

(CL:DEFUN IS-TRUE-UNARY-PROPOSITION (RELATION ARG MODULE ENVIRONMENT)
  "Return TRUE if the proposition (`relation' `arg') has
been asserted (or inferred by forward chaining)."
  (CL:NOT
   (CL:EQ
    (HELP-GET-PROPOSITIONS RELATION (STELLA::CONS-LIST ARG) 1 MODULE
     ENVIRONMENT)
    STELLA::NIL)))

;;; (DEFUN (IS-TRUE-BINARY-PROPOSITION BOOLEAN) ...)

(CL:DEFUN IS-TRUE-BINARY-PROPOSITION (RELATION ARG VALUE MODULE ENVIRONMENT)
  "Return TRUE if the proposition (`relation' `arg' `value') has
been asserted (or inferred by forward chaining)."
  (CL:NOT
   (CL:EQ
    (GET-BINARY-PROPOSITION RELATION ARG VALUE MODULE ENVIRONMENT)
    STELLA::NULL)))

;;; (DEFUN (IS-TRUE-NARY-PROPOSITION BOOLEAN) ...)

(CL:DEFUN IS-TRUE-NARY-PROPOSITION (RELATION-AND-ARGUMENTS MODULE ENVIRONMENT)
  "Return TRUE if a proposition (`relation' `args') has
been asserted (or inferred by forward chaining)."
  (CL:NOT
   (CL:EQ (GET-PROPOSITION RELATION-AND-ARGUMENTS MODULE ENVIRONMENT)
    STELLA::NULL)))

;;; (DEFUN (S-IS-TRUE-NARY-PROPOSITION BOOLEAN) ...)

(CL:DEFUN S-IS-TRUE-NARY-PROPOSITION (RELATION-AND-ARGUMENTS MODULE-NAME ENVIRONMENT)
  "Return TRUE if a proposition that prints as the string
`relation-and-arguments' is true in the module named `module-name'.
A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown."
  (CL:DECLARE
   (CL:TYPE CL:SIMPLE-STRING RELATION-AND-ARGUMENTS MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE RELATION-AND-ARGUMENTS CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:NOT
   (CL:EQ
    (S-GET-PROPOSITION RELATION-AND-ARGUMENTS MODULE-NAME ENVIRONMENT)
    STELLA::NULL)))

;;; (DEFUN (IS-TRUE-PROPOSITION BOOLEAN) ...)

(CL:DEFUN IS-TRUE-PROPOSITION (PROPOSITION MODULE ENVIRONMENT)
  "Return TRUE if `proposition' is TRUE in the module `module'."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:AND (CL:NOT (STELLA::DELETED? PROPOSITION))
     (CL:IF STELLA::*REVERSEPOLARITY?* (STELLA::FALSE? PROPOSITION)
      (CL:OR (STELLA::TRUE? PROPOSITION)
       (STELLA::FUNCTION-WITH-DEFINED-VALUE? PROPOSITION)))))))

;;; (DEFUN (IS-SUBRELATION BOOLEAN) ...)

(CL:DEFUN IS-SUBRELATION (SUB SUPER MODULE ENVIRONMENT)
  "Return TRUE if `sub' is a subconcept/subrelation of `super'."
  (CL:WHEN (CL:OR (CL:EQ SUB STELLA::NULL) (CL:EQ SUPER STELLA::NULL))
   (CL:RETURN-FROM IS-SUBRELATION CL:NIL))
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (STELLA::TRUE-TRUTH-VALUE?
     (STELLA::DESCRIPTION-SPECIALIZES-DESCRIPTION? SUB SUPER)))))

;;; (DEFUN (GET-PROPER-SUBRELATIONS (PL-ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN GET-PROPER-SUBRELATIONS (RELATION MODULE ENVIRONMENT)
  "Return relations that specialize `relation'.
Non-reflexive."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CONS-TO-PL-ITERATOR (STELLA::ALL-SUBRELATIONS RELATION CL:T)))))

;;; (DEFUN (GET-DIRECT-SUBRELATIONS (PL-ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN GET-DIRECT-SUBRELATIONS (RELATION MODULE ENVIRONMENT)
  "Return relations that directly specialize `relation'.
Non-reflexive."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CONS-TO-PL-ITERATOR
     (STELLA::ALL-DIRECT-SUBRELATIONS RELATION CL:T)))))

;;; (DEFUN (GET-PROPER-SUPERRELATIONS (PL-ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN GET-PROPER-SUPERRELATIONS (RELATION MODULE ENVIRONMENT)
  "Return relations that generalize `relation'.
Non-reflexive."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CONS-TO-PL-ITERATOR (STELLA::ALL-SUPERRELATIONS RELATION CL:T)))))

;;; (DEFUN (GET-DIRECT-SUPERRELATIONS (PL-ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN GET-DIRECT-SUPERRELATIONS (RELATION MODULE ENVIRONMENT)
  "Return relations that directly generalize `relation'.
Non-reflexive."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CONS-TO-PL-ITERATOR
     (STELLA::ALL-DIRECT-SUPERRELATIONS RELATION CL:T)))))

;;; (DEFUN (IS-INSTANCE BOOLEAN) ...)

(CL:DEFUN IS-INSTANCE (OBJECT CONCEPT MODULE ENVIRONMENT)
  "Return TRUE if `object' is an instance of the concept `concept'.  This uses subsumption inference only."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (STELLA::TEST-ISA? OBJECT
     (STELLA::%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE CONCEPT)))))

;;; (DEFUN (IS-A BOOLEAN) ...)

(CL:DEFUN IS-A (OBJECT CONCEPT MODULE ENVIRONMENT)
  "Deprecated - use `is-instance' instead."
  (IS-INSTANCE OBJECT CONCEPT MODULE ENVIRONMENT))

;;; (DEFUN (GET-CONCEPT-INSTANCES PL-ITERATOR) ...)

(CL:DEFUN GET-CONCEPT-INSTANCES (CONCEPT MODULE ENVIRONMENT)
  "Return instances of the concept `concept'.
Include instances of subconcepts of `concept'.  Depending on `concept',
the return values could be (wrapped) literals."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:SETQ MODULE STELLA::*MODULE*)
    (CL:IF
     (CL:AND (CL:NOT (CL:EQ ENVIRONMENT STELLA::NULL))
      (STELLA::STRING-EQL? (%ENVIRONMENT.LEVEL ENVIRONMENT)
       "ASSERTION"))
     (LIST-TO-PL-ITERATOR
      (STELLA::REMOVE-DELETED-MEMBERS
       (STELLA::ASSERTED-COLLECTION-MEMBERS CONCEPT CL:NIL)))
     (RETRIEVE
      (STELLA::LIST* SYM-PLI-LOGIC-ALL SYM-PLI-LOGIC-?X
       (STELLA::CONS (STELLA::OBJECT-NAME CONCEPT)
        (STELLA::CONS SYM-PLI-LOGIC-?X STELLA::NIL))
       STELLA::NIL)
      MODULE ENVIRONMENT)))))

;;; (DEFUN (S-GET-CONCEPT-INSTANCES PL-ITERATOR) ...)

(CL:DEFUN S-GET-CONCEPT-INSTANCES (CONCEPT-NAME MODULE-NAME ENVIRONMENT)
  "Return instances of concept `concept-name'.
Include instances of subconcepts of `concept-name'.  Depending on `concept-name',
the return values could be (wrapped) literals.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING CONCEPT-NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE CONCEPT-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (CONCEPT (SAFELY-GET-CONCEPT CONCEPT-NAME MODULE ENVIRONMENT)))
   (CL:IF
    (CL:AND (CL:NOT (CL:EQ MODULE STELLA::NULL))
     (CL:NOT (CL:EQ CONCEPT STELLA::NULL)))
    (GET-CONCEPT-INSTANCES CONCEPT MODULE ENVIRONMENT)
    EMPTY-PL-ITERATOR)))

;;; (DEFUN (GET-DIRECT-CONCEPT-INSTANCES PL-ITERATOR) ...)

(CL:DEFUN GET-DIRECT-CONCEPT-INSTANCES (CONCEPT MODULE ENVIRONMENT)
  "Return instances of concept `concept'.
Exclude instances of subconcepts of `concept'.  Depending on `concept',
the return values could be (wrapped) literals."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:SETQ MODULE STELLA::*MODULE*)
    (CL:IF
     (CL:AND (CL:NOT (CL:EQ ENVIRONMENT STELLA::NULL))
      (STELLA::STRING-EQL? (%ENVIRONMENT.LEVEL ENVIRONMENT)
       "ASSERTION"))
     (LIST-TO-PL-ITERATOR
      (STELLA::REMOVE-DELETED-MEMBERS
       (STELLA::ASSERTED-COLLECTION-MEMBERS CONCEPT CL:T)))
     (RETRIEVE
      (STELLA::LIST* SYM-PLI-LOGIC-ALL SYM-PLI-LOGIC-?X
       (STELLA::LIST* SYM-PLI-STELLA-AND
        (STELLA::CONS (STELLA::OBJECT-NAME CONCEPT)
         (STELLA::CONS SYM-PLI-LOGIC-?X STELLA::NIL))
        (STELLA::LIST* SYM-PLI-LOGIC-FAIL
         (STELLA::LIST* SYM-PLI-STELLA-EXISTS
          (STELLA::CONS SYM-PLI-LOGIC-?Y STELLA::NIL)
          (STELLA::LIST* SYM-PLI-STELLA-AND
           (STELLA::LIST* SYM-PLI-PLI-PROPER-SUBRELATION
            (STELLA::OBJECT-NAME CONCEPT)
            (STELLA::CONS SYM-PLI-LOGIC-?Y STELLA::NIL))
           (STELLA::LIST* SYM-PLI-LOGIC-?Y SYM-PLI-LOGIC-?X
            STELLA::NIL)
           STELLA::NIL)
          STELLA::NIL)
         STELLA::NIL)
        STELLA::NIL)
       STELLA::NIL)
      MODULE ENVIRONMENT)))))

;;; (DEFUN (S-GET-DIRECT-CONCEPT-INSTANCES PL-ITERATOR) ...)

(CL:DEFUN S-GET-DIRECT-CONCEPT-INSTANCES (CONCEPT-NAME MODULE-NAME ENVIRONMENT)
  "Return instances of concept `concept-name'.
Exclude instances of subconcepts of `concept-name'.  Depending on `concept-name',
the return values could be (wrapped) literals.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING CONCEPT-NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE CONCEPT-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (CONCEPT (SAFELY-GET-CONCEPT CONCEPT-NAME MODULE ENVIRONMENT)))
   (CL:IF (CL:NOT (CL:EQ CONCEPT STELLA::NULL))
    (GET-DIRECT-CONCEPT-INSTANCES CONCEPT MODULE ENVIRONMENT)
    EMPTY-PL-ITERATOR)))

;;; (DEFUN (GET-CONCEPT-INSTANCES-MATCHING-VALUE PL-ITERATOR) ...)

(CL:DEFUN GET-CONCEPT-INSTANCES-MATCHING-VALUE (CONCEPT RELATION VALUE MODULE ENVIRONMENT)
  "Return members of concept `concept' that
have an attribute matching `value' for the binary relation `relation', i.e.,
`(relation <result> value)' holds."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:SETQ MODULE STELLA::*MODULE*)
    (CL:LET*
     ((INSTANCES (GET-CONCEPT-INSTANCES CONCEPT MODULE ENVIRONMENT))
      (ANSWERS STELLA::NIL))
     (CL:LET* ((I STELLA::NULL) (ITER-000 INSTANCES))
      (CL:LOOP WHILE (STELLA::NEXT? ITER-000) DO
       (CL:SETQ I (%PL-ITERATOR.VALUE ITER-000))
       (CL:WHEN
        (IS-TRUE-BINARY-PROPOSITION RELATION I VALUE MODULE
         ENVIRONMENT)
        (CL:SETQ ANSWERS (STELLA::CONS I ANSWERS)))))
     (CONS-TO-PL-ITERATOR ANSWERS)))))

;;; (DEFUN (GET-CONCEPT-INSTANCE-MATCHING-VALUE OBJECT) ...)

(CL:DEFUN GET-CONCEPT-INSTANCE-MATCHING-VALUE (CONCEPT RELATION VALUE MODULE ENVIRONMENT)
  "Return a member of concept `concept' that
has an attribute matching `value' for the binary relation `relation', i.e.,
`(relation <result> value)' holds."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:SETQ MODULE STELLA::*MODULE*)
    (CL:LET*
     ((INSTANCES (GET-CONCEPT-INSTANCES CONCEPT MODULE ENVIRONMENT)))
     (CL:LET* ((I STELLA::NULL) (ITER-000 INSTANCES))
      (CL:LOOP WHILE (STELLA::NEXT? ITER-000) DO
       (CL:SETQ I (%PL-ITERATOR.VALUE ITER-000))
       (CL:WHEN
        (IS-TRUE-BINARY-PROPOSITION RELATION I VALUE MODULE
         ENVIRONMENT)
        (CL:RETURN-FROM GET-CONCEPT-INSTANCE-MATCHING-VALUE I))))
     STELLA::NULL))))

;;; (DEFUN (HELP-GET-TYPES (CONS OF LOGIC-OBJECT)) ...)

(CL:DEFUN HELP-GET-TYPES (OBJECT MODULE ENVIRONMENT)
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:LET* ((DERIVABLETYPES STELLA::NIL))
     (CL:COND
      ((CL:OR (CL:EQ ENVIRONMENT STELLA::NULL)
        (CL:AND (CL:NOT (CL:EQ ENVIRONMENT STELLA::NULL))
         (STELLA::STRING-EQL? (%ENVIRONMENT.LEVEL ENVIRONMENT)
          "INFERENCE")))
       (CL:SETQ DERIVABLETYPES (STELLA::ALL-TYPES OBJECT)))
      ((CL:AND (CL:NOT (CL:EQ ENVIRONMENT STELLA::NULL))
        (STELLA::STRING-EQL? (%ENVIRONMENT.LEVEL ENVIRONMENT)
         "ASSERTION"))
       (CL:SETQ DERIVABLETYPES (STELLA::ALL-ASSERTED-TYPES OBJECT)))
      ((CL:AND (CL:NOT (CL:EQ ENVIRONMENT STELLA::NULL))
        (STELLA::STRING-EQL? (%ENVIRONMENT.LEVEL ENVIRONMENT)
         "TAXONOMIC"))
       (CL:SETQ DERIVABLETYPES (STELLA::ALL-TAXONOMIC-TYPES OBJECT))))
     DERIVABLETYPES))))

;;; (DEFUN (GET-TYPES (PL-ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN GET-TYPES (OBJECT MODULE ENVIRONMENT)
  "Return all named concepts that `object' belongs to."
  (CONS-TO-PL-ITERATOR (HELP-GET-TYPES OBJECT MODULE ENVIRONMENT)))

;;; (DEFUN (GET-DIRECT-TYPES (PL-ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN GET-DIRECT-TYPES (OBJECT MODULE ENVIRONMENT)
  "Return most specific concepts that `object' belongs to."
  (CONS-TO-PL-ITERATOR
   (STELLA::MOST-SPECIFIC-NAMED-DESCRIPTIONS
    (STELLA::COPY-CONS-LIST
     (HELP-GET-TYPES OBJECT MODULE ENVIRONMENT)))))

;;; (DEFUN (GET-RELATION-EXTENSION (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN GET-RELATION-EXTENSION (RELATION MODULE ENVIRONMENT)
  "Return propositions that satisfy `relation'.
Include propositions that satisfy subrelations of `relation'."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CONS-TO-PL-ITERATOR
     (HELP-GET-TRUE-EXTENSION-MEMBERS RELATION
      (CL:NOT
       (CL:AND (CL:NOT (CL:EQ ENVIRONMENT STELLA::NULL))
        (STELLA::STRING-EQL? (%ENVIRONMENT.LEVEL ENVIRONMENT)
         "ASSERTION"))))))))

;;; (DEFUN (S-GET-RELATION-EXTENSION (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN S-GET-RELATION-EXTENSION (RELATION-NAME MODULE-NAME ENVIRONMENT)
  "Return propositions that satisfy the relation named
`relation-name'.  Include propositions that satisfy subrelations of the relation."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RELATION-NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE RELATION-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (RELATION (SAFELY-GET-RELATION RELATION-NAME MODULE ENVIRONMENT)))
   (CL:IF (CL:NOT (CL:EQ RELATION STELLA::NULL))
    (GET-RELATION-EXTENSION RELATION MODULE ENVIRONMENT)
    EMPTY-PL-ITERATOR)))

;;; (DEFUN (GET-MODULE MODULE) ...)

(CL:DEFUN GET-MODULE (NAME ENVIRONMENT)
  "Return a module named `name' or NULL if no such module exists."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:SETQ ENVIRONMENT ENVIRONMENT)
  (STELLA::GET-STELLA-MODULE NAME CL:NIL))

;;; (DEFUN (GET-EXISTING-MODULE MODULE) ...)

(CL:DEFUN GET-EXISTING-MODULE (NAME ENVIRONMENT)
  "Return the module named `name' or raise a STELLA `no-such-context-exception' if it doesn't exist."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:SETQ ENVIRONMENT ENVIRONMENT)
  (STELLA::GET-STELLA-MODULE NAME CL:T))

;;; (DEFUN (GET-CURRENT-MODULE MODULE) ...)

(CL:DEFUN GET-CURRENT-MODULE (ENVIRONMENT)
  "Return the currently set module"
  (CL:SETQ ENVIRONMENT ENVIRONMENT)
  STELLA::*MODULE*)

;;; (DEFUN (GET-HOME-MODULE MODULE) ...)

(CL:DEFUN GET-HOME-MODULE (OBJECT)
  "Return the module in which `object' was created."
  (STELLA::HOME-MODULE OBJECT))

;;; (DEFUN (GET-MODULES (PL-ITERATOR OF MODULE)) ...)

(CL:DEFUN GET-MODULES (KB-MODULES-ONLY?)
  "Return all modules currently loaded into PowerLoom.  If `kb-modules-only?'
is `true', then Stella modules that are used only for program code are
not included in the list."
  (CONS-TO-PL-ITERATOR (STELLA::%LIST-MODULES KB-MODULES-ONLY?)))

;;; (DEFUN (CREATE-MODULE MODULE) ...)

(CL:DEFUN CREATE-MODULE (NAME PARENT CASE-SENSITIVE?)
  "Creates a new module `name' as a child of `parent'.  The flag
`case-sensitive?' controls whether names read in this module will be
case sensitive or not."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((FULL-NAME
     (CL:IF (CL:NOT (CL:EQ PARENT STELLA::NULL))
      (STELLA::CONCATENATE (STELLA::%MODULE.MODULE-FULL-NAME PARENT)
       "/" NAME)
      NAME))
    (CASE-SENSITIVE-SYMBOL
     (CL:IF CASE-SENSITIVE? SYM-PLI-STELLA-TRUE SYM-PLI-STELLA-FALSE)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FULL-NAME))
   (STELLA::DEFINE-MODULE FULL-NAME
    (STELLA::LIST* KWD-PLI-CASE-SENSITIVE? CASE-SENSITIVE-SYMBOL
     STELLA::NIL))))

;;; (DEFUN (S-CREATE-MODULE MODULE) ...)

(CL:DEFUN S-CREATE-MODULE (NAME PARENT-NAME CASE-SENSITIVE? ENVIRONMENT)
  "Creates a new module `name' as a child of `parent-name'.  The flag
`case-sensitive?' controls whether names read in this module will be
case sensitive or not."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME PARENT-NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE PARENT-NAME CL:SIMPLE-STRING)
  (CREATE-MODULE NAME (SAFELY-GET-MODULE PARENT-NAME ENVIRONMENT)
   CASE-SENSITIVE?))

;;; (DEFUN (CHANGE-MODULE MODULE) ...)

(CL:DEFUN CHANGE-MODULE (MODULE)
  "Set the current module to `module' and return it.
If `module' is `null', then no switch is performed and the current
module is returned."
  (CL:WHEN (CL:EQ MODULE STELLA::NULL)
   (CL:RETURN-FROM CHANGE-MODULE STELLA::*MODULE*))
  (STELLA::CHANGE-MODULE MODULE))

;;; (DEFUN (S-CHANGE-MODULE MODULE) ...)

(CL:DEFUN S-CHANGE-MODULE (NAME ENVIRONMENT)
  "Set the current module to the module named `name'.
The return value is the module named `name' unless `name' is null or
the empty string.  In that case, the current module is returned.
If no module named `name' exists, a Stella `no-such-context-exception'
is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CHANGE-MODULE (SAFELY-GET-MODULE NAME ENVIRONMENT)))

;;; (DEFUN (CLEAR-MODULE MODULE) ...)

(CL:DEFUN CLEAR-MODULE (MODULE)
  "Destroy the contents of the module `module' as well as
the contents of all of its children, recursively."
  (STELLA::CALL-CLEAR-MODULE (STELLA::CONS-LIST MODULE))
  MODULE)

;;; (DEFUN (S-CLEAR-MODULE MODULE) ...)

(CL:DEFUN S-CLEAR-MODULE (NAME ENVIRONMENT)
  "Destroy the contents of the module named `name', as
well as the contents of all of its children, recursively.  If no module
named `name' exists, a Stella `no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((MODULE (SAFELY-GET-MODULE NAME ENVIRONMENT)))
   (STELLA::CALL-CLEAR-MODULE (STELLA::CONS-LIST MODULE)) MODULE))

;;; (DEFUN (GET-CHILD-MODULES (PL-ITERATOR OF MODULE)) ...)

(CL:DEFUN GET-CHILD-MODULES (MODULE)
  "Return the modules that are immediate children of `module'."
  (CL:LET* ((DIRECTSUBMODULES STELLA::NIL))
   (CL:LET*
    ((CHILD STELLA::NULL)
     (ITER-000
      (STELLA::%LIST.THE-CONS-LIST
       (STELLA::%MODULE.CHILD-CONTEXTS MODULE)))
     (COLLECT-000 STELLA::NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 STELLA::NIL)) DO
     (CL:SETQ CHILD (STELLA::%%VALUE ITER-000))
     (CL:WHEN (STELLA::ISA? CHILD SGT-PLI-STELLA-MODULE)
      (CL:IF (CL:EQ COLLECT-000 STELLA::NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (STELLA::CONS CHILD STELLA::NIL))
        (CL:IF (CL:EQ DIRECTSUBMODULES STELLA::NIL)
         (CL:SETQ DIRECTSUBMODULES COLLECT-000)
         (STELLA::ADD-CONS-TO-END-OF-CONS-LIST DIRECTSUBMODULES
          COLLECT-000)))
       (CL:PROGN
        (CL:SETF (STELLA::%%REST COLLECT-000)
         (STELLA::CONS CHILD STELLA::NIL))
        (CL:SETQ COLLECT-000 (STELLA::%%REST COLLECT-000)))))
     (CL:SETQ ITER-000 (STELLA::%%REST ITER-000))))
   (CONS-TO-PL-ITERATOR DIRECTSUBMODULES)))

;;; (DEFUN (S-GET-CHILD-MODULES (PL-ITERATOR OF MODULE)) ...)

(CL:DEFUN S-GET-CHILD-MODULES (NAME ENVIRONMENT)
  "Return the modules that are immediate children of module `name'.
If no module named `name' exists, a Stella `no-such-context-exception'
is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (GET-CHILD-MODULES (SAFELY-GET-MODULE NAME ENVIRONMENT)))

;;; (DEFUN (GET-PARENT-MODULES (PL-ITERATOR OF MODULE)) ...)

(CL:DEFUN GET-PARENT-MODULES (MODULE)
  "Return the modules that are immediate parents of `module'."
  (LIST-TO-PL-ITERATOR (STELLA::%MODULE.PARENT-MODULES MODULE)))

;;; (DEFUN (S-GET-PARENT-MODULES (PL-ITERATOR OF MODULE)) ...)

(CL:DEFUN S-GET-PARENT-MODULES (NAME ENVIRONMENT)
  "Return the modules that are immediate parents of module `name'.
If no module named `name' exists, a Stella `no-such-context-exception'
is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (GET-PARENT-MODULES (SAFELY-GET-MODULE NAME ENVIRONMENT)))

;;; (DEFUN (GENERATE-UNIQUE-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING CL:T CL:T) CL:SIMPLE-STRING)
  GENERATE-UNIQUE-NAME))
(CL:DEFUN GENERATE-UNIQUE-NAME (PREFIX MODULE ENVIRONMENT)
  "Generates a name based on `prefix' with a number appended that
is not currently in use in `module.'  In a non-case-sensitive module, the returned
name will be all upper case (This latter feature may change!)"
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PREFIX))
  #+MCL
  (CL:CHECK-TYPE PREFIX CL:SIMPLE-STRING)
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:SETQ MODULE STELLA::*MODULE*)
    (CL:WHEN
     (CL:NOT
      (CL:OR (STELLA::%MODULE.CASE-SENSITIVE? MODULE)
       (STELLA::ALL-UPPER-CASE-STRING? PREFIX)))
     (CL:SETQ PREFIX (STELLA::STRING-UPCASE PREFIX)))
    (STELLA::YIELD-UNIQUE-GENSYM-NAME PREFIX MODULE))))

;;; (DEFUN (CREATE-KEYWORD KEYWORD) ...)

(CL:DEFUN CREATE-KEYWORD (NAME)
  "Returns the Stella keyword `name', creating it if
necessary.  `name' is treated literally and case-sensitively.
This should generally not be necessary to do."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE NAME STELLA::*MODULE*
   STELLA::KEYWORD-SYM))

;;; (DEFUN (CREATE-SYMBOL SYMBOL) ...)

(CL:DEFUN CREATE-SYMBOL (NAME MODULE ENVIRONMENT)
  "Returns the Stella symbol `name' visible in `module',
creating it if necessary.  `name' is treated literally and ALWAYS case-sensitively,
even if `module' is case insensitive. This should generally not be necessary to do."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:SETQ MODULE STELLA::*MODULE*)
    (STELLA::INTERN-SYMBOL-IN-MODULE NAME MODULE CL:NIL))))

;;; (DEFUN (CREATE-OBJECT LOGIC-OBJECT) ...)

(CL:DEFUN CREATE-OBJECT (NAME CONCEPT MODULE ENVIRONMENT)
  "Create an object named `name' of type `concept' in the designated
module.  Both `name' and `concept' can be `null'.  If `name' is `null' then an
object will be created with a new, non-conflicting name based on the name of
`concept', or system-generated if no concept is specified.  If `concept' is
`null', then the object will be of type THING.  It is an error to create an
object with the same name as an existing object.

Note that the string can be a qualified name, in which case the object
will be created in the module specified, but with a name as determined
by the qualified name.  Vertical bars in the name string are interpreted
as Stella escape characters.

Note that because names in modules that are not case-sensitive are
canonicalized, the name of the returned object may not match `name'
exactly.

Return the object."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:SETQ MODULE STELLA::*MODULE*)
    (CL:LET*
     ((OBJECT STELLA::NULL) (NAME-SYMBOL STELLA::NULL)
      (OBJECT-SURROGATE STELLA::NULL))
     (CL:COND
      ((CL:NOT (CL:EQ NAME STELLA::NULL-STRING))
       (CL:SETQ NAME-SYMBOL (STELLA::INTERN-STELLA-NAME NAME)))
      ((CL:NOT (CL:EQ CONCEPT STELLA::NULL))
       (CL:SETQ NAME-SYMBOL
        (STELLA::INTERN-SYMBOL (GET-SHORT-NAME CONCEPT)))
       (CL:SETQ NAME-SYMBOL
        (STELLA::INTERN-SYMBOL-IN-MODULE
         (GENERATE-UNIQUE-NAME
          (STELLA::%SYMBOL.SYMBOL-NAME NAME-SYMBOL)
          (STELLA::%SYMBOL.HOME-CONTEXT NAME-SYMBOL) STELLA::NULL)
         (STELLA::%SYMBOL.HOME-CONTEXT NAME-SYMBOL) CL:T)))
      (CL:T
       (CL:SETQ NAME-SYMBOL
        (STELLA::INTERN-SYMBOL-IN-MODULE
         (GENERATE-UNIQUE-NAME "I" STELLA::NULL STELLA::NULL) MODULE
         CL:T))))
     (CL:SETQ OBJECT-SURROGATE
      (STELLA::LOOKUP-SURROGATE-IN-MODULE
       (STELLA::%SYMBOL.SYMBOL-NAME NAME-SYMBOL)
       (STELLA::%SYMBOL.HOME-CONTEXT NAME-SYMBOL) CL:NIL))
     (CL:WHEN (CL:EQ OBJECT-SURROGATE STELLA::NULL)
      (CL:SETQ OBJECT-SURROGATE
       (STELLA::INTERN-SURROGATE-IN-MODULE
        (STELLA::%SYMBOL.SYMBOL-NAME NAME-SYMBOL)
        (STELLA::%SYMBOL.HOME-CONTEXT NAME-SYMBOL) CL:NIL)))
     (CL:SETQ OBJECT
      (STELLA::HELP-CREATE-LOGIC-INSTANCE OBJECT-SURROGATE
       STELLA::NULL))
     (CL:WHEN (CL:NOT (CL:EQ CONCEPT STELLA::NULL))
      (CL:IF
       (CL:NOT
        (CL:EQ
         (ASSERT-UNARY-PROPOSITION CONCEPT OBJECT MODULE ENVIRONMENT)
         STELLA::NULL))
       (CL:RETURN-FROM CREATE-OBJECT OBJECT)
       (CL:RETURN-FROM CREATE-OBJECT STELLA::NULL)))
     OBJECT))))

;;; (DEFUN (S-CREATE-OBJECT LOGIC-OBJECT) ...)

(CL:DEFUN S-CREATE-OBJECT (NAME CONCEPT-NAME MODULE-NAME ENVIRONMENT)
  "Create an object named `name' of type `concept-name' in the designated
module.  Both `name' and `concept-name' can be null strings.  If `name' is a null string
then an object will be created with a new, non-conflicting name based on `concept-name', or
system-generated if no concept nameis specified.  If `concept-name' is the null string, then
the object will be of type THING.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly.

Return the object."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME CONCEPT-NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE CONCEPT-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET* ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT)))
   (CREATE-OBJECT NAME
    (SAFELY-GET-CONCEPT CONCEPT-NAME MODULE ENVIRONMENT) MODULE
    ENVIRONMENT)))

;;; (DEFUN (CREATE-CONCEPT LOGIC-OBJECT) ...)

(CL:DEFUN CREATE-CONCEPT (NAME PARENT MODULE ENVIRONMENT)
  "Create a concept named `name' in the designated `module', with the
designated `parent' superconcept (which can be left undefined).  Additional
superconcepts can be added via assertions of the `subset-of' relation.  Note
that a specified `parent' concept needs to be created separately.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (STELLA::CALL-DEFCONCEPT
     (STELLA::CONS (STELLA::INTERN-STELLA-NAME NAME)
      (STELLA::CONCATENATE
       (CL:IF (CL:NOT (CL:EQ PARENT STELLA::NULL))
        (STELLA::LIST* KWD-PLI-SUBSET-OF (STELLA::OBJECT-NAME PARENT)
         STELLA::NIL)
        STELLA::NIL)
       STELLA::NIL))))))

;;; (DEFUN (S-CREATE-CONCEPT LOGIC-OBJECT) ...)

(CL:DEFUN S-CREATE-CONCEPT (NAME PARENT-NAME MODULE-NAME ENVIRONMENT)
  "Create a concept named `name' in the designated module, with
with the concept named `parent-name' as superconcept (which can be left
undefined).  Additional superconcepts can be added via assertions of the
`subset-of' relation.  Note that a specified parent concept needs to be
created separately.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME PARENT-NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE PARENT-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET* ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT)))
   (CREATE-CONCEPT NAME
    (SAFELY-GET-CONCEPT PARENT-NAME MODULE ENVIRONMENT) MODULE
    ENVIRONMENT)))

;;; (DEFUN (CREATE-RELATION LOGIC-OBJECT) ...)

(CL:DEFUN CREATE-RELATION (NAME ARITY MODULE ENVIRONMENT)
  "Create a relation named `name' with arity `arity' in the
designated module.  Domain and range information can be added via assertions
of `nth-domain' (or `domain' and `range') relations.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME) (CL:TYPE CL:FIXNUM ARITY))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE ARITY CL:FIXNUM)
  (CL:WHEN (CL:<= ARITY 0)
   (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((STELLA::*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL STELLA::*PRINTREADABLY?*))
     (STELLA::%%PRINT-STREAM
      (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "PARSING ERROR: Relations must have arity of at least 1." EOL)
     (STELLA::HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PLI-ERROR))
    (CL:ERROR
     (STELLA::NEW-PARSING-ERROR
      (STELLA::THE-STRING-READER STREAM-000)))))
  (CL:LET* ((ARGS STELLA::NIL))
   (CL:LET*
    ((STELLA::*MODULE*
      (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
       STELLA::*MODULE*))
     (STELLA::*CONTEXT* STELLA::*MODULE*))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:SETQ MODULE STELLA::*MODULE*)
     (CL:LET*
      ((I STELLA::NULL-INTEGER) (ITER-000 0)
       (UPPER-BOUND-000 (CL:1- ARITY)) (COLLECT-000 STELLA::NULL))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
      (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
       (CL:SETQ I ITER-000)
       (CL:IF (CL:EQ COLLECT-000 STELLA::NULL)
        (CL:PROGN
         (CL:SETQ COLLECT-000
          (STELLA::CONS
           (STELLA::YIELD-SYSTEM-DEFINED-PARAMETER-NAME I MODULE)
           STELLA::NIL))
         (CL:IF (CL:EQ ARGS STELLA::NIL) (CL:SETQ ARGS COLLECT-000)
          (STELLA::ADD-CONS-TO-END-OF-CONS-LIST ARGS COLLECT-000)))
        (CL:PROGN
         (CL:SETF (STELLA::%%REST COLLECT-000)
          (STELLA::CONS
           (STELLA::YIELD-SYSTEM-DEFINED-PARAMETER-NAME I MODULE)
           STELLA::NIL))
         (CL:SETQ COLLECT-000 (STELLA::%%REST COLLECT-000))))
       (CL:SETQ ITER-000 (CL:1+ ITER-000))))
     (STELLA::CALL-DEFRELATION
      (STELLA::CONS (STELLA::INTERN-STELLA-NAME NAME)
       (STELLA::CONS ARGS STELLA::NIL)))))))

;;; (DEFUN (S-CREATE-RELATION LOGIC-OBJECT) ...)

(CL:DEFUN S-CREATE-RELATION (NAME ARITY MODULE-NAME ENVIRONMENT)
  "Create a relation named `name' with arity `arity' in the
designated module.  Domain and range information can be added via assertions
of `nth-domain' (or `domain' and `range') relations.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME MODULE-NAME)
   (CL:TYPE CL:FIXNUM ARITY))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE ARITY CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CREATE-RELATION NAME ARITY
   (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT) ENVIRONMENT))

;;; (DEFUN (CREATE-FUNCTION LOGIC-OBJECT) ...)

(CL:DEFUN CREATE-FUNCTION (NAME ARITY MODULE ENVIRONMENT)
  "Create a function named `name' with arity `arity'  in the designated 
`module'.  Domain and range information can be added via assertions of
`nth-domain' (or `domain' and `range') relations.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME) (CL:TYPE CL:FIXNUM ARITY))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE ARITY CL:FIXNUM)
  (CL:WHEN (CL:<= ARITY 0)
   (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((STELLA::*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL STELLA::*PRINTREADABLY?*))
     (STELLA::%%PRINT-STREAM
      (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "PARSING ERROR: Functions must have arity of at least 1." EOL)
     (STELLA::HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PLI-ERROR))
    (CL:ERROR
     (STELLA::NEW-PARSING-ERROR
      (STELLA::THE-STRING-READER STREAM-000)))))
  (CL:LET* ((ARGS STELLA::NIL))
   (CL:LET*
    ((STELLA::*MODULE*
      (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
       STELLA::*MODULE*))
     (STELLA::*CONTEXT* STELLA::*MODULE*))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:SETQ MODULE STELLA::*MODULE*)
     (CL:LET*
      ((I STELLA::NULL-INTEGER) (ITER-000 0)
       (UPPER-BOUND-000 (CL:1- ARITY)) (COLLECT-000 STELLA::NULL))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
      (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
       (CL:SETQ I ITER-000)
       (CL:IF (CL:EQ COLLECT-000 STELLA::NULL)
        (CL:PROGN
         (CL:SETQ COLLECT-000
          (STELLA::CONS
           (STELLA::YIELD-SYSTEM-DEFINED-PARAMETER-NAME I MODULE)
           STELLA::NIL))
         (CL:IF (CL:EQ ARGS STELLA::NIL) (CL:SETQ ARGS COLLECT-000)
          (STELLA::ADD-CONS-TO-END-OF-CONS-LIST ARGS COLLECT-000)))
        (CL:PROGN
         (CL:SETF (STELLA::%%REST COLLECT-000)
          (STELLA::CONS
           (STELLA::YIELD-SYSTEM-DEFINED-PARAMETER-NAME I MODULE)
           STELLA::NIL))
         (CL:SETQ COLLECT-000 (STELLA::%%REST COLLECT-000))))
       (CL:SETQ ITER-000 (CL:1+ ITER-000))))
     (STELLA::CALL-DEFFUNCTION
      (STELLA::CONS (STELLA::INTERN-STELLA-NAME NAME)
       (STELLA::CONS ARGS STELLA::NIL)))))))

;;; (DEFUN (S-CREATE-FUNCTION LOGIC-OBJECT) ...)

(CL:DEFUN S-CREATE-FUNCTION (NAME ARITY MODULE-NAME ENVIRONMENT)
  "Create a function named `name' with arity `arity' in the designated 
module.  Domain and range information can be added via assertions of
`domain', `nth-domain' and `range' relations.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME MODULE-NAME)
   (CL:TYPE CL:FIXNUM ARITY))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE ARITY CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CREATE-FUNCTION NAME ARITY
   (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT) ENVIRONMENT))

;;; (DEFUN REGISTER-SPECIALIST-FUNCTION ...)

(CL:DEFUN REGISTER-SPECIALIST-FUNCTION (NAME FUNCTION-REFERENCE MODULE ENVIRONMENT)
  "Register `name' as a function name in `module' which will invoke the
native code procedure described by `function-reference.'  The `name'
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The function must conform
to the signature for specialist functions.

The exact form of `function-reference' depends on the underlying
programming language.  The following type mappings are used:
          C++:  
  Common Lisp:  FUNCTION   (result of #' or (FUNCTION ...))
         Java:  java.lang.reflect.Method"
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (STELLA::REGISTER-SPECIALIST-FUNCTION NAME FUNCTION-REFERENCE))))

;;; (DEFUN S-REGISTER-SPECIALIST-FUNCTION ...)

(CL:DEFUN S-REGISTER-SPECIALIST-FUNCTION (NAME NATIVE-NAME MODULE-NAME ENVIRONMENT)
  "Register `name' as a function name in the module named `module-name'.
This function will the native code named `native-name'.  The `name'
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The `native-name' will be
processed in a manner that depends on the underlying programming
language.  The following type mappings are used:
          C++:  Not available.  Error signaled.
  Common Lisp:  The native-name is read by READ-FROM-STRING and then
                the SYMBOL-FUNCTION is taken.
         Java:  A fully package-qualified name is required.  It is
                looked up using the Reflection tools.
The function found must conform to the signature for specialist functions."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME NATIVE-NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE NATIVE-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((STELLA::*MODULE* STELLA::NULL) (STELLA::*CONTEXT* STELLA::NULL))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:LET* ((TEMP-000 (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT)))
    (CL:SETQ STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ TEMP-000 STELLA::NULL)) TEMP-000
      STELLA::*MODULE*)))
   (CL:SETQ STELLA::*CONTEXT* STELLA::*MODULE*)
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (STELLA::%REGISTER-SPECIALIST-FUNCTION-NAME NAME NATIVE-NAME))))

;;; (DEFUN REGISTER-COMPUTATION-FUNCTION ...)

(CL:DEFUN REGISTER-COMPUTATION-FUNCTION (NAME FUNCTION-REFERENCE ARITY MODULE ENVIRONMENT)
  "Register `name' as a function name in `module' which will invoke the
native code procedure described by `function-reference.'  The `name'
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The function must conform
to the signature for computation functions used by the computation
specialist.  Arity specifies the number of arguments the computation
accepts.

The exact form of `function-reference' depends on the underlying
programming language.  The following type mappings are used:
          C++:  cpp_function_code (a pointer to the function code)
  Common Lisp:  FUNCTION   (result of #' or (FUNCTION ...))
         Java:  java.lang.reflect.Method"
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME) (CL:TYPE CL:FIXNUM ARITY))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE ARITY CL:FIXNUM)
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (STELLA::REGISTER-COMPUTATION-FUNCTION NAME FUNCTION-REFERENCE
     ARITY))))

;;; (DEFUN S-REGISTER-COMPUTATION-FUNCTION ...)

(CL:DEFUN S-REGISTER-COMPUTATION-FUNCTION (NAME NATIVE-NAME ARITY MODULE-NAME ENVIRONMENT)
  "Register `name' as a function name in the module named `module-name'.
This function will the native code named `native-name'.  The `name'
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The `native-name' will be
processed in a manner that depends on the underlying programming
language.  The following type mappings are used:
          C++:  Not available.  Error signaled.
  Common Lisp:  The native-name is read by READ-FROM-STRING and then
                the SYMBOL-FUNCTION is taken.
         Java:  A fully package-qualified name is required.  It is
                looked up using the Reflection tools.
The function found must conform to the signature for computation functions.
Arity specifies the number of arguments the computation accepts."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME NATIVE-NAME MODULE-NAME)
   (CL:TYPE CL:FIXNUM ARITY))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE NATIVE-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE ARITY CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((STELLA::*MODULE* STELLA::NULL) (STELLA::*CONTEXT* STELLA::NULL))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:LET* ((TEMP-000 (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT)))
    (CL:SETQ STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ TEMP-000 STELLA::NULL)) TEMP-000
      STELLA::*MODULE*)))
   (CL:SETQ STELLA::*CONTEXT* STELLA::*MODULE*)
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (STELLA::%REGISTER-COMPUTATION-FUNCTION-NAME NAME NATIVE-NAME
     ARITY))))

;;; (DEFUN (CREATE-ENUMERATED-LIST LOGIC-OBJECT) ...)

(CL:DEFUN CREATE-ENUMERATED-LIST (MEMBERS MODULE ENVIRONMENT)
  "Create a logical term that denotes a list containing `members' in
`module' using `environment'.  Useful for passing lists as arguments
to parameterized queries."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:LET* ((SELF-000 (STELLA::NEW-LIST)))
     (CL:SETF (STELLA::%LIST.THE-CONS-LIST SELF-000) MEMBERS)
     (CL:LET* ((VALUE-000 (STELLA::CREATE-LOGICAL-LIST SELF-000)))
      VALUE-000)))))

;;; (DEFUN (CREATE-ENUMERATED-SET LOGIC-OBJECT) ...)

(CL:DEFUN CREATE-ENUMERATED-SET (MEMBERS MODULE ENVIRONMENT)
  "Create a logical term that denotes the enumerated set containing `members'
in `module' using `environment'."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:LET* ((SELF-000 (STELLA::NEW-LIST)))
     (CL:SETF (STELLA::%LIST.THE-CONS-LIST SELF-000) MEMBERS)
     (CL:LET* ((VALUE-000 (STELLA::CREATE-ENUMERATED-SET SELF-000)))
      VALUE-000)))))

;;; (DEFUN DESTROY-OBJECT ...)

(CL:DEFUN DESTROY-OBJECT (OBJECT)
  "Delete the object `object', retracting all facts attached to it."
  (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
   (STELLA::DESTROY-OBJECT OBJECT)))

;;; (DEFUN S-DESTROY-OBJECT ...)

(CL:DEFUN S-DESTROY-OBJECT (OBJECT-NAME MODULE-NAME ENVIRONMENT)
  "Delete the object named `object-name', retracting all facts
attached to it.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING OBJECT-NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE OBJECT-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (OBJECT (SAFELY-GET-OBJECT OBJECT-NAME MODULE ENVIRONMENT)))
   (CL:WHEN (CL:NOT (CL:EQ OBJECT STELLA::NULL))
    (DESTROY-OBJECT OBJECT))))

;;; (DEFUN (ASSERT-UNARY-PROPOSITION PROPOSITION) ...)

(CL:DEFUN ASSERT-UNARY-PROPOSITION (RELATION ARG MODULE ENVIRONMENT)
  "Assert that the proposition (`relation' `arg') is TRUE in `module'.  Return the asserted proposition."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:IF (STELLA::CLASS? RELATION)
     (STELLA::ASSERT-ISA-PROPOSITION ARG
      (STELLA::%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE RELATION))
     (STELLA::ASSERT-PROPERTY ARG
      (STELLA::%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE RELATION))))))

;;; (DEFUN (ASSERT-BINARY-PROPOSITION PROPOSITION) ...)

(CL:DEFUN ASSERT-BINARY-PROPOSITION (RELATION ARG VALUE MODULE ENVIRONMENT)
  "Assert that the proposition (`relation' `arg' `value') is TRUE
in `module'.  Return the asserted proposition."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (STELLA::ASSERT-BINARY-VALUE
     (STELLA::%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE RELATION) ARG
     VALUE))))

;;; (DEFUN (ASSERT-NARY-PROPOSITION PROPOSITION) ...)

(CL:DEFUN ASSERT-NARY-PROPOSITION (RELATION-AND-ARGUMENTS MODULE ENVIRONMENT)
  "Assert that the proposition represented by the list ` relation-and-arguments' satisfies
the relation `relation'."
  (CL:LET*
   ((LIST (SEQUENCE-TO-CONS-LIST RELATION-AND-ARGUMENTS))
    (RELATION (STELLA::%%VALUE LIST))
    (RELATIONSURROGATE
     (STELLA::%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE RELATION))
    (ARGUMENTS (STELLA::%%REST LIST)))
   (CL:LET*
    ((STELLA::*MODULE*
      (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
       STELLA::*MODULE*))
     (STELLA::*CONTEXT* STELLA::*MODULE*))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (STELLA::ASSERT-TUPLE RELATIONSURROGATE ARGUMENTS)))))

;;; (DEFUN (RETRACT-UNARY-PROPOSITION PROPOSITION) ...)

(CL:DEFUN RETRACT-UNARY-PROPOSITION (RELATION ARG MODULE ENVIRONMENT)
  "Retract that the proposition (`relation' `arg') is TRUE in `module'.  Return the asserted proposition."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:IF (STELLA::CLASS? RELATION)
     (STELLA::RETRACT-ISA-PROPOSITION ARG
      (STELLA::%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE RELATION))
     (STELLA::RETRACT-PROPERTY ARG
      (STELLA::%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE RELATION))))))

;;; (DEFUN (RETRACT-BINARY-PROPOSITION PROPOSITION) ...)

(CL:DEFUN RETRACT-BINARY-PROPOSITION (RELATION ARG VALUE MODULE ENVIRONMENT)
  "Retract that the proposition (`relation' `arg' `value') is TRUE
in `module'.  Return the asserted proposition."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (STELLA::RETRACT-BINARY-VALUE
     (STELLA::%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE RELATION) ARG
     VALUE))))

;;; (DEFUN (RETRACT-NARY-PROPOSITION PROPOSITION) ...)

(CL:DEFUN RETRACT-NARY-PROPOSITION (RELATION-AND-ARGUMENTS MODULE ENVIRONMENT)
  "Retract the proposition that `arguments' satisfies
the relation `relation'."
  (CL:LET*
   ((LIST (SEQUENCE-TO-CONS-LIST RELATION-AND-ARGUMENTS))
    (RELATION (STELLA::%%VALUE LIST))
    (RELATIONSURROGATE
     (STELLA::%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE RELATION))
    (ARGUMENTS (STELLA::%%REST LIST)))
   (CL:LET*
    ((STELLA::*MODULE*
      (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
       STELLA::*MODULE*))
     (STELLA::*CONTEXT* STELLA::*MODULE*))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (STELLA::UPDATE-TUPLE RELATIONSURROGATE ARGUMENTS
      KWD-PLI-RETRACT-TRUE)))))

;;; (DEFUN (ASSERT-PROPOSITION PROPOSITION) ...)

(CL:DEFUN ASSERT-PROPOSITION (PROPOSITION MODULE ENVIRONMENT)
  "Assert that the proposition `proposition' is true in `module'.
Return the asserted proposition."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (STELLA::HELP-UPDATE-TOP-LEVEL-PROPOSITION PROPOSITION
     KWD-PLI-ASSERT-TRUE)
    PROPOSITION)))

;;; (DEFUN (S-ASSERT-PROPOSITION (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN S-ASSERT-PROPOSITION (SENTENCE MODULE-NAME ENVIRONMENT)
  "Assert that the logical sentence `sentence' is true in the module
named `module-name'.  A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.

Return an iterator of the propositions resulting from sentence."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SENTENCE MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE SENTENCE CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (PROPOSITIONS STELLA::NULL) (RETURN-VALUE STELLA::NULL))
   (CL:LET*
    ((STELLA::*MODULE*
      (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
       STELLA::*MODULE*))
     (STELLA::*CONTEXT* STELLA::*MODULE*))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:SETQ PROPOSITIONS
      (S-CONCEIVE SENTENCE MODULE-NAME ENVIRONMENT))
     (CL:SETQ RETURN-VALUE
      (CONS-TO-PL-ITERATOR (%PL-ITERATOR.CURSOR PROPOSITIONS)))
     (CL:LET* ((PROPOSITION STELLA::NULL) (ITER-000 PROPOSITIONS))
      (CL:LOOP WHILE (STELLA::NEXT? ITER-000) DO
       (CL:SETQ PROPOSITION (%PL-ITERATOR.VALUE ITER-000))
       (STELLA::HELP-UPDATE-TOP-LEVEL-PROPOSITION PROPOSITION
        KWD-PLI-ASSERT-TRUE)))
     RETURN-VALUE))))

;;; (DEFUN (RETRACT-PROPOSITION PROPOSITION) ...)

(CL:DEFUN RETRACT-PROPOSITION (PROPOSITION MODULE ENVIRONMENT)
  "Retract the truth of the proposition `proposition' in `module'.
Return the retracted proposition."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (STELLA::HELP-UPDATE-TOP-LEVEL-PROPOSITION PROPOSITION
     KWD-PLI-RETRACT-TRUE)
    PROPOSITION)))

;;; (DEFUN (S-RETRACT-PROPOSITION (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN S-RETRACT-PROPOSITION (SENTENCE MODULE-NAME ENVIRONMENT)
  "Retract the truth of the logical sentence `sentence' in the module named
`module-name'.  A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.

Return an iterator of the retracted propositions resulting from sentence."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SENTENCE MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE SENTENCE CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (PROPOSITIONS STELLA::NULL) (RETURN-VALUE STELLA::NULL))
   (CL:LET*
    ((STELLA::*MODULE*
      (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
       STELLA::*MODULE*))
     (STELLA::*CONTEXT* STELLA::*MODULE*))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:SETQ PROPOSITIONS
      (S-CONCEIVE SENTENCE MODULE-NAME ENVIRONMENT))
     (CL:SETQ RETURN-VALUE
      (CONS-TO-PL-ITERATOR (%PL-ITERATOR.CURSOR PROPOSITIONS)))
     (CL:LET* ((PROPOSITION STELLA::NULL) (ITER-000 PROPOSITIONS))
      (CL:LOOP WHILE (STELLA::NEXT? ITER-000) DO
       (CL:SETQ PROPOSITION (%PL-ITERATOR.VALUE ITER-000))
       (STELLA::HELP-UPDATE-TOP-LEVEL-PROPOSITION PROPOSITION
        KWD-PLI-RETRACT-TRUE)))
     RETURN-VALUE))))

;;; (DEFUN (CONCEIVE (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN CONCEIVE (SENTENCE MODULE ENVIRONMENT)
  "Create one or more proposition objects from the sentence `sentence'
in the  module `module'.  Return an iterator of the propositions.
If any of the new propositions has the same structure as an already existing
proposition, an automatic check for duplicates will return the pre-existing
proposition.  Multiple propositions may be returned for a single sentence
because of normalization of equivalences, conjunctions, etc.

Signals a `Proposition-Error' if PowerLoom could not conceive `sentence'."
  (CL:IF (CL:EQ SENTENCE STELLA::NULL) STELLA::NULL
   (CL:LET*
    ((STELLA::*MODULE*
      (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
       STELLA::*MODULE*))
     (STELLA::*CONTEXT* STELLA::*MODULE*))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:LET* ((PROPOSITIONS (STELLA::CONCEIVE-FORMULA SENTENCE)))
      (CL:WHEN (CL:EQ PROPOSITIONS STELLA::NULL)
       (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
        (CL:LET* ((STELLA::*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL STELLA::*PRINTREADABLY?*))
         (STELLA::%%PRINT-STREAM
          (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
          "ERROR: Failed to conceive `" SENTENCE "'." EOL)
         (STELLA::HELP-SIGNAL-PROPOSITION-ERROR STREAM-000
          KWD-PLI-ERROR))
        (CL:ERROR
         (STELLA::NEW-PROPOSITION-ERROR
          (STELLA::THE-STRING-READER STREAM-000)))))
      (CL:LET*
       ((TEST-VALUE-000 (STELLA::SAFE-PRIMARY-TYPE PROPOSITIONS)))
       (CL:COND
        ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-LOGIC-PROPOSITION)
         (CL:PROGN
          (CONS-TO-PL-ITERATOR
           (STELLA::CONS PROPOSITIONS STELLA::NIL))))
        ((CL:EQ TEST-VALUE-000 SGT-PLI-STELLA-CONS)
         (CL:PROGN (CONS-TO-PL-ITERATOR PROPOSITIONS)))
        (CL:T
         (CL:LET* ((STREAM-001 (STELLA::NEW-OUTPUT-STRING-STREAM)))
          (CL:LET* ((STELLA::*PRINTREADABLY?* CL:T))
           (CL:DECLARE (CL:SPECIAL STELLA::*PRINTREADABLY?*))
           (STELLA::%%PRINT-STREAM
            (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
            "ERROR: Formula is not a sentence: `" SENTENCE "'." EOL)
           (STELLA::HELP-SIGNAL-PROPOSITION-ERROR STREAM-001
            KWD-PLI-ERROR))
          (CL:ERROR
           (STELLA::NEW-PROPOSITION-ERROR
            (STELLA::THE-STRING-READER STREAM-001))))))))))))

;;; (DEFUN (S-CONCEIVE (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN S-CONCEIVE (SENTENCE MODULE-NAME ENVIRONMENT)
  "Create one or more proposition objects from the sentence `sentence'
in the  module named `module-name'.  Return an iterator of the propositions.
If any of the new propositions has the same structure as an already existing
proposition, an automatic check for duplicates will return the pre-existing
proposition.  Multiple propositions may be returned for a single sentence
because of normalization of equivalences, conjunctions, etc.

A module name of `null' or the empty string refers to the current module.
If no module can be found with the name `module-name', then a Stella
`No-Such-Context-Exception' is thrown.

Signals a `Proposition-Error' if PowerLoom could not conceive `sentence'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SENTENCE MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE SENTENCE CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET* ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT)))
   (CL:LET*
    ((STELLA::*MODULE*
      (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
       STELLA::*MODULE*))
     (STELLA::*CONTEXT* STELLA::*MODULE*))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:SETQ MODULE STELLA::*MODULE*)
     (CONCEIVE (STELLA::READ-S-EXPRESSION-FROM-STRING SENTENCE) MODULE
      ENVIRONMENT)))))

;;; (DEFUN (GET-RULES (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN GET-RULES (RELATION MODULE ENVIRONMENT)
  "Return rules attached to the concept/relation `relation'
in either antecedent or consequent position."
  (CL:IF (CL:EQ RELATION STELLA::NULL) EMPTY-PL-ITERATOR
   (CL:LET*
    ((STELLA::*MODULE*
      (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
       STELLA::*MODULE*))
     (STELLA::*CONTEXT* STELLA::*MODULE*))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CONS-TO-PL-ITERATOR (STELLA::CALL-GET-RULES RELATION))))))

;;; (DEFUN (S-GET-RULES (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN S-GET-RULES (RELATION-NAME MODULE-NAME ENVIRONMENT)
  "Return rules attached to the concept/relation named
`relation-name' found in the module named `module-name'.
A module name of `null' or the empty string refers to the current module.
If no module can be found with the name `module-name', then a Stella
`No-Such-Context-Exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RELATION-NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE RELATION-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (RELATION (SAFELY-GET-RELATION RELATION-NAME MODULE ENVIRONMENT)))
   (GET-RULES RELATION MODULE ENVIRONMENT)))

;;; (DEFUN S-PRINT-RULES ...)

(CL:DEFUN S-PRINT-RULES (NAME STREAM MODULE-NAME ENVIRONMENT)
  "Print rules attached to the concept/relation named `name'.
A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ STREAM STELLA::NULL)
   (CL:SETQ STREAM STELLA::STANDARD-OUTPUT))
  (CL:LET*
   ((RULE STELLA::NULL)
    (ITER-000 (S-GET-RULES NAME MODULE-NAME ENVIRONMENT)))
   (CL:LOOP WHILE (STELLA::NEXT? ITER-000) DO
    (CL:SETQ RULE (%PL-ITERATOR.VALUE ITER-000))
    (STELLA::PRINT-LOGICAL-FORM RULE STREAM)
    (STELLA::%%PRINT-STREAM
     (STELLA::%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL EOL))))

;;; (DEFUN RUN-FORWARD-RULES ...)

(CL:DEFUN RUN-FORWARD-RULES (MODULE LOCAL? FORCE?)
  "Run forward inference rules in module `module' which defaults
to the current module.  See `run-forward-rules' command for more information."
  (CL:WHEN (CL:EQ MODULE STELLA::NULL)
   (CL:SETQ MODULE STELLA::*MODULE*))
  (CL:WHEN (CL:NOT (CL:EQ MODULE STELLA::NULL))
   (STELLA::CALL-RUN-FORWARD-RULES MODULE LOCAL? FORCE?)))

;;; (DEFUN (GET-ARITY INTEGER) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM) GET-ARITY))
(CL:DEFUN GET-ARITY (RELATION)
  "Return the arity of the relation `relation'."
  (CL:COND
   ((STELLA::SUBTYPE-OF? (STELLA::SAFE-PRIMARY-TYPE RELATION)
     SGT-PLI-LOGIC-DESCRIPTION)
    (CL:PROGN (STELLA::ARITY RELATION)))
   (CL:T 0)))

;;; (DEFUN (S-GET-ARITY INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:SIMPLE-STRING CL:SIMPLE-STRING CL:T) CL:FIXNUM)
  S-GET-ARITY))
(CL:DEFUN S-GET-ARITY (RELATION-NAME MODULE-NAME ENVIRONMENT)
  "Return the arity of the relation named `relation-name'.

 A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RELATION-NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE RELATION-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (RELATION (SAFELY-GET-RELATION RELATION-NAME MODULE ENVIRONMENT)))
   (CL:IF (CL:NOT (CL:EQ RELATION STELLA::NULL)) (GET-ARITY RELATION)
    STELLA::NULL-INTEGER)))

;;; (DEFUN (GET-DOMAIN LOGIC-OBJECT) ...)

(CL:DEFUN GET-DOMAIN (RELATION)
  "Return the type (a concept) for the first argument to the binary
relation `relation'."
  (CL:COND
   ((STELLA::SUBTYPE-OF? (STELLA::SAFE-PRIMARY-TYPE RELATION)
     SGT-PLI-LOGIC-NAMED-DESCRIPTION)
    (CL:PROGN (GET-NTH-DOMAIN RELATION 0)))
   (CL:T STELLA::NULL)))

;;; (DEFUN (S-GET-DOMAIN LOGIC-OBJECT) ...)

(CL:DEFUN S-GET-DOMAIN (RELATION-NAME MODULE-NAME ENVIRONMENT)
  "Return the type (concept) for the first argument to the binary
relation `relation-name'.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RELATION-NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE RELATION-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (RELATION (SAFELY-GET-RELATION RELATION-NAME MODULE ENVIRONMENT)))
   (CL:IF (CL:NOT (CL:EQ RELATION STELLA::NULL)) (GET-DOMAIN RELATION)
    STELLA::NULL)))

;;; (DEFUN (GET-RANGE LOGIC-OBJECT) ...)

(CL:DEFUN GET-RANGE (RELATION)
  "Return the type (a concept) for fillers of the binary relation
`relation'."
  (CL:COND
   ((STELLA::SUBTYPE-OF? (STELLA::SAFE-PRIMARY-TYPE RELATION)
     SGT-PLI-LOGIC-NAMED-DESCRIPTION)
    (CL:PROGN (GET-NTH-DOMAIN RELATION 1)))
   (CL:T STELLA::NULL)))

;;; (DEFUN (S-GET-RANGE LOGIC-OBJECT) ...)

(CL:DEFUN S-GET-RANGE (RELATION-NAME MODULE-NAME ENVIRONMENT)
  "Return the type (a concept) for fillers of the binary relation
`relation-name'.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RELATION-NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE RELATION-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (RELATION (SAFELY-GET-RELATION RELATION-NAME MODULE ENVIRONMENT)))
   (CL:IF (CL:NOT (CL:EQ RELATION STELLA::NULL)) (GET-RANGE RELATION)
    STELLA::NULL)))

;;; (DEFUN (GET-NTH-DOMAIN LOGIC-OBJECT) ...)

(CL:DEFUN GET-NTH-DOMAIN (RELATION N)
  "Return the type (a concept) for the the nth argument of the
relation `relation'.  Counting starts at zero.  NOTE: if there are multiple
`nth-domain' propositions for `relation', this arbitrarily returns one of them;
it does not look for the most specific one (which might have to be created)."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (CL:WHEN (STELLA::CLASS? RELATION)
   (CL:RETURN-FROM GET-NTH-DOMAIN
    (CL:IF (CL:= N 0) RELATION STELLA::NULL)))
  (CL:COND
   ((STELLA::SUBTYPE-OF? (STELLA::SAFE-PRIMARY-TYPE RELATION)
     SGT-PLI-LOGIC-NAMED-DESCRIPTION)
    (CL:PROGN
     (CL:WHEN
      (CL:AND (CL:>= N 0)
       (CL:< N
        (STELLA::LENGTH
         (STELLA::%NAMED-DESCRIPTION.IO-VARIABLE-TYPES RELATION))))
      (CL:LET*
       ((DOMAINPROP
         (STELLA::%%VALUE
          (HELP-GET-PROPOSITIONS
           (STELLA::%SURROGATE.SURROGATE-VALUE
            SGT-PLI-PL-KERNEL-KB-NTH-DOMAIN)
           (STELLA::CONS RELATION
            (STELLA::CONS (STELLA::WRAP-INTEGER N)
             (STELLA::CONS STELLA::NULL STELLA::NIL)))
           1 STELLA::NULL STELLA::NULL))))
       (CL:WHEN (CL:NOT (CL:EQ DOMAINPROP STELLA::NULL))
        (CL:RETURN-FROM GET-NTH-DOMAIN
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (STELLA::%VECTOR.THE-ARRAY
            (STELLA::%PROPOSITION.ARGUMENTS DOMAINPROP)))
          (CL:THE CL:FIXNUM
           (CL:1-
            (STELLA::LENGTH
             (STELLA::%PROPOSITION.ARGUMENTS DOMAINPROP)))))))))))
   (CL:T))
  STELLA::NULL)

;;; (DEFUN (S-GET-NTH-DOMAIN LOGIC-OBJECT) ...)

(CL:DEFUN S-GET-NTH-DOMAIN (RELATION-NAME N MODULE-NAME ENVIRONMENT)
  "Return the type (a concept) for the nth argument of the relation
named `relation-name'.  Counting starts at zero.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RELATION-NAME MODULE-NAME)
   (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE RELATION-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (RELATION (SAFELY-GET-RELATION RELATION-NAME MODULE ENVIRONMENT)))
   (CL:IF (CL:NOT (CL:EQ RELATION STELLA::NULL))
    (GET-NTH-DOMAIN RELATION N) STELLA::NULL)))

;;; (DEFUN LOAD ...)

(CL:DEFUN LOAD (FILENAME ENVIRONMENT)
  "Read logic commands from the file named `filename' and evaluate them.
See `load' command help for more information."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILENAME))
  #+MCL
  (CL:CHECK-TYPE FILENAME CL:SIMPLE-STRING)
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ STELLA::*MODULE* STELLA::NULL))
      STELLA::*MODULE* STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (STELLA::%LOAD FILENAME STELLA::NIL))))

;;; (DEFUN LOAD-IN-MODULE ...)

(CL:DEFUN LOAD-IN-MODULE (FILENAME MODULE ENVIRONMENT)
  "Read logic commands from the file named `filename' and evaluate them.
Binds the `load' command's :module option to `module'.  See `load' command help for more information."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILENAME))
  #+MCL
  (CL:CHECK-TYPE FILENAME CL:SIMPLE-STRING)
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:SETQ MODULE STELLA::*MODULE*)
    (STELLA::%LOAD FILENAME (STELLA::CONS-LIST KWD-PLI-MODULE MODULE)))))

;;; (DEFUN LOAD-STREAM ...)

(CL:DEFUN LOAD-STREAM (STREAM ENVIRONMENT)
  "Read logic commands from the STELLA stream `stream' and evaluate them.
See `load' command help for more information."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ STELLA::*MODULE* STELLA::NULL))
      STELLA::*MODULE* STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (STELLA::LOAD-STREAM STREAM))))

;;; (DEFUN LOAD-STREAM-IN-MODULE ...)

(CL:DEFUN LOAD-STREAM-IN-MODULE (STREAM MODULE ENVIRONMENT)
  "Read logic commands from the STELLA stream `stream' and evaluate them.
Binds the `load' command's :module option to `module'.  See `load' command help for more information."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:SETQ MODULE STELLA::*MODULE*)
    (STELLA::LOAD-STREAM STREAM KWD-PLI-MODULE MODULE))))

;;; (DEFUN LOAD-NATIVE-STREAM ...)

(CL:DEFUN LOAD-NATIVE-STREAM (STREAM ENVIRONMENT)
  "Read logic commands from the native input stream `stream' and evaluate them.
Assumes `stream' is a line-buffered stream which is a safe compromise but does
not generate the best efficiency for block-buffered streams such as files.
See `load' command help for more information."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ STELLA::*MODULE* STELLA::NULL))
      STELLA::*MODULE* STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:LET* ((SELF-000 (STELLA::NEW-INPUT-STREAM)))
     (CL:SETF (STELLA::%INPUT-STREAM.NATIVE-STREAM SELF-000) STREAM)
     (STELLA::LOAD-STREAM SELF-000)))))

;;; (DEFUN LOAD-NATIVE-STREAM-IN-MODULE ...)

(CL:DEFUN LOAD-NATIVE-STREAM-IN-MODULE (STREAM MODULE ENVIRONMENT)
  "Read logic commands from the native input stream `stream' and evaluate them.
Assumes `stream' is a line-buffered stream which is a safe compromise but does
not generate the best efficiency for block-buffered streams such as files.
Binds the `load' command's :module option to `module'.  See `load' command help for more information."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:SETQ MODULE STELLA::*MODULE*)
    (CL:LET* ((SELF-000 (STELLA::NEW-INPUT-STREAM)))
     (CL:SETF (STELLA::%INPUT-STREAM.NATIVE-STREAM SELF-000) STREAM)
     (STELLA::LOAD-STREAM SELF-000 KWD-PLI-MODULE MODULE)))))

;;; (DEFUN SAVE-MODULE ...)

(CL:DEFUN SAVE-MODULE (MODULE FILENAME IFEXISTS ENVIRONMENT)
  "Save the contents of the module `mod' into a file named `filename'.
If a file named `filename' already exists, then the action taken depends on the
value of `ifexists'.  Possible values are \"ASK\", \"REPLACE\", \"WARN\" and \"ERROR\":

  REPLACE => Means overwrite without warning.
  WARN    => Means overwrite with a warning.
  ERROR   => Means don't overwrite, signal an error instead.
  ASK     => Ask the user whether to overwrite or not.  If not overwritten, an 
             exception is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILENAME IFEXISTS))
  #+MCL
  (CL:CHECK-TYPE FILENAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE IFEXISTS CL:SIMPLE-STRING)
  (CL:LET* ((EXISTS? (STELLA::PROBE-FILE? FILENAME)))
   (CL:COND
    ((CL:OR (CL:NOT EXISTS?)
      (STELLA::STRING-EQUAL? IFEXISTS "REPLACE")))
    ((STELLA::STRING-EQUAL? IFEXISTS "ASK")
     (CL:WHEN
      (CL:NOT
       (STELLA::YES-OR-NO?
        (STELLA::CONCATENATE "File `" FILENAME
         "' already exists.  Overwrite it? (yes or no) ")))
      (STELLA::ENSURE-FILE-DOES-NOT-EXIST FILENAME "save-module")))
    ((STELLA::STRING-EQUAL? IFEXISTS "WARN")
     (CL:WARN "File `~A' already exists, overwriting." FILENAME))
    ((STELLA::STRING-EQUAL? IFEXISTS "ERROR")
     (STELLA::ENSURE-FILE-DOES-NOT-EXIST FILENAME "save-module"))
    (CL:T
     (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
      (STELLA::%%PRINT-STREAM
       (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "Unrecognized ifexists option `" IFEXISTS "'")
      (CL:ERROR
       (STELLA::NEW-BAD-ARGUMENT-EXCEPTION
        (STELLA::THE-STRING-READER STREAM-000))))))
   (CL:LET*
    ((STELLA::*MODULE*
      (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
       STELLA::*MODULE*))
     (STELLA::*CONTEXT* STELLA::*MODULE*))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:SETQ MODULE STELLA::*MODULE*)
     (CL:LET* ((STREAM STELLA::NULL))
      (CL:UNWIND-PROTECT
       (CL:PROGN (CL:SETQ STREAM (STELLA::OPEN-OUTPUT-FILE FILENAME))
        (STELLA::DO-SAVE-MODULE MODULE STREAM))
       (CL:WHEN (CL:NOT (CL:EQ STREAM STELLA::NULL))
        (STELLA::FREE STREAM))))))))

;;; (DEFUN S-SAVE-MODULE ...)

(CL:DEFUN S-SAVE-MODULE (MODULE-NAME FILENAME IFEXISTS ENVIRONMENT)
  "Save the contents of the module `module-name' into a file named `filename'.
If a file named `filename' already exists, then the action taken depends on the
value of `ifexists'.  Possible values are \"ASK\", \"REPLACE\", \"WARN\" and \"ERROR\":

  REPLACE => Means overwrite without warning.
  WARN    => Means overwrite with a warning.
  ERROR   => Means don't overwrite, signal an error instead.
  ASK     => Ask the user whether to overwrite or not.  If not overwritten, an
             exception is thrown.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MODULE-NAME FILENAME IFEXISTS))
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE FILENAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE IFEXISTS CL:SIMPLE-STRING)
  (SAVE-MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT) FILENAME
   IFEXISTS ENVIRONMENT))

;;; (DEFUN (GET-PREDICATE LOGIC-OBJECT) ...)

(CL:DEFUN GET-PREDICATE (PROP)
  "Return the concept or relation predicate for
the proposition `prop'."
  (CL:LET*
   ((RELATION
     (STELLA::GET-DESCRIPTION (STELLA::%PROPOSITION.OPERATOR PROP))))
   (CL:WHEN (CL:EQ RELATION STELLA::NULL)
    (CL:SETQ RELATION
     (STELLA::%SURROGATE.SURROGATE-VALUE
      (STELLA::%PROPOSITION.OPERATOR PROP))))
   RELATION))

;;; (DEFUN (GET-COLUMN-COUNT INTEGER) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM) GET-COLUMN-COUNT))
(CL:DEFUN GET-COLUMN-COUNT (OBJ)
  "Return the number of columns in `obj', which must
be of type proposition, skolem, cons, vector or PL-iterator.  For a proposition,
the number includes both the predicate and arguments. For the PL-iterator
case,the number of columns is for the current value of the iterator. For the
skolem case, if the skolem is a function term, the column count of its defining
proposition will be returned, otherwise it is treated as a non-sequence object.

For a null item, the column count is zero.
For non sequence objects, the column count is one."
  (CL:WHEN (CL:EQ OBJ STELLA::NULL) (CL:RETURN-FROM GET-COLUMN-COUNT 0))
  (CL:LET* ((TEST-VALUE-000 (STELLA::SAFE-PRIMARY-TYPE OBJ)))
   (CL:COND
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-LOGIC-PROPOSITION)
     (CL:PROGN
      (CL:1+ (STELLA::LENGTH (STELLA::%PROPOSITION.ARGUMENTS OBJ)))))
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-PLI-PL-ITERATOR)
     (CL:PROGN (GET-COLUMN-COUNT (%PL-ITERATOR.VALUE OBJ))))
    ((CL:EQ TEST-VALUE-000 SGT-PLI-STELLA-CONS)
     (CL:PROGN (STELLA::LENGTH OBJ)))
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-STELLA-VECTOR)
     (CL:PROGN (STELLA::LENGTH OBJ)))
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:IF (STELLA::FUNCTION-OUTPUT-SKOLEM? OBJ)
       (GET-COLUMN-COUNT (STELLA::%SKOLEM.DEFINING-PROPOSITION OBJ))
       1)))
    (CL:T 1))))

;;; (DEFUN (GET-NTH-VALUE OBJECT) ...)

(CL:DEFUN GET-NTH-VALUE (SEQUENCE N MODULE ENVIRONMENT)
  "Return the value in the `nth' column of `sequence'.
Counting starts at zero.  Unless `n' is zero, `sequence' must be of type
proposition, skolem, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the number
of columns is for the current value of the iterator.   For the skolem case,
if the skolem is a function term, the nth value of its defining proposition
will be returned, otherwise it is treated as a non-sequence object.

As a special case, a column number of zero will also return `sequence' itself
if it is not one of the types enumerated above.  This is done to allow the
use of `get-nth-value' on PL-iterators with only a single return variable."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (CL:WHEN (CL:OR (CL:>= N (GET-COLUMN-COUNT SEQUENCE)) (CL:< N 0))
   (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
    (STELLA::%%PRINT-STREAM
     (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
     "Column index `" N "' is out of range for `" SEQUENCE "'")
    (CL:ERROR
     (STELLA::NEW-LOGIC-EXCEPTION
      (STELLA::THE-STRING-READER STREAM-000)))))
  (CL:LET* ((TEST-VALUE-000 (STELLA::SAFE-PRIMARY-TYPE SEQUENCE)))
   (CL:COND
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-LOGIC-PROPOSITION)
     (CL:PROGN
      (CL:IF (CL:= N 0) (GET-PREDICATE SEQUENCE)
       (CL:LET*
        ((VALUE
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR
            (STELLA::%VECTOR.THE-ARRAY
             (STELLA::%PROPOSITION.ARGUMENTS SEQUENCE)))
           (CL:THE CL:FIXNUM (CL:1- N)))))
        (CL:COND
         ((STELLA::SUBTYPE-OF? (STELLA::SAFE-PRIMARY-TYPE VALUE)
           SGT-PLI-LOGIC-SKOLEM)
          (CL:PROGN
           (CL:LET*
            ((STELLA::*MODULE*
              (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
               STELLA::*MODULE*))
             (STELLA::*CONTEXT* STELLA::*MODULE*))
            (CL:DECLARE
             (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
            (CL:SETQ ENVIRONMENT ENVIRONMENT)
            (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
             (STELLA::VALUE-OF VALUE)))))
         (CL:T VALUE))))))
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-PLI-PL-ITERATOR)
     (CL:PROGN
      (GET-NTH-VALUE (%PL-ITERATOR.VALUE SEQUENCE) N MODULE
       ENVIRONMENT)))
    ((CL:EQ TEST-VALUE-000 SGT-PLI-STELLA-CONS)
     (CL:PROGN (STELLA::NTH SEQUENCE N)))
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-STELLA-VECTOR)
     (CL:PROGN
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR (STELLA::%VECTOR.THE-ARRAY SEQUENCE))
       N)))
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:IF (STELLA::FUNCTION-OUTPUT-SKOLEM? SEQUENCE)
       (GET-NTH-VALUE (STELLA::%SKOLEM.DEFINING-PROPOSITION SEQUENCE) N
        MODULE ENVIRONMENT)
       SEQUENCE)))
    (CL:T SEQUENCE))))

;;; (DEFUN (GET-NTH-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:FIXNUM CL:T CL:T) CL:SIMPLE-STRING)
  GET-NTH-STRING))
(CL:DEFUN GET-NTH-STRING (SEQUENCE N MODULE ENVIRONMENT)
  "Return a string representation of the value in the `nth' column of
`sequence'. Counting starts at zero.   Unless `n' is zero, `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  This will always
succeed, even if the `nth' value is not a string object.  In that case, a
string reprensentation will be returned.

As a special case, a column number of zero will also return `sequence' itself
as a string if it is not one of the types enumerated above.  This is done to 
allow the use of `get-nth-string' on PL-iterators with only a single return variable."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (OBJECT-TO-STRING (GET-NTH-VALUE SEQUENCE N MODULE ENVIRONMENT)))

;;; (DEFUN (GET-NTH-INTEGER INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:FIXNUM CL:T CL:T) CL:FIXNUM)
  GET-NTH-INTEGER))
(CL:DEFUN GET-NTH-INTEGER (SEQUENCE N MODULE ENVIRONMENT)
  "Return an integer representation of the value in the `nth' column of
`sequence'. Counting starts at zero.   Unless `n' is zero, `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  If this is not
an integer value, then an exception will be thrown.

As a special case, a column number of zero will also return the integer
value of `sequence' itself if it is not one of the types enumerated
above.   This allows the use of `get-nth-integer' on PL-iterators with
only a single return variable.  If  `sequence' cannot be turned into an
integer, an exception will be thrown."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (OBJECT-TO-INTEGER (GET-NTH-VALUE SEQUENCE N MODULE ENVIRONMENT)))

;;; (DEFUN (GET-NTH-FLOAT FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:FIXNUM CL:T CL:T) CL:DOUBLE-FLOAT)
  GET-NTH-FLOAT))
(CL:DEFUN GET-NTH-FLOAT (SEQUENCE N MODULE ENVIRONMENT)
  "Return the floating point value in the `nth' column of
`sequence'. Counting starts at zero.  `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  If this is not
a floating point value, then an exception will be thrown.

As a special case, a column number of zero will also return the floating
point value of `sequence' itself if it is not one of the types enumerated
above.  This allows the use of `get-nth-float' on PL-iterators with only
a single return variable.    If  `sequence' cannot be turned into a floating
point value, an exception will be thrown."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (OBJECT-TO-FLOAT (GET-NTH-VALUE SEQUENCE N MODULE ENVIRONMENT)))

;;; (DEFUN (GET-NTH-LOGIC-OBJECT LOGIC-OBJECT) ...)

(CL:DEFUN GET-NTH-LOGIC-OBJECT (SEQUENCE N MODULE ENVIRONMENT)
  "Return a logic object representation of the value in the `nth' column
of `sequence'.  Counting starts at zero.   Unless `n' is zero, `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  A zero column number
returns the proposition's relational predicate.  If the return value is
not a LOGIC-OBJECT, an exception is thrown.

As a special case, a column number of zero will also return `sequence' itself
if it is not one of the types enumerated above.  This is done to allow the
use of `get-nth-value' on PL-iterators with only a single return variable.
If `sequence' is not a LOGIC-OBJECT, an exception is thrown."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (CL:LET* ((VALUE (GET-NTH-VALUE SEQUENCE N MODULE ENVIRONMENT)))
   (CL:IF (STELLA::ISA? VALUE SGT-PLI-LOGIC-LOGIC-OBJECT) VALUE
    (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
     (STELLA::%%PRINT-STREAM
      (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "Can't coerce `" VALUE "' to a LOGIC-OBJECT.")
     (CL:ERROR
      (STELLA::NEW-STELLA-EXCEPTION
       (STELLA::THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (GET-ENUMERATED-COLLECTION-MEMBERS CONS) ...)

(CL:DEFUN GET-ENUMERATED-COLLECTION-MEMBERS (COLLECTION MODULE ENVIRONMENT)
  "Returns the members of an enumerated collection.  This works on all types
of collection, i.e., sets and lists"
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:LET*
     ((MEMBERS (STELLA::ASSERTED-COLLECTION-MEMBERS COLLECTION CL:T)))
     (CL:IF (CL:NOT (CL:EQ MEMBERS STELLA::NULL))
      (STELLA::%LIST.THE-CONS-LIST MEMBERS) STELLA::NULL)))))

;;; (DEFUN (EVALUATE OBJECT) ...)

(CL:DEFUN EVALUATE (COMMAND MODULE ENVIRONMENT)
  "Evaluate the command `command' within `module' and return
the result. Currently, only the evaluation of (possibly nested) commands and
global variables is supported.  Commands are simple to program in Common Lisp,
since they are built into the language, and relatively awkward in Java and C++.
Users of either of those languages are more likely to want to call `s-evaluate'."
  (CL:WHEN (CL:NOT (CL:EQ COMMAND STELLA::NULL))
   (CL:LET*
    ((STELLA::*MODULE*
      (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
       STELLA::*MODULE*))
     (STELLA::*CONTEXT* STELLA::*MODULE*))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:RETURN-FROM EVALUATE (STELLA::%EVALUATE COMMAND)))))
  STELLA::NULL)

;;; (DEFUN (S-EVALUATE OBJECT) ...)

(CL:DEFUN S-EVALUATE (COMMAND MODULE-NAME ENVIRONMENT)
  "Evaluate the command represented by the string `command' within `module' and
return the result.  Currently, only the evaluation of (possibly nested) commands and
global variables is supported.

 A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING COMMAND MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE COMMAND CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET* ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT)))
   (CL:LET*
    ((STELLA::*MODULE*
      (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
       STELLA::*MODULE*))
     (STELLA::*CONTEXT* STELLA::*MODULE*))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:SETQ MODULE STELLA::*MODULE*)
     (EVALUATE (STELLA::READ-S-EXPRESSION-FROM-STRING COMMAND) MODULE
      ENVIRONMENT)))))

;;; (DEFUN POWERLOOM ...)

(CL:DEFUN POWERLOOM (MODULE ENVIRONMENT)
  "Run the PowerLoom read/eval/print loop."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (STELLA::POWERLOOM))))

;;; (DEFUN (IS-LOGIC-OBJECT BOOLEAN) ...)

(CL:DEFUN IS-LOGIC-OBJECT (OBJ)
  "Test whether `obj' is of type LOGIC-OBJECT"
  (STELLA::ISA? OBJ SGT-PLI-LOGIC-LOGIC-OBJECT))

;;; (DEFUN (IS-SKOLEM BOOLEAN) ...)

(CL:DEFUN IS-SKOLEM (OBJ)
  "Test whether `obj' is of type SKOLEM (which subsumes pattern variables)."
  (STELLA::ISA? OBJ SGT-PLI-LOGIC-SKOLEM))

;;; (DEFUN (IS-VARIABLE BOOLEAN) ...)

(CL:DEFUN IS-VARIABLE (OBJ)
  "Test whether `obj' is of type PATTERN-VARIABLE."
  (STELLA::ISA? OBJ SGT-PLI-LOGIC-PATTERN-VARIABLE))

;;; (DEFUN (IS-INTEGER BOOLEAN) ...)

(CL:DEFUN IS-INTEGER (OBJ)
  "Test whether `obj' is of type INTEGER"
  (STELLA::ISA? OBJ SGT-PLI-STELLA-INTEGER-WRAPPER))

;;; (DEFUN (IS-FLOAT BOOLEAN) ...)

(CL:DEFUN IS-FLOAT (OBJ)
  "Test whether `obj' is of type FLOAT (double)"
  (STELLA::ISA? OBJ SGT-PLI-STELLA-FLOAT-WRAPPER))

;;; (DEFUN (IS-NUMBER BOOLEAN) ...)

(CL:DEFUN IS-NUMBER (OBJ)
  "Test whether `obj' is of type NUMBER.  This can
be either an integer or a floating point number.  One key characteristic
is that 'object-to-integer' and `object-to-float' will both work on it."
  (STELLA::ISA? OBJ SGT-PLI-STELLA-NUMBER-WRAPPER))

;;; (DEFUN (IS-STRING BOOLEAN) ...)

(CL:DEFUN IS-STRING (OBJ)
  "Test whether `obj' is of type STRING"
  (STELLA::ISA? OBJ SGT-PLI-STELLA-STRING-WRAPPER))

;;; (DEFUN (IS-ENUMERATED-COLLECTION BOOLEAN) ...)

(CL:DEFUN IS-ENUMERATED-COLLECTION (OBJ)
  "Test whether `obj' is an enumerated collection.  This
subsumes both sets and lists."
  (STELLA::LOGICAL-COLLECTION? OBJ))

;;; (DEFUN (IS-ENUMERATED-SET BOOLEAN) ...)

(CL:DEFUN IS-ENUMERATED-SET (OBJ)
  "Test whether `obj' is an enumerated set."
  (STELLA::ENUMERATED-SET? OBJ))

;;; (DEFUN (IS-ENUMERATED-LIST BOOLEAN) ...)

(CL:DEFUN IS-ENUMERATED-LIST (OBJ)
  "Test whether `obj' is an enumerated list"
  (STELLA::ENUMERATED-LIST? OBJ))

;;; (DEFUN (IS-TRUE BOOLEAN) ...)

(CL:DEFUN IS-TRUE (TV)
  "Tests whether `tv' is a true truth value.  It can be true
either absolutely or by default."
  (CL:OR (CL:EQ TV STELLA::TRUE-TRUTH-VALUE)
   (CL:EQ TV STELLA::DEFAULT-TRUE-TRUTH-VALUE)))

;;; (DEFUN (IS-FALSE BOOLEAN) ...)

(CL:DEFUN IS-FALSE (TV)
  "Tests whether `tv' is a false truth value.  It can be false
either absolutely or by default."
  (CL:OR (CL:EQ TV STELLA::FALSE-TRUTH-VALUE)
   (CL:EQ TV STELLA::DEFAULT-FALSE-TRUTH-VALUE)))

;;; (DEFUN (IS-UNKNOWN BOOLEAN) ...)

(CL:DEFUN IS-UNKNOWN (TV)
  "Tests whether `tv' is an unknown truth value."
  (CL:OR (CL:EQ TV STELLA::UNKNOWN-TRUTH-VALUE) (CL:EQ TV STELLA::NULL)))

;;; (DEFUN (IS-KNOWN BOOLEAN) ...)

(CL:DEFUN IS-KNOWN (TV)
  "Tests whether `tv' is a known truth value (i.e., true or false)."
  (STELLA::KNOWN-TRUTH-VALUE? TV))

;;; (DEFUN (IS-INCONSISTENT BOOLEAN) ...)

(CL:DEFUN IS-INCONSISTENT (TV)
  "Tests whether `tv' is an inconsistent truth value."
  (CL:EQ TV STELLA::INCONSISTENT-TRUTH-VALUE))

;;; (DEFUN (IS-STRICT BOOLEAN) ...)

(CL:DEFUN IS-STRICT (TV)
  "Tests whether `tv' is a strict (non-default) truth value."
  (CL:OR (CL:EQ TV STELLA::TRUE-TRUTH-VALUE)
   (CL:EQ TV STELLA::FALSE-TRUTH-VALUE)))

;;; (DEFUN (IS-DEFAULT BOOLEAN) ...)

(CL:DEFUN IS-DEFAULT (TV)
  "Tests whether `tv' is a default truth value."
  (CL:OR (CL:EQ TV STELLA::DEFAULT-TRUE-TRUTH-VALUE)
   (CL:EQ TV STELLA::DEFAULT-FALSE-TRUTH-VALUE)))

;;; (DEFUN (ASK TRUTH-VALUE) ...)

(CL:DEFUN ASK (QUERY MODULE ENVIRONMENT)
  "Returns a truth value for `query' in `module' and `environment'.
`query' has the same syntax as the PowerLoom `ask' command (which see)
but with the `ask' operator omitted.  For example, here are some legal
`query' arguments:
	 
    ((happy Fred))
    ((happy Fred) :inference-level :assertion)
    ((happy Fred) :inference-level :assertion :timeout 1.0)
	
As a convenience, a `query' argument whose first element is a symbol is
interpreted as a sentence that is queried without any options.  For example:
	 
    (happy Fred)
	
is a legal `query' argument.  Note that for a sentence whose relation is a list
itself, e.g., `((FruitFn BananaTree) MyBanana)' this shortcut is not available,
that is, in that case an extra level of list nesting is always necessary.
The returned truth value represents the logical truth of the queried sentence
as determined by PowerLoom.  It can be be tested via the functions `is-true',
`is-false' and `is-unknown' (which see)."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:SETQ QUERY (STELLA::DEOBJECTIFY-TREE QUERY))
    (CL:WHEN (STELLA::SYMBOL? (STELLA::%%VALUE QUERY))
     (CL:SETQ QUERY (STELLA::CONS QUERY STELLA::NIL)))
    (STELLA::CALL-ASK QUERY))))

;;; (DEFUN (S-ASK TRUTH-VALUE) ...)

(CL:DEFUN S-ASK (QUERY MODULE-NAME ENVIRONMENT)
  "Returns a truth value for `query' in module `module-name' and `environment'.
`query' has the same syntax as the PowerLoom `ask' command (which see) but
with the `ask' operator omitted.  Different from the PLI `ask' function, `s-ask'
does not expect a top-level pair of parentheses.  For example, here are some legal
`query' arguments:
	 
    \"(happy Fred)\"
    \"(happy Fred) :inference-level :assertion\"
    \"(happy Fred) :inference-level :assertion :timeout 1.0\"
	
Names in `query' will be interpreted relative to module `module-name'.
A null `module-name' or the empty string refers to the current module.
If no module can be found with the name `module-name', then a STELLA
`no-such-context-exception' is thrown.
The returned truth value represents the logical truth of the queried sentence
as determined by PowerLoom.  It can be be tested via the functions `is-true',
`is-false' and `is-unknown' (which see)."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING QUERY MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE QUERY CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((QUERYFORM STELLA::NIL)
    (MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT)))
   (CL:LET*
    ((STELLA::*MODULE*
      (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
       STELLA::*MODULE*))
     (STELLA::*CONTEXT* STELLA::*MODULE*))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:LET*
      ((SEXP STELLA::NULL)
       (ITER-000
        (STELLA::S-EXPRESSIONS
         (STELLA::NEW-INPUT-STRING-STREAM QUERY)))
       (COLLECT-000 STELLA::NULL))
      (CL:LOOP WHILE (STELLA::NEXT? ITER-000) DO
       (CL:SETQ SEXP (STELLA::%S-EXPRESSION-ITERATOR.VALUE ITER-000))
       (CL:IF (CL:EQ COLLECT-000 STELLA::NULL)
        (CL:PROGN (CL:SETQ COLLECT-000 (STELLA::CONS SEXP STELLA::NIL))
         (CL:IF (CL:EQ QUERYFORM STELLA::NIL)
          (CL:SETQ QUERYFORM COLLECT-000)
          (STELLA::ADD-CONS-TO-END-OF-CONS-LIST QUERYFORM
           COLLECT-000)))
        (CL:PROGN
         (CL:SETF (STELLA::%%REST COLLECT-000)
          (STELLA::CONS SEXP STELLA::NIL))
         (CL:SETQ COLLECT-000 (STELLA::%%REST COLLECT-000))))))))
   (ASK QUERYFORM (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT)
    ENVIRONMENT)))

;;; (DEFUN (RETRIEVE PL-ITERATOR) ...)

(CL:DEFUN RETRIEVE (QUERY MODULE ENVIRONMENT)
  "Returns an iterator of variable bindings that when substituted for the
open variables in `query' satisfy the query proposition.  The query is
run in `module' and relative to `environment'.  `query' has the same syntax
as the PowerLoom `retrieve' command (which see) but with the `retrieve'
operator omitted.    For example, here are some legal `query' arguments:
	 
    ((happy ?x))
    (10 (happy ?x))
    (all (happy ?x))
    (all ?x (happy ?x))
    (10 (happy ?x) :inference-level :assertion)
    (10 (happy ?x) :inference-level :assertion :timeout 1.0)
	
If there is only a single output variable (as in all the examples above)
each element generated by the returned iterator will be a binding for
that variable - unless, the output variable was declared with a surrounding
pair of parentheses.  For example:
	 
    (all (?x) (happy ?x))
	
In that case, the generated elements will be one-element lists.  If there
are multiple output variables, each element generated by the returned
iterator will be a list of variable bindings that can be accessed using
the various `get-nth-...' functions.  The list of output variables does
not need to be declared in which case they are taken to be the open variables
in the query proposition in the order in which they were encountered.  If
order does matter or should be different from its default, it can be forced
by declaring the set of output variables."
  (CL:LET*
   ((STELLA::*MODULE*
     (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
      STELLA::*MODULE*))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:SETQ ENVIRONMENT ENVIRONMENT)
   (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
    (CL:SETQ QUERY (STELLA::DEOBJECTIFY-TREE QUERY))
    (CONS-TO-PL-ITERATOR
     (STELLA::CONSIFY-CURRENT-SOLUTIONS
      (STELLA::CALL-RETRIEVE QUERY))))))

;;; (DEFUN (S-RETRIEVE PL-ITERATOR) ...)

(CL:DEFUN S-RETRIEVE (QUERY MODULE-NAME ENVIRONMENT)
  "Returns an iterator of variable bindings that when substituted for the
open variables in `query' satisfy the query proposition.  The query is
run in `module' and relative to `environment'.  `query' has the same syntax
as the PowerLoom `retrieve' command (which see) but with the `retrieve'
operator omitted.  Different from the PLI `retrieve' function, `s-retrieve'
does not expect a top-level pair of parentheses.  For example, here are some
legal `query' arguments:
	 
    \"(happy ?x)\"
    \"10 (happy ?x)\"
    \"all (happy ?x)\"
    \"all ?x (happy ?x)\"
    \"10 (happy ?x) :inference-level :assertion\"
    \"10 (happy ?x) :inference-level :assertion :timeout 1.0\"
	
If there is only a single output variable (as in all the examples above)
each element generated by the returned iterator will be a binding for
that variable - unless, the output variable was declared with a surrounding
pair of parentheses.  For example:
	 
    \"all (?x) (happy ?x)\"
	
In that case, the generated elements will be one-element lists.  If there
are multiple output variables, each element generated by the returned
iterator will be a list of variable bindings that can be accessed using
the various `get-nth-...' functions.  The list of output variables does
not need to be declared in which case they are taken to be the open variables
in the query proposition in the order in which they were encountered.  If
order does matter or should be different from its default, it can be forced
by declaring the set of output variables.

Names in `query' will be interpreted relative to module `module-name'.
A null `module-name' or the empty string refers to the current module.
If no module can be found with the name `module-name', then a STELLA
`no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING QUERY MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE QUERY CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((QUERYFORM STELLA::NIL)
    (MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT)))
   (CL:LET*
    ((STELLA::*MODULE*
      (CL:IF (CL:NOT (CL:EQ MODULE STELLA::NULL)) MODULE
       STELLA::*MODULE*))
     (STELLA::*CONTEXT* STELLA::*MODULE*))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:LET*
      ((SEXP STELLA::NULL)
       (ITER-000
        (STELLA::S-EXPRESSIONS
         (STELLA::NEW-INPUT-STRING-STREAM QUERY)))
       (COLLECT-000 STELLA::NULL))
      (CL:LOOP WHILE (STELLA::NEXT? ITER-000) DO
       (CL:SETQ SEXP (STELLA::%S-EXPRESSION-ITERATOR.VALUE ITER-000))
       (CL:IF (CL:EQ COLLECT-000 STELLA::NULL)
        (CL:PROGN (CL:SETQ COLLECT-000 (STELLA::CONS SEXP STELLA::NIL))
         (CL:IF (CL:EQ QUERYFORM STELLA::NIL)
          (CL:SETQ QUERYFORM COLLECT-000)
          (STELLA::ADD-CONS-TO-END-OF-CONS-LIST QUERYFORM
           COLLECT-000)))
        (CL:PROGN
         (CL:SETF (STELLA::%%REST COLLECT-000)
          (STELLA::CONS SEXP STELLA::NIL))
         (CL:SETQ COLLECT-000 (STELLA::%%REST COLLECT-000))))))))
   (RETRIEVE QUERYFORM MODULE ENVIRONMENT)))

;;; (DEFUN (GET-FRAME-PROPOSITION PROPOSITION) ...)

(CL:DEFUN GET-FRAME-PROPOSITION (FRAME)
  "Return the proposition currently being inferred by this control `frame'.
This proposition will generally have bound and/or unbound pattern variables as its arguments."
  (STELLA::%CONTROL-FRAME.PROPOSITION FRAME))

;;; (DEFUN (GET-FRAME-ARITY INTEGER) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM) GET-FRAME-ARITY))
(CL:DEFUN GET-FRAME-ARITY (FRAME)
  "Return the arity of the proposition currently being inferred by `frame'.
This will be the actual number of arguments, even if the proposition is of variable arity."
  (STELLA::LENGTH
   (STELLA::%PROPOSITION.ARGUMENTS
    (STELLA::%CONTROL-FRAME.PROPOSITION FRAME))))

;;; (DEFUN (GET-FRAME-ITERATOR PL-ITERATOR) ...)

(CL:DEFUN GET-FRAME-ITERATOR (FRAME)
  "Return the iterator generating successive bindings for the proposition
that is currently being inferred by `frame'."
  (STELLA::DYNAMIC-SLOT-VALUE
   (STELLA::%CONTROL-FRAME.DYNAMIC-SLOTS FRAME) SYM-PLI-STELLA-ITERATOR
   STELLA::NULL))

;;; (DEFUN SET-FRAME-ITERATOR ...)

(CL:DEFUN SET-FRAME-ITERATOR (FRAME ITERATOR)
  "Set the iterator for generating successive bindings for the proposition
that is currently being inferred by `frame' to `iterator'."
  (STELLA::SET-DYNAMIC-SLOT-VALUE
   (STELLA::%CONTROL-FRAME.DYNAMIC-SLOTS FRAME) SYM-PLI-STELLA-ITERATOR
   ITERATOR STELLA::NULL))

;;; (DEFUN (GET-NTH-FRAME-ARGUMENT OBJECT) ...)

(CL:DEFUN GET-NTH-FRAME-ARGUMENT (FRAME N)
  "Return the `n'-th argument of the proposition that is currently being inferred
by `frame'.  This will generally be a pattern variable that might be unbound or bound."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (CL:LET*
   ((ARGS
     (STELLA::%PROPOSITION.ARGUMENTS
      (STELLA::%CONTROL-FRAME.PROPOSITION FRAME))))
   (CL:IF (CL:AND (CL:>= N 0) (CL:< N (STELLA::LENGTH ARGS)))
    (CL:AREF (CL:THE CL:SIMPLE-VECTOR (STELLA::%VECTOR.THE-ARRAY ARGS))
     N)
    (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
     (STELLA::%%PRINT-STREAM
      (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "Argument index `" N "' is out of range for `"
      (STELLA::%CONTROL-FRAME.PROPOSITION FRAME) "'")
     (CL:ERROR
      (STELLA::NEW-LOGIC-EXCEPTION
       (STELLA::THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (GET-NTH-FRAME-BINDING OBJECT) ...)

(CL:DEFUN GET-NTH-FRAME-BINDING (FRAME N)
  "Return the binding of the `n'-th argument of the proposition that is currently
being inferred by `frame'.  This will be NULL if the argument is unbound, otherwise, the object
bound to the variable."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (CL:LET*
   ((ARGS
     (STELLA::%PROPOSITION.ARGUMENTS
      (STELLA::%CONTROL-FRAME.PROPOSITION FRAME))))
   (CL:IF (CL:AND (CL:>= N 0) (CL:< N (STELLA::LENGTH ARGS)))
    (STELLA::SAFE-ARGUMENT-BOUND-TO
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (STELLA::%VECTOR.THE-ARRAY ARGS)) N))
    (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
     (STELLA::%%PRINT-STREAM
      (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "Argument index `" N "' is out of range for `"
      (STELLA::%CONTROL-FRAME.PROPOSITION FRAME) "'")
     (CL:ERROR
      (STELLA::NEW-LOGIC-EXCEPTION
       (STELLA::THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (SET-NTH-FRAME-BINDING BOOLEAN) ...)

(CL:DEFUN SET-NTH-FRAME-BINDING (FRAME N VALUE)
  "Set the binding of the `n'-th argument of the proposition that is currently
being inferred by `frame' to `value'.  If the binding was successful, that is if the argument
was unbound or is already bound to `binding', the function returns TRUE.  Otherwise, the
argument will keep its current binding and FALSE will be returned."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (CL:LET*
   ((ARGS
     (STELLA::%PROPOSITION.ARGUMENTS
      (STELLA::%CONTROL-FRAME.PROPOSITION FRAME))))
   (CL:IF (CL:AND (CL:>= N 0) (CL:< N (STELLA::LENGTH ARGS)))
    (STELLA::BIND-ARGUMENT-TO-VALUE?
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (STELLA::%VECTOR.THE-ARRAY ARGS)) N)
     VALUE CL:T)
    (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
     (STELLA::%%PRINT-STREAM
      (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "Argument index `" N "' is out of range for `"
      (STELLA::%CONTROL-FRAME.PROPOSITION FRAME) "'")
     (CL:ERROR
      (STELLA::NEW-LOGIC-EXCEPTION
       (STELLA::THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (IS-FRAME-BINDING-PATTERN BOOLEAN) ...)

(CL:DEFUN IS-FRAME-BINDING-PATTERN (FRAME PATTERN)
  "Return TRUE if the arguments of `frame' are bound according to `pattern'.
Each character in pattern corresponds to an argument at the particular position and  must be
either `B' (for bound) or `_' for unbound.  The function returns TRUE if `frame' has at least
as many arguments as `pattern' has characters and their bindings match `pattern'.  If `frame'
has additional arguments, they will be ignored.  If `pattern' has more positions than `frame'
has arguments, the function returns FALSE."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATTERN))
  #+MCL
  (CL:CHECK-TYPE PATTERN CL:SIMPLE-STRING)
  (CL:LET*
   ((ARGS
     (STELLA::%PROPOSITION.ARGUMENTS
      (STELLA::%CONTROL-FRAME.PROPOSITION FRAME))))
   (CL:COND
    ((CL:<= (CL:THE CL:FIXNUM (CL:LENGTH PATTERN))
      (STELLA::LENGTH ARGS))
     (CL:LET*
      ((CH STELLA::NULL-CHARACTER) (VECTOR-000 PATTERN) (INDEX-000 0)
       (LENGTH-000 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-000)))
       (ARG STELLA::NULL) (VECTOR-001 ARGS) (INDEX-001 0)
       (LENGTH-001 (STELLA::LENGTH VECTOR-001)))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-000)
       (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
      (CL:LOOP WHILE
       (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001))
       DO
       (CL:SETQ CH
        (CL:LET ((SELF VECTOR-000) (POSITION INDEX-000))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION))))
       (CL:SETQ ARG
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (STELLA::%VECTOR.THE-ARRAY VECTOR-001))
         INDEX-001))
       (CL:CASE CH
        (#\B
         (CL:WHEN
          (CL:EQ (STELLA::SAFE-ARGUMENT-BOUND-TO ARG) STELLA::NULL)
          (CL:RETURN-FROM IS-FRAME-BINDING-PATTERN CL:NIL)))
        (#\_
         (CL:WHEN
          (CL:NOT
           (CL:EQ (STELLA::SAFE-ARGUMENT-BOUND-TO ARG) STELLA::NULL))
          (CL:RETURN-FROM IS-FRAME-BINDING-PATTERN CL:NIL)))
        (CL:OTHERWISE
         (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
          (STELLA::%%PRINT-STREAM
           (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
           "Illegal binding pattern: `" PATTERN "'")
          (CL:ERROR
           (STELLA::NEW-LOGIC-EXCEPTION
            (STELLA::THE-STRING-READER STREAM-000))))))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
     CL:T)
    (CL:T CL:NIL))))

;;; (DEFUN (GET-FRAME-BINDING-PATTERN STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  GET-FRAME-BINDING-PATTERN))
(CL:DEFUN GET-FRAME-BINDING-PATTERN (FRAME)
  "Return a string representation of the argument binding pattern of `frame'.
The syntax of the pattern is the same as used for `is-frame-binding-pattern' (which see)."
  (CL:LET*
   ((ARGS
     (STELLA::%PROPOSITION.ARGUMENTS
      (STELLA::%CONTROL-FRAME.PROPOSITION FRAME)))
    (PATTERN (STELLA::MAKE-RAW-MUTABLE-STRING (STELLA::LENGTH ARGS))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATTERN))
   (CL:LET*
    ((ARG STELLA::NULL) (VECTOR-000 ARGS) (INDEX-000 0)
     (LENGTH-000 (STELLA::LENGTH VECTOR-000)) (I STELLA::NULL-INTEGER)
     (ITER-000 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR (STELLA::%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ I ITER-000)
     (CL:IF
      (CL:NOT
       (CL:EQ (STELLA::SAFE-ARGUMENT-BOUND-TO ARG) STELLA::NULL))
      (CL:LET ((SELF PATTERN) (CH #\B) (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (STELLA::SETF
        (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
         (CL:THE CL:FIXNUM POSITION))
        (CL:THE CL:CHARACTER CH)))
      (CL:LET ((SELF PATTERN) (CH #\_) (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (STELLA::SETF
        (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
         (CL:THE CL:FIXNUM POSITION))
        (CL:THE CL:CHARACTER CH))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:LET ((S PATTERN)) (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
    (CL:THE CL:SIMPLE-STRING S))))

;;; (DEFUN (GET-FRAME-BINDING-STATE CONS) ...)

(CL:DEFUN GET-FRAME-BINDING-STATE (FRAME)
  "Return a frame variable binding stack state that can be used to unbind
all frame variables to the state they were in when the binding stack state was recorded."
  (CL:LET*
   ((PATTERNRECORD
     (STELLA::%QUERY-ITERATOR.CURRENT-PATTERN-RECORD
      STELLA::*QUERYITERATOR*))
    (UBSTACKOFFSET
     (STELLA::%PATTERN-RECORD.TOP-UNBINDING-STACK-OFFSET
      PATTERNRECORD)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM UBSTACKOFFSET))
   (STELLA::CONS PATTERNRECORD
    (STELLA::CONS (STELLA::WRAP-INTEGER UBSTACKOFFSET) STELLA::NIL))))

;;; (DEFUN SET-FRAME-BINDING-STATE ...)

(CL:DEFUN SET-FRAME-BINDING-STATE (FRAME STATE)
  "Reset the frame variable binding stack state to `state'.  This will set
all frame variables to the state they were in when the binding stack state was recorded."
  (STELLA::UNBIND-VARIABLES-BEGINNING-AT (STELLA::%%VALUE STATE)
   (CL:TRUNCATE
    (CL:1+
     (STELLA::NUMBER-WRAPPER-TO-FLOAT
      (STELLA::%%VALUE (STELLA::%%REST STATE)))))))

;;; (DEFUN (GET-PROPERTY-OBJECT OBJECT) ...)

(CL:DEFUN GET-PROPERTY-OBJECT (PROPERTY DEFAULTVALUE)
  "Return the value of the global STELLA configuration `property'
or `defaultValue' if it is undefined."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  (STELLA::%GET-PROPERTY (STELLA::WRAP-STRING PROPERTY)
   (STELLA::CONS-LIST DEFAULTVALUE)))

;;; (DEFUN (GET-PROPERTY-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:SIMPLE-STRING CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  GET-PROPERTY-STRING))
(CL:DEFUN GET-PROPERTY-STRING (PROPERTY DEFAULTVALUE)
  "Return the value of the global STELLA configuration `property'
as a string or `defaultValue' if it is undefined."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY DEFAULTVALUE))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE DEFAULTVALUE CL:SIMPLE-STRING)
  (OBJECT-TO-STRING
   (STELLA::%GET-PROPERTY (STELLA::WRAP-STRING PROPERTY)
    (STELLA::CONS-LIST (STELLA::WRAP-STRING DEFAULTVALUE)))))

;;; (DEFUN (GET-PROPERTY STRING) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:SIMPLE-STRING CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  GET-PROPERTY))
(CL:DEFUN GET-PROPERTY (PROPERTY DEFAULTVALUE)
  "Synonym for `get-property-string' (which see)."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY DEFAULTVALUE))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE DEFAULTVALUE CL:SIMPLE-STRING)
  (GET-PROPERTY-STRING PROPERTY DEFAULTVALUE))

;;; (DEFUN (GET-PROPERTY-INTEGER INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING CL:FIXNUM) CL:FIXNUM)
  GET-PROPERTY-INTEGER))
(CL:DEFUN GET-PROPERTY-INTEGER (PROPERTY DEFAULTVALUE)
  "Return the value of the global STELLA configuration `property'
as an integer or `defaultValue' if it is undefined.  Raises an error if the defined
value is not an integer."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY)
   (CL:TYPE CL:FIXNUM DEFAULTVALUE))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE DEFAULTVALUE CL:FIXNUM)
  (OBJECT-TO-INTEGER
   (STELLA::%GET-PROPERTY (STELLA::WRAP-STRING PROPERTY)
    (STELLA::CONS-LIST (STELLA::WRAP-INTEGER DEFAULTVALUE)))))

;;; (DEFUN (GET-PROPERTY-FLOAT FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:SIMPLE-STRING CL:DOUBLE-FLOAT) CL:DOUBLE-FLOAT)
  GET-PROPERTY-FLOAT))
(CL:DEFUN GET-PROPERTY-FLOAT (PROPERTY DEFAULTVALUE)
  "Return the value of the global STELLA configuration `property'
as a float or `defaultValue' if it is undefined.  Raises an error if the defined
value is not a float."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY)
   (CL:TYPE CL:DOUBLE-FLOAT DEFAULTVALUE))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE DEFAULTVALUE CL:DOUBLE-FLOAT)
  (OBJECT-TO-FLOAT
   (STELLA::%GET-PROPERTY (STELLA::WRAP-STRING PROPERTY)
    (STELLA::CONS-LIST (STELLA::WRAP-FLOAT DEFAULTVALUE)))))

;;; (DEFUN (GET-PROPERTY-BOOLEAN BOOLEAN) ...)

(CL:DEFUN GET-PROPERTY-BOOLEAN (PROPERTY DEFAULTVALUE)
  "Return the value of the global STELLA configuration `property'
as a boolean or `defaultValue' if it is undefined.  Raises an error if the defined
value is not a boolean."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  (STELLA::COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
   (STELLA::COERCE-TO-BOOLEAN
    (STELLA::%GET-PROPERTY (STELLA::WRAP-STRING PROPERTY)
     (STELLA::CONS-LIST
      (CL:IF DEFAULTVALUE STELLA::TRUE-WRAPPER
       STELLA::FALSE-WRAPPER))))))

;;; (DEFUN SET-PROPERTY-OBJECT ...)

(CL:DEFUN SET-PROPERTY-OBJECT (PROPERTY VALUE)
  "Set the global STELLA configuration `property' to `value'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  (STELLA::%SET-PROPERTY (STELLA::WRAP-STRING (STELLA::COPY PROPERTY))
   VALUE))

;;; (DEFUN SET-PROPERTY-STRING ...)

(CL:DEFUN SET-PROPERTY-STRING (PROPERTY VALUE)
  "Set the global STELLA configuration `property' to a string `value'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY VALUE))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE VALUE CL:SIMPLE-STRING)
  (STELLA::%SET-PROPERTY (STELLA::WRAP-STRING (STELLA::COPY PROPERTY))
   (STELLA::WRAP-STRING (STELLA::COPY VALUE))))

;;; (DEFUN SET-PROPERTY ...)

(CL:DEFUN SET-PROPERTY (PROPERTY VALUE)
  "Synonym for `set-property-string' (which see)."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY VALUE))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE VALUE CL:SIMPLE-STRING)
  (SET-PROPERTY-STRING PROPERTY VALUE))

;;; (DEFUN SET-PROPERTY-INTEGER ...)

(CL:DEFUN SET-PROPERTY-INTEGER (PROPERTY VALUE)
  "Set the global STELLA configuration `property' to an integer `value'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY)
   (CL:TYPE CL:FIXNUM VALUE))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE VALUE CL:FIXNUM)
  (STELLA::%SET-PROPERTY (STELLA::WRAP-STRING (STELLA::COPY PROPERTY))
   (STELLA::WRAP-INTEGER VALUE)))

;;; (DEFUN SET-PROPERTY-FLOAT ...)

(CL:DEFUN SET-PROPERTY-FLOAT (PROPERTY VALUE)
  "Set the global STELLA configuration `property' to a float `value'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY)
   (CL:TYPE CL:DOUBLE-FLOAT VALUE))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE VALUE CL:DOUBLE-FLOAT)
  (STELLA::%SET-PROPERTY (STELLA::WRAP-STRING (STELLA::COPY PROPERTY))
   (STELLA::WRAP-FLOAT VALUE)))

;;; (DEFUN SET-PROPERTY-BOOLEAN ...)

(CL:DEFUN SET-PROPERTY-BOOLEAN (PROPERTY VALUE)
  "Set the global STELLA configuration `property' to a boolean `value'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  (STELLA::%SET-PROPERTY (STELLA::WRAP-STRING (STELLA::COPY PROPERTY))
   (CL:IF VALUE STELLA::TRUE-WRAPPER STELLA::FALSE-WRAPPER)))

;;; (DEFUN (IS-DEFINED-PROPERTY BOOLEAN) ...)

(CL:DEFUN IS-DEFINED-PROPERTY (PROPERTY)
  "Return TRUE if `property' has a defined value."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  (CL:LET*
   ((VALUE
     (STELLA::%GET-PROPERTY (STELLA::WRAP-STRING PROPERTY)
      STELLA::NIL)))
   (CL:AND (CL:NOT (CL:EQ VALUE STELLA::NULL))
    (CL:NOT (STELLA::NULL-WRAPPER? VALUE)))))

;;; (DEFUN PRINT-PROPERTIES ...)

(CL:DEFUN PRINT-PROPERTIES ()
  "Print all currently defined STELLA configuration properties and values."
  (STELLA::PRINT-PROPERTIES))

;;; (DEFUN (GET-EXCEPTION-HANDLER FUNCTION-CODE) ...)

(CL:DEFUN GET-EXCEPTION-HANDLER ()
  (STELLA::GET-GLOBAL-EXCEPTION-HANDLER))

;;; (DEFUN SET-EXCEPTION-HANDLER ...)

(CL:DEFUN SET-EXCEPTION-HANDLER (HANDLER)
  (STELLA::SET-GLOBAL-EXCEPTION-HANDLER HANDLER))

(CL:DEFUN NEW-OBJECT-REGISTRY-LIST ()
  (CL:LET* ((SELF STELLA::NULL))
   (CL:SETQ SELF (%MAKE-OBJECT-REGISTRY-LIST))
   (CL:SETF (%OBJECT-REGISTRY-LIST.THE-CONS-LIST SELF) STELLA::NIL)
   (CL:SETF (%OBJECT-REGISTRY-LIST.N-FREE-CELLS SELF) 0)
   (CL:SETF (%OBJECT-REGISTRY-LIST.REGISTRY-LENGTH SELF) 0) SELF))

(CL:DEFMETHOD STELLA::PRIMARY-TYPE ((SELF OBJECT-REGISTRY-LIST))
  SGT-PLI-PLI-OBJECT-REGISTRY-LIST)

(CL:DEFUN ACCESS-OBJECT-REGISTRY-LIST-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PLI-PLI-REGISTRY-LENGTH)
    (CL:IF SETVALUE?
     (CL:SETF (%OBJECT-REGISTRY-LIST.REGISTRY-LENGTH SELF)
      (STELLA::%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (STELLA::WRAP-INTEGER
       (%OBJECT-REGISTRY-LIST.REGISTRY-LENGTH SELF)))))
   ((CL:EQ SLOTNAME SYM-PLI-PLI-N-FREE-CELLS)
    (CL:IF SETVALUE?
     (CL:SETF (%OBJECT-REGISTRY-LIST.N-FREE-CELLS SELF)
      (STELLA::%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (STELLA::WRAP-INTEGER
       (%OBJECT-REGISTRY-LIST.N-FREE-CELLS SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
     (STELLA::%%PRINT-STREAM
      (STELLA::%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
      SLOTNAME "' is not a valid case option")
     (CL:ERROR
      (STELLA::NEW-STELLA-EXCEPTION
       (STELLA::THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFGLOBAL *OBJECT-REGISTRY* ...)

(CL:DEFVAR *OBJECT-REGISTRY* STELLA::NULL)

;;; (DEFUN (REGISTER-OBJECT CONS) ...)

(CL:DEFUN REGISTER-OBJECT (OBJECT)
  "Register `object' to prevent it from being garbage-collected by the PowerLoom GC.
The result of registration is a handle for `object' which can later be used to unregister it.
Currently it is assumed that calling this immediately after an object was returned by a PLI function
is safe; however, we might have to handle registration in PLI functions before objects are returned.
This is not thread safe and needs to be explicitly synchronized in a threaded environment."
  (CL:LET* ((REGISTRY *OBJECT-REGISTRY*))
   (STELLA::PUSH REGISTRY OBJECT)
   (CL:SETF (%OBJECT-REGISTRY-LIST.REGISTRY-LENGTH REGISTRY)
    (CL:1+ (%OBJECT-REGISTRY-LIST.REGISTRY-LENGTH REGISTRY)))
   (%OBJECT-REGISTRY-LIST.THE-CONS-LIST REGISTRY)))

;;; (DEFUN UNREGISTER-OBJECT ...)

(CL:DEFUN UNREGISTER-OBJECT (OBJECTHANDLE)
  "Unregister the object whose registered handle is `objectHandle' to make it available
for PowerLoom garbage collection.  This also is not thread safe and needs to be explicitly synchronized
in a threaded environment."
  (CL:LET*
   ((REGISTRY *OBJECT-REGISTRY*)
    (NFREE (%OBJECT-REGISTRY-LIST.N-FREE-CELLS REGISTRY)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NFREE))
   (CL:SETF (STELLA::%%VALUE OBJECTHANDLE) STELLA::NULL)
   (CL:SETQ NFREE (CL:1+ NFREE))
   (CL:WHEN
    (CL:AND (CL:> NFREE 1000)
     (CL:>= NFREE
      (CL:LET
       ((ARG (%OBJECT-REGISTRY-LIST.REGISTRY-LENGTH REGISTRY))
        (COUNT 1))
       (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
       (CL:THE CL:FIXNUM
        (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT)))))))
    (STELLA::REMOVE REGISTRY STELLA::NULL)
    (CL:SETF (%OBJECT-REGISTRY-LIST.REGISTRY-LENGTH REGISTRY)
     (CL:- (%OBJECT-REGISTRY-LIST.REGISTRY-LENGTH REGISTRY) NFREE))
    (CL:SETQ NFREE 0))
   (CL:SETF (%OBJECT-REGISTRY-LIST.N-FREE-CELLS REGISTRY) NFREE)))

;;; (DEFUN MAIN ...)

(CL:DEFUN MAIN ()
  (STELLA::%%PRINT-STREAM
   (STELLA::%OUTPUT-STREAM.NATIVE-STREAM STELLA::STANDARD-OUTPUT)
   "Initializing STELLA..." EOL)
  (STELLA::STARTUP-STELLA-SYSTEM)
  (STELLA::%%PRINT-STREAM
   (STELLA::%OUTPUT-STREAM.NATIVE-STREAM STELLA::STANDARD-OUTPUT)
   "Initializing PowerLoom..." EOL)
  (STELLA::STARTUP-LOGIC-SYSTEM)
  (STELLA::CHANGE-MODULE "PL-USER")
  (STELLA::POWERLOOM))

(CL:DEFUN HELP-STARTUP-PLI1 ()
  (CL:PROGN
   (CL:SETQ SGT-PLI-PLI-ENVIRONMENT
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "ENVIRONMENT" STELLA::NULL
     1))
   (CL:SETQ SYM-PLI-LOGIC-LEVEL
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "LEVEL"
     (STELLA::GET-STELLA-MODULE "/LOGIC" CL:T) 0))
   (CL:SETQ SGT-PLI-PLI-PL-ITERATOR
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "PL-ITERATOR" STELLA::NULL
     1))
   (CL:SETQ SYM-PLI-STELLA-CURSOR
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "CURSOR"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-PLI-STELLA-CONS
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "CONS"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PLI-STELLA-LIST
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "LIST"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PLI-STELLA-VECTOR
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "VECTOR"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-PLI-STELLA-NULL
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "NULL"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-PLI-LOGIC-SKOLEM
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM"
     (STELLA::GET-STELLA-MODULE "/LOGIC" CL:T) 1))
   (CL:SETQ SGT-PLI-LOGIC-LOGIC-OBJECT
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT"
     (STELLA::GET-STELLA-MODULE "/LOGIC" CL:T) 1))
   (CL:SETQ SGT-PLI-STELLA-GENERALIZED-SYMBOL
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "GENERALIZED-SYMBOL"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PLI-STELLA-MODULE
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PLI-STELLA-CONTEXT
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "CONTEXT"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PLI-LOGIC-COMPUTED-PROCEDURE
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "COMPUTED-PROCEDURE"
     (STELLA::GET-STELLA-MODULE "/LOGIC" CL:T) 1))
   (CL:SETQ SGT-PLI-STELLA-LITERAL-WRAPPER
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL-WRAPPER"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PLI-LOGIC-NAMED-DESCRIPTION
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION"
     (STELLA::GET-STELLA-MODULE "/LOGIC" CL:T) 1))
   (CL:SETQ SYM-PLI-PLI-?R
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "?R" STELLA::NULL 0))
   (CL:SETQ SYM-PLI-PLI-?I
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "?I" STELLA::NULL 0))
   (CL:SETQ SYM-PLI-PLI-?V
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "?V" STELLA::NULL 0))
   (CL:SETQ
    SYM-PLI-PLI-F-GET-INFERRED-BINARY-PROPOSITION-VALUES-QUERY-000
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE
     "F-GET-INFERRED-BINARY-PROPOSITION-VALUES-QUERY-000" STELLA::NULL
     0))
   (CL:SETQ SYM-PLI-LOGIC-ALL
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "ALL"
     (STELLA::GET-STELLA-MODULE "/LOGIC" CL:T) 0))
   (CL:SETQ SYM-PLI-LOGIC-?X
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "?X"
     (STELLA::GET-STELLA-MODULE "/LOGIC" CL:T) 0))
   (CL:SETQ SYM-PLI-STELLA-AND
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "AND"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PLI-LOGIC-FAIL
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL"
     (STELLA::GET-STELLA-MODULE "/LOGIC" CL:T) 0))
   (CL:SETQ SYM-PLI-STELLA-EXISTS
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PLI-LOGIC-?Y
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "?Y"
     (STELLA::GET-STELLA-MODULE "/LOGIC" CL:T) 0))
   (CL:SETQ SYM-PLI-PLI-PROPER-SUBRELATION
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "PROPER-SUBRELATION"
     STELLA::NULL 0))
   (CL:SETQ SYM-PLI-STELLA-TRUE
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PLI-STELLA-FALSE
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-PLI-CASE-SENSITIVE?
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "CASE-SENSITIVE?"
     STELLA::NULL 2))
   (CL:SETQ KWD-PLI-SUBSET-OF
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSET-OF" STELLA::NULL
     2))
   (CL:SETQ KWD-PLI-ERROR
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" STELLA::NULL 2))
   (CL:SETQ KWD-PLI-RETRACT-TRUE
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT-TRUE" STELLA::NULL
     2))
   (CL:SETQ KWD-PLI-ASSERT-TRUE
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT-TRUE" STELLA::NULL
     2))
   (CL:SETQ SGT-PLI-LOGIC-PROPOSITION
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION"
     (STELLA::GET-STELLA-MODULE "/LOGIC" CL:T) 1))
   (CL:SETQ SGT-PLI-LOGIC-DESCRIPTION
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION"
     (STELLA::GET-STELLA-MODULE "/LOGIC" CL:T) 1))
   (CL:SETQ SGT-PLI-PL-KERNEL-KB-NTH-DOMAIN
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "NTH-DOMAIN"
     (STELLA::GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-PLI-MODULE
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE" STELLA::NULL 2))
   (CL:SETQ SGT-PLI-LOGIC-PATTERN-VARIABLE
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE"
     (STELLA::GET-STELLA-MODULE "/LOGIC" CL:T) 1))
   (CL:SETQ SGT-PLI-STELLA-INTEGER-WRAPPER
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-WRAPPER"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PLI-STELLA-FLOAT-WRAPPER
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT-WRAPPER"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PLI-STELLA-NUMBER-WRAPPER
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER-WRAPPER"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PLI-STELLA-STRING-WRAPPER
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-WRAPPER"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-PLI-STELLA-ITERATOR
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-PLI-PLI-OBJECT-REGISTRY-LIST
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-REGISTRY-LIST"
     STELLA::NULL 1))
   (CL:SETQ SYM-PLI-PLI-REGISTRY-LENGTH
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "REGISTRY-LENGTH"
     STELLA::NULL 0))
   (CL:SETQ SYM-PLI-PLI-N-FREE-CELLS
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "N-FREE-CELLS" STELLA::NULL
     0))
   (CL:SETQ KWD-PLI-DOCUMENTATION
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION"
     STELLA::NULL 2))
   (CL:SETQ SYM-PLI-PLI-STARTUP-PLI
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-PLI" STELLA::NULL
     0))
   (CL:SETQ SYM-PLI-STELLA-METHOD-STARTUP-CLASSNAME
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN HELP-STARTUP-PLI2 ()
  (CL:PROGN
   (STELLA::DEFINE-FUNCTION-OBJECT "INITIALIZE"
    "(DEFUN INITIALIZE () :DOCUMENTATION \"Initialize the PowerLoom logic system.  This function
needs to be called by all applications before using PowerLoom.  If it
is called more than once, every call after the first one is a no-op.\" :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION INITIALIZE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "RESET-POWERLOOM"
    "(DEFUN RESET-POWERLOOM () :DOCUMENTATION \"Reset PowerLoom to its initial state.
CAUTION: This will destroy all loaded knowledge bases and might break other
loaded STELLA systems if they do reference PowerLoom symbols in their code.\" :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION RESET-POWERLOOM) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CLEAR-CACHES"
    "(DEFUN CLEAR-CACHES () :DOCUMENTATION \"Clear all query and memoization caches.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION CLEAR-CACHES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "TEST-ENVIRONMENT-LEVEL?"
    "(DEFUN (TEST-ENVIRONMENT-LEVEL? BOOLEAN) ((ENV ENVIRONMENT) (LEVEL STRING)) :PUBLIC? FALSE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Test if `env' has level set to `level'\" (RETURN (AND (DEFINED? ENV) (STRING-EQL? (LEVEL ENV) LEVEL))))"
    (CL:FUNCTION TEST-ENVIRONMENT-LEVEL?) STELLA::NULL)
   (STELLA::DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF PL-ITERATOR)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Advance the PL-Iterator `self' and return `true' if more
elements are available, `false' otherwise.\")"
    (STELLA::WRAP-METHOD-CODE (CL:FUNCTION STELLA::NEXT?))
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "PL-ITERATOR-VALUE"
    "(DEFUN (PL-ITERATOR-VALUE OBJECT) ((SELF PL-ITERATOR)) :DOCUMENTATION \"C-callable iterator `value'-slot accessor.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION PL-ITERATOR-VALUE) STELLA::NULL)
   (STELLA::DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF PL-ITERATOR)) :DOCUMENTATION \"Return TRUE if the iterator `self' has no more elements.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (STELLA::WRAP-METHOD-CODE (CL:FUNCTION STELLA::EMPTY?))
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "PL-ITERATOR-IS-EMPTY"
    "(DEFUN (PL-ITERATOR-IS-EMPTY BOOLEAN) ((SELF PL-ITERATOR)) :DOCUMENTATION \"Return TRUE if the iterator `self' has no more elements.
This is here primarily to support the `is-...' naming convention for tests.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION PL-ITERATOR-IS-EMPTY) STELLA::NULL)
   (STELLA::DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((SELF PL-ITERATOR)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Number of items remaining in `self'.  Non destructive.\")"
    (STELLA::WRAP-METHOD-CODE (CL:FUNCTION STELLA::LENGTH))
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CONS-TO-PL-ITERATOR"
    "(DEFUN (CONS-TO-PL-ITERATOR PL-ITERATOR) ((SELF CONS)) :DOCUMENTATION \"Convert a STELLA cons list into an API iterator.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION CONS-TO-PL-ITERATOR) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "LIST-TO-PL-ITERATOR"
    "(DEFUN (LIST-TO-PL-ITERATOR PL-ITERATOR) ((SELF LIST)) :DOCUMENTATION \"Convert a STELLA list into an API iterator.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION LIST-TO-PL-ITERATOR) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "ITERATOR-TO-PL-ITERATOR"
    "(DEFUN (ITERATOR-TO-PL-ITERATOR PL-ITERATOR) ((SELF ITERATOR)) :DOCUMENTATION \"Convert an arbitrary STELLA iterator into an API iterator.
This will first exhaust `self' and then create an API iterator that will
iterate over the previously generated values.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION ITERATOR-TO-PL-ITERATOR) STELLA::NULL)
   (STELLA::DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LISTIFY LIST) ((SELF PL-ITERATOR)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Convert `self' into a Stella LIST.\")"
    (STELLA::WRAP-METHOD-CODE (CL:FUNCTION STELLA::LISTIFY))
    STELLA::NULL)
   (STELLA::DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONSIFY CONS) ((SELF PL-ITERATOR)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Convert `self' into a Stella CONS.\")"
    (STELLA::WRAP-METHOD-CODE (CL:FUNCTION STELLA::CONSIFY))
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-CONS"
    "(DEFUN (CREATE-CONS CONS) ((FIRST OBJECT) (REST CONS)) :DOCUMENTATION \"Create a STELLA CONS-cell whose value points to `first' and tail points to `rest'.
If `rest' is NULL, it will point to the empty list (available as a constructor in C).\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION CREATE-CONS) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-CONS-LIST"
    "(DEFUN (CREATE-CONS-LIST CONS) ((LENGTH INTEGER)) :DOCUMENTATION \"Create a STELLA CONS-list of `length' with elements initialized to NULL (available as a constructor in C).\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION CREATE-CONS-LIST) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CONS-LENGTH"
    "(DEFUN (CONS-LENGTH INTEGER) ((SELF CONS)) :DOCUMENTATION \"Return the length of the CONS-list `self' (available to support access in C).\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION CONS-LENGTH) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CONS-IS-EMPTY"
    "(DEFUN (CONS-IS-EMPTY BOOLEAN) ((SELF CONS)) :DOCUMENTATION \"Return TRUE if the CONS-list `self' is empty (available to support access in C).\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION CONS-IS-EMPTY) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CONS-FIRST"
    "(DEFUN (CONS-FIRST (LIKE (ANY-VALUE SELF))) ((SELF CONS)) :DOCUMENTATION \"Access the first element of the CONS-list `self' (available to support access in C).\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION CONS-FIRST) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CONS-REST"
    "(DEFUN (CONS-REST (LIKE SELF)) ((SELF CONS)) :DOCUMENTATION \"Access the rest (tail) of the CONS-list `self' (available to support access in C).\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION CONS-REST) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CONS-NTH"
    "(DEFUN (CONS-NTH (LIKE (ANY-VALUE SELF))) ((SELF CONS) (N INTEGER)) :DOCUMENTATION \"Access the `n'-th element of the CONS-list `self' (available to support access in C).\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION CONS-NTH) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CONS-NTH-REST"
    "(DEFUN (CONS-NTH-REST (LIKE SELF)) ((SELF CONS) (N INTEGER)) :DOCUMENTATION \"Access the `n'-th rest (tail) of the CONS-list `self' (available to support access in C).\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION CONS-NTH-REST) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CONS-SET-FIRST"
    "(DEFUN CONS-SET-FIRST ((SELF CONS) (VALUE OBJECT)) :DOCUMENTATION \"Set the first element of the CONS-list `self' to `value' (available to support access in C).\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION CONS-SET-FIRST) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CONS-SET-REST"
    "(DEFUN CONS-SET-REST ((SELF CONS) (REST CONS)) :DOCUMENTATION \"Set the rest (tail) of the CONS-list `self' to `rest' (available to support access in C).
If `rest' is NULL, it will point to the empty list.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION CONS-SET-REST) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CONS-SET-NTH"
    "(DEFUN CONS-SET-NTH ((SELF CONS) (N INTEGER) (VALUE OBJECT)) :DOCUMENTATION \"Set the `n'-th element of the CONS-list `self' to `value' (available to support access in C).
The run-time complexity of this operation is O(n).\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION CONS-SET-NTH) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CONS-SET-NTH-REST"
    "(DEFUN CONS-SET-NTH-REST ((SELF CONS) (N INTEGER) (REST CONS)) :DOCUMENTATION \"Set the `n'-th rest (tail) of the CONS-list `self' to `rest' (available to support access in C).
If `rest' is NULL, it will point to the empty list.  The run-time complexity of this operation is O(n).\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION CONS-SET-NTH-REST) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "LIST-FIRST"
    "(DEFUN (LIST-FIRST (LIKE (ANY-VALUE SELF))) ((SELF LIST)) :DOCUMENTATION \"Access the first element of the list `self' (available to support access in C).\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION LIST-FIRST) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "LIST-REST"
    "(DEFUN (LIST-REST (CONS OF (LIKE (ANY-VALUE SELF)))) ((SELF LIST)) :DOCUMENTATION \"Access the rest (tail) of the list `self' (available to support access in C).
NOTE: the rest of a STELLA list is a CONS-list not a LIST.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION LIST-REST) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "LIST-NTH"
    "(DEFUN (LIST-NTH (LIKE (ANY-VALUE SELF))) ((SELF LIST) (N INTEGER)) :DOCUMENTATION \"Access the `n'-th element of the list `self' (available to support access in C).\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION LIST-NTH) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-STRING"
    "(DEFUN (CREATE-STRING STRING) ((CONTENT STRING)) :DOCUMENTATION \"Create a PowerLoom copy of the string `content' which uses PowerLoom memory
management and garbage collection.  This is primarily necessary in C environments when a string
is passed to a PowerLoom PLI function which might then be pointed to by a PowerLoom result
object such as a string wrapper.  If such an argument string is later explicitly freed or
overwritten, the result object would have a dangling reference or its content destroyed.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION CREATE-STRING) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-STRING-WRAPPER"
    "(DEFUN (CREATE-STRING-WRAPPER STRING-WRAPPER) ((SELF STRING)) :DOCUMENTATION \"Create a STELLA string wrapper for `self'.  This automatically copies `self'
before the wrapper is allocated to avoid garbage collection issues in case `self' is freed.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION CREATE-STRING-WRAPPER) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-DIRECT-STRING-WRAPPER"
    "(DEFUN (CREATE-DIRECT-STRING-WRAPPER STRING-WRAPPER) ((SELF STRING)) :DOCUMENTATION \"Create a STELLA string wrapper for `self'.  This wraps `self' directly
and does not allocate a PowerLoom copy first, hence, memory management of `self' needs to
be carefully handled by the caller.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION CREATE-DIRECT-STRING-WRAPPER) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-INTEGER-WRAPPER"
    "(DEFUN (CREATE-INTEGER-WRAPPER INTEGER-WRAPPER) ((SELF INTEGER)) :DOCUMENTATION \"Create a STELLA integer wrapper for `self'.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION CREATE-INTEGER-WRAPPER) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-LONG-INTEGER-WRAPPER"
    "(DEFUN (CREATE-LONG-INTEGER-WRAPPER LONG-INTEGER-WRAPPER) ((SELF LONG-INTEGER)) :DOCUMENTATION \"Create a STELLA long-integer wrapper for `self'.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION CREATE-LONG-INTEGER-WRAPPER) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-FLOAT-WRAPPER"
    "(DEFUN (CREATE-FLOAT-WRAPPER FLOAT-WRAPPER) ((SELF FLOAT)) :DOCUMENTATION \"Create a STELLA float wrapper for `self'.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION CREATE-FLOAT-WRAPPER) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-BOOLEAN-WRAPPER"
    "(DEFUN (CREATE-BOOLEAN-WRAPPER BOOLEAN-WRAPPER) ((SELF BOOLEAN)) :DOCUMENTATION \"Create a STELLA boolean wrapper for `self'.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION CREATE-BOOLEAN-WRAPPER) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "SAFELY-GET-OBJECT"
    "(DEFUN (SAFELY-GET-OBJECT OBJECT) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? FALSE)"
    (CL:FUNCTION SAFELY-GET-OBJECT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "SAFELY-GET-CONCEPT"
    "(DEFUN (SAFELY-GET-CONCEPT OBJECT) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? FALSE)"
    (CL:FUNCTION SAFELY-GET-CONCEPT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "SAFELY-GET-RELATION"
    "(DEFUN (SAFELY-GET-RELATION OBJECT) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? FALSE)"
    (CL:FUNCTION SAFELY-GET-RELATION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "SAFELY-GET-MODULE"
    "(DEFUN (SAFELY-GET-MODULE CONTEXT) ((NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? FALSE)"
    (CL:FUNCTION SAFELY-GET-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "SAFELY-GET-OBJECT-OR-NULL"
    "(DEFUN (SAFELY-GET-OBJECT-OR-NULL OBJECT) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? FALSE)"
    (CL:FUNCTION SAFELY-GET-OBJECT-OR-NULL) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "SEQUENCE-TO-CONS-LIST"
    "(DEFUN (SEQUENCE-TO-CONS-LIST CONS) ((SEQUENCE OBJECT)) :PUBLIC? FALSE)"
    (CL:FUNCTION SEQUENCE-TO-CONS-LIST) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "EXPLODE-STRING-LIST"
    "(DEFUN (EXPLODE-STRING-LIST CONS) ((STRINGLIST STRING) (MODULE MODULE)) :PUBLIC? FALSE)"
    (CL:FUNCTION EXPLODE-STRING-LIST) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "LEGAL-OPERATOR?"
    "(DEFUN (LEGAL-OPERATOR? BOOLEAN) ((OPERATOR SYMBOL)) :PUBLIC? FALSE)"
    (CL:FUNCTION LEGAL-OPERATOR?) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-KEYWORD"
    "(DEFUN (GET-KEYWORD KEYWORD) ((NAME STRING)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Returns the Stella KEYWORD `name' if it exists.  Case sensitive.\")"
    (CL:FUNCTION GET-KEYWORD) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-SYMBOL"
    "(DEFUN (GET-SYMBOL SYMBOL) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Returns the Stella SYMBOL `name' visible in `module' if it
exists.  `name' is ALWAYS treated literally and case sensitively.\")"
    (CL:FUNCTION GET-SYMBOL) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-OPERATOR"
    "(DEFUN (GET-OPERATOR SYMBOL) ((NAME STRING)) :DOCUMENTATION \"Returns the logical operator object (a Stella SYMBOL) for `name'.
If no such operator exists then a `no-such-object' exception is thrown.\" :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION GET-OPERATOR) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-OBJECT"
    "(DEFUN (GET-OBJECT OBJECT) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Look for an object named `name' that is local to
or visible from the module `module'.  `name' is not taken literally
but will be parsed first with the PowerLoom symbol reader and, hence,
can contain escape characters, module prefixes, etc.\")"
    (CL:FUNCTION GET-OBJECT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-OBJECT"
    "(DEFUN (S-GET-OBJECT OBJECT) ((NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Look for an object named `name' that is local to
or visible from the module `module-name'.  A module name of `null' or the
empty string refers to the current module.  If no module can be found
with the name `module-name', then a STELLA `no-such-context-exception' is thrown.
`name' is not taken literally but will be parsed first (see `get-object').\")"
    (CL:FUNCTION S-GET-OBJECT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-CONCEPT"
    "(DEFUN (GET-CONCEPT LOGIC-OBJECT) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return a class/concept named `name' that is local to
or visible from the module `module'.  `name' is not taken literally but
will be parsed first (see `get-object').\")" (CL:FUNCTION GET-CONCEPT)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-CONCEPT"
    "(DEFUN (S-GET-CONCEPT LOGIC-OBJECT) ((NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return a class/concept named `name' that is local to
or visible from the module `module-name'.  A module name of `null' or the
empty string refers to the current module.  If no module can be found
with the name `module-name', then a Stella `no-such-context-exception' is thrown.
`name' is not taken literally but will be parsed first (see `get-object').\")"
    (CL:FUNCTION S-GET-CONCEPT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-RELATION"
    "(DEFUN (GET-RELATION LOGIC-OBJECT) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return a concept or relation named `name' that is local to
or visible from the module `module'.  `name' is not taken literally but will
be parsed first (see `get-object').\")" (CL:FUNCTION GET-RELATION)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-RELATION"
    "(DEFUN (S-GET-RELATION LOGIC-OBJECT) ((NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return a concept or relation named `name' that is local to
or visible from the module `module-name'.  A module name of `null' or the
empty string refers to the current module.  If no module can be found
with the name `module-name', then a Stella `no-such-context-exception' is thrown.
`name' is not taken literally but will be parsed first (see `get-object').\")"
    (CL:FUNCTION S-GET-RELATION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-UNDEFINED-RELATIONS"
    "(DEFUN (GET-UNDEFINED-RELATIONS (PL-ITERATOR OF LOGIC-OBJECT)) ((MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return relations that have been referenced but not defined in `module'.\")"
    (CL:FUNCTION GET-UNDEFINED-RELATIONS) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-NAME-IN-MODULE"
    "(DEFUN (GET-NAME-IN-MODULE STRING) ((OBJ OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return the name, qualified as necessary, so that `obj' can be found from
`module'.  If there is no name for the object return `null'.\")"
    (CL:FUNCTION GET-NAME-IN-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-NAME"
    "(DEFUN (GET-NAME STRING) ((OBJ OBJECT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return the fully qualified name of `obj', if it has one.  Otherwise return `null'.\")"
    (CL:FUNCTION GET-NAME) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-SHORT-NAME"
    "(DEFUN (GET-SHORT-NAME STRING) ((OBJ OBJECT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return the short name of `obj', if it has one.  Otherwise return `null'.\")"
    (CL:FUNCTION GET-SHORT-NAME) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-SKOLEM-NAME"
    "(DEFUN (GET-SKOLEM-NAME STRING) ((SKOLEM SKOLEM)) :DOCUMENTATION \"Return the fully qualified name of `skolem'.  Note that skolems are anonymous objects
which cannot be referenced by their name in logic expressions, so this function is only useful in special
circumstances such as inside specialist computations, etc.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION GET-SKOLEM-NAME) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-SKOLEM-SHORT-NAME"
    "(DEFUN (GET-SKOLEM-SHORT-NAME STRING) ((SKOLEM SKOLEM)) :DOCUMENTATION \"Return the unqualified name of `skolem'.  Note that skolems are anonymous objects which
cannot be referenced by their name in logic expressions, so this function is only useful in special
circumstances such as inside specialist computations, etc.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION GET-SKOLEM-SHORT-NAME) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-VARIABLE-NAME"
    "(DEFUN (GET-VARIABLE-NAME STRING) ((VARIABLE PATTERN-VARIABLE)) :DOCUMENTATION \"Return the fully qualified name of `variable'.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION GET-VARIABLE-NAME) STELLA::NULL)))

(CL:DEFUN HELP-STARTUP-PLI3 ()
  (CL:PROGN
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-VARIABLE-SHORT-NAME"
    "(DEFUN (GET-VARIABLE-SHORT-NAME STRING) ((VARIABLE PATTERN-VARIABLE)) :DOCUMENTATION \"Return the unqualified name of `variable'.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION GET-VARIABLE-SHORT-NAME) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "OBJECT-TO-STRING"
    "(DEFUN (OBJECT-TO-STRING STRING) ((SELF OBJECT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return a printed representation of the term `self' as a string.\")"
    (CL:FUNCTION OBJECT-TO-STRING) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "OBJECT-TO-INTEGER"
    "(DEFUN (OBJECT-TO-INTEGER INTEGER) ((SELF OBJECT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Coerce `self' to an integer, or throw a Stella Exception if the coersion is not feasible.
Floating point values will be coerced by rounding.\")"
    (CL:FUNCTION OBJECT-TO-INTEGER) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "OBJECT-TO-FLOAT"
    "(DEFUN (OBJECT-TO-FLOAT FLOAT) ((SELF OBJECT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Coerce `self' to a float, or throw a Stella Exception if the coersion is not feasible.\")"
    (CL:FUNCTION OBJECT-TO-FLOAT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "OBJECT-TO-PARSABLE-STRING"
    "(DEFUN (OBJECT-TO-PARSABLE-STRING STRING) ((SELF OBJECT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return a string representing a printed
representation of the object `self'.  Like `object-to-string', but puts
escaped double quotes around strings.\")"
    (CL:FUNCTION OBJECT-TO-PARSABLE-STRING) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-STELLA-TYPE"
    "(DEFUN (GET-STELLA-TYPE SYMBOL) ((SELF OBJECT)) :DOCUMENTATION \"Return the name symbol of the STELLA class of which `self' is a direct instance.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION GET-STELLA-TYPE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-LOGIC-TYPE"
    "(DEFUN (GET-LOGIC-TYPE SYMBOL) ((SELF OBJECT)) :DOCUMENTATION \"Return the name symbol of the logic object type of `self'.  This type describes the basic
role this object plays in the logic system such as 'PROPOSITION', 'CONCEPT', 'THING', etc., as indicated by
its native object type, it does not have anything to do with type propositions asserted about `self'.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION GET-LOGIC-TYPE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-STELLA-TYPE-NAME"
    "(DEFUN (GET-STELLA-TYPE-NAME STRING) ((SELF OBJECT)) :DOCUMENTATION \"Return the qualified name of the STELLA class of which `self' is a direct instance.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION GET-STELLA-TYPE-NAME) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-STELLA-TYPE-SHORT-NAME"
    "(DEFUN (GET-STELLA-TYPE-SHORT-NAME STRING) ((SELF OBJECT)) :DOCUMENTATION \"Return the unqualified name of the STELLA class of which `self' is a direct instance.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION GET-STELLA-TYPE-SHORT-NAME) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-LOGIC-TYPE-NAME"
    "(DEFUN (GET-LOGIC-TYPE-NAME STRING) ((SELF OBJECT)) :DOCUMENTATION \"Return the qualified name of the logic type of `self'.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION GET-LOGIC-TYPE-NAME) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-LOGIC-TYPE-SHORT-NAME"
    "(DEFUN (GET-LOGIC-TYPE-SHORT-NAME STRING) ((SELF OBJECT)) :DOCUMENTATION \"Return the unqualified name of the logic type of `self'.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION GET-LOGIC-TYPE-SHORT-NAME) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "STRING-TO-OBJECT"
    "(DEFUN (STRING-TO-OBJECT OBJECT) ((STRING STRING) (TYPE LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Evaluate `string' with respect to `module' and `environment'
and return the corresponding logical term.  `type' is a concept used to assist the
correct interpretation of `string'.

Currently `type' only has an effect on the interpretation of literal types.\")"
    (CL:FUNCTION STRING-TO-OBJECT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "STRING-TO-STELLA-EXPRESSION"
    "(DEFUN (STRING-TO-STELLA-EXPRESSION OBJECT) ((EXPRESSION STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :DOCUMENTATION \"Read the STELLA `expression' in `module' and return the result.
Raises a reader exception in case of incorrect STELLA syntax.\" :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION STRING-TO-STELLA-EXPRESSION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "HELP-GET-TRUE-EXTENSION-MEMBERS"
    "(DEFUN (HELP-GET-TRUE-EXTENSION-MEMBERS (CONS OF PROPOSITION)) ((RELATION NAMED-DESCRIPTION) (SPECIALIZE? BOOLEAN)) :PUBLIC? FALSE)"
    (CL:FUNCTION HELP-GET-TRUE-EXTENSION-MEMBERS) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "HELP-GET-PROPOSITIONS"
    "(DEFUN (HELP-GET-PROPOSITIONS (CONS OF PROPOSITION)) ((RELATION LOGIC-OBJECT) (ARGUMENTS CONS) (LIMIT INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? FALSE)"
    (CL:FUNCTION HELP-GET-PROPOSITIONS) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-PROPOSITION"
    "(DEFUN (GET-PROPOSITION PROPOSITION) ((RELATION-AND-ARGUMENTS OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return a proposition matching `relation-and-arguments' that
has been asserted (or inferred by forward chaining).  `relation-and-arguments'
is a sequence containing objects and nulls.  The first argument must be the
name of a relation.  A null value acts like a wild card.  If more than one 
proposition matches the input criteria, the selection among satisficing
propositions is arbitrary.  This procedure is normally applied to single-valued
relations or functions.\")" (CL:FUNCTION GET-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-PROPOSITION"
    "(DEFUN (S-GET-PROPOSITION PROPOSITION) ((RELATION-AND-ARGUMENTS STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return a proposition matching `relation-and-arguments' that
has been asserted (or inferred by forward chaining).  `relation-and-arguments'
is a string that begins with a left parenthesis, followed by a relation name, 
one or more argument identifiers, and terminated by a right parenthesis.  Each
argument identifier can be the name of a logical constant, a literal reference
such as a number, or the null identifier which acts like a wild card.
If more than one proposition matches the input criteria, the selection among
satisficing propositions is arbitrary.  This procedure is normally applied to
single-valued relations or functions.

A module name of `null' or the empty string refers to the current module.  If no module
with name `module-name' can be found, a STELLA `no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-GET-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-PROPOSITIONS"
    "(DEFUN (GET-PROPOSITIONS (PL-ITERATOR OF PROPOSITION)) ((RELATION-AND-ARGUMENTS OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return propositions matching `relation-and-arguments' that
have been asserted (or inferred by forward chaining).  `relation-and-arguments'
is a sequence containing objects and nulls.  The first argument must be the
name of a relation.  A null value acts like a wild card.\")"
    (CL:FUNCTION GET-PROPOSITIONS) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-PROPOSITIONS"
    "(DEFUN (S-GET-PROPOSITIONS (PL-ITERATOR OF PROPOSITION)) ((RELATION-AND-ARGUMENTS STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return propositions matching `relation-and-arguments' that
have been asserted (or inferred by forward chaining).  `relation-and-arguments'
is a string that begins with a left parenthesis, followed by a relation name, 
one or more argument identifiers, and terminated by a right parenthesis.  Each
argument identifier can be the name of a logical constant, a literal 
reference (e.g., a number), or the null identifier which acts like a wild card.

A module name of `null' or the empty string refers to the current module.  If no module
with name `module-name' can be found, a STELLA `no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-GET-PROPOSITIONS) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-INCONSISTENT-PROPOSITIONS"
    "(DEFUN (GET-INCONSISTENT-PROPOSITIONS (PL-ITERATOR OF PROPOSITION)) ((MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return inconsistent propositions visible in `module'.\")"
    (CL:FUNCTION GET-INCONSISTENT-PROPOSITIONS) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-UNARY-PROPOSITIONS"
    "(DEFUN (GET-UNARY-PROPOSITIONS (PL-ITERATOR OF PROPOSITION)) ((RELATION LOGIC-OBJECT) (ARG OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return propositions such that (`relation' `arg')
is true.  The `relation' argument must be bound to a relation.  `arg' may be
set to NULL, which is interpreted as a wildcard.\")"
    (CL:FUNCTION GET-UNARY-PROPOSITIONS) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-BINARY-PROPOSITION"
    "(DEFUN (GET-BINARY-PROPOSITION PROPOSITION) ((RELATION LOGIC-OBJECT) (ARG1 OBJECT) (ARG2 OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return a proposition such that (`relation' `arg1' `arg2')
is true.  The `relation' argument must be bound to a relation.  One or both
of the `arg1' and `arg2' arguments may be set to NULL, which is interpreted
as a wildcard. If more than one proposition matches the input criteria,
the selection is arbitrary.  This procedure is normally applied to single-valued
relations or functions.\")" (CL:FUNCTION GET-BINARY-PROPOSITION)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-BINARY-PROPOSITIONS"
    "(DEFUN (GET-BINARY-PROPOSITIONS (PL-ITERATOR OF PROPOSITION)) ((RELATION LOGIC-OBJECT) (ARG1 OBJECT) (ARG2 OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return propositions such that (`relation' `arg1' `arg2')
is true.  The `relation' argument must be bound to a relation.  One or both
of the `arg1' and `arg2' arguments may be set to NULL, which is interpreted
as a wildcard.\")" (CL:FUNCTION GET-BINARY-PROPOSITIONS) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT
    "GET-INFERRED-BINARY-PROPOSITION-VALUES"
    "(DEFUN (GET-INFERRED-BINARY-PROPOSITION-VALUES PL-ITERATOR) ((RELATION LOGIC-OBJECT) (ARG OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return all values `v' such that (`relation' `arg' `v')
has been asserted or can be inferred via a general PowerLoom `retrieve'.
Both `relation' and `arg' have to be non-NULL.\")"
    (CL:FUNCTION GET-INFERRED-BINARY-PROPOSITION-VALUES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT
    "S-GET-INFERRED-BINARY-PROPOSITION-VALUES"
    "(DEFUN (S-GET-INFERRED-BINARY-PROPOSITION-VALUES PL-ITERATOR) ((RELATION-NAME STRING) (ARG-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return all values `v' such that (`relation-name' `arg-name' `v')
has been asserted or can be inferred via a general PowerLoom `retrieve'.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a STELLA
`no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-GET-INFERRED-BINARY-PROPOSITION-VALUES)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-PROPOSITIONS-OF"
    "(DEFUN (GET-PROPOSITIONS-OF (PL-ITERATOR OF PROPOSITION)) ((OBJECT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return all propositions that have `object' among their arguments,
and that are TRUE in the scope of the module `module'.\")"
    (CL:FUNCTION GET-PROPOSITIONS-OF) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-PROPOSITIONS-OF"
    "(DEFUN (S-GET-PROPOSITIONS-OF (PL-ITERATOR OF PROPOSITION)) ((OBJECT-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return all propositions that have the object named `object-name' among
their arguments, and that are TRUE in the scope of the module `module-name'.
A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-GET-PROPOSITIONS-OF) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-PROPOSITIONS-IN-MODULE"
    "(DEFUN (GET-PROPOSITIONS-IN-MODULE (PL-ITERATOR OF PROPOSITION)) ((MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return propositions that have been locally conceived in
the module `module' (but are not necessarily true).\")"
    (CL:FUNCTION GET-PROPOSITIONS-IN-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-TRUE-UNARY-PROPOSITION"
    "(DEFUN (IS-TRUE-UNARY-PROPOSITION BOOLEAN) ((RELATION LOGIC-OBJECT) (ARG OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :DOCUMENTATION \"Return TRUE if the proposition (`relation' `arg') has
been asserted (or inferred by forward chaining).\" :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION IS-TRUE-UNARY-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-TRUE-BINARY-PROPOSITION"
    "(DEFUN (IS-TRUE-BINARY-PROPOSITION BOOLEAN) ((RELATION LOGIC-OBJECT) (ARG OBJECT) (VALUE OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :DOCUMENTATION \"Return TRUE if the proposition (`relation' `arg' `value') has
been asserted (or inferred by forward chaining).\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION IS-TRUE-BINARY-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-TRUE-NARY-PROPOSITION"
    "(DEFUN (IS-TRUE-NARY-PROPOSITION BOOLEAN) ((RELATION-AND-ARGUMENTS OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :DOCUMENTATION \"Return TRUE if a proposition (`relation' `args') has
been asserted (or inferred by forward chaining).\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION IS-TRUE-NARY-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-IS-TRUE-NARY-PROPOSITION"
    "(DEFUN (S-IS-TRUE-NARY-PROPOSITION BOOLEAN) ((RELATION-AND-ARGUMENTS STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :DOCUMENTATION \"Return TRUE if a proposition that prints as the string
`relation-and-arguments' is true in the module named `module-name'.
A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION S-IS-TRUE-NARY-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-TRUE-PROPOSITION"
    "(DEFUN (IS-TRUE-PROPOSITION BOOLEAN) ((PROPOSITION PROPOSITION) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :DOCUMENTATION \"Return TRUE if `proposition' is TRUE in the module `module'.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION IS-TRUE-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-SUBRELATION"
    "(DEFUN (IS-SUBRELATION BOOLEAN) ((SUB LOGIC-OBJECT) (SUPER LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return TRUE if `sub' is a subconcept/subrelation of `super'.\")"
    (CL:FUNCTION IS-SUBRELATION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-PROPER-SUBRELATIONS"
    "(DEFUN (GET-PROPER-SUBRELATIONS (PL-ITERATOR OF LOGIC-OBJECT)) ((RELATION LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return relations that specialize `relation'.
Non-reflexive.\")" (CL:FUNCTION GET-PROPER-SUBRELATIONS) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-DIRECT-SUBRELATIONS"
    "(DEFUN (GET-DIRECT-SUBRELATIONS (PL-ITERATOR OF LOGIC-OBJECT)) ((RELATION LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return relations that directly specialize `relation'.
Non-reflexive.\")" (CL:FUNCTION GET-DIRECT-SUBRELATIONS) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-PROPER-SUPERRELATIONS"
    "(DEFUN (GET-PROPER-SUPERRELATIONS (PL-ITERATOR OF LOGIC-OBJECT)) ((RELATION LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return relations that generalize `relation'.
Non-reflexive.\")" (CL:FUNCTION GET-PROPER-SUPERRELATIONS)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-DIRECT-SUPERRELATIONS"
    "(DEFUN (GET-DIRECT-SUPERRELATIONS (PL-ITERATOR OF LOGIC-OBJECT)) ((RELATION LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return relations that directly generalize `relation'.
Non-reflexive.\")" (CL:FUNCTION GET-DIRECT-SUPERRELATIONS)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-INSTANCE"
    "(DEFUN (IS-INSTANCE BOOLEAN) ((OBJECT OBJECT) (CONCEPT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :DOCUMENTATION \"Return TRUE if `object' is an instance of the concept `concept'.  This uses subsumption inference only.\" :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION IS-INSTANCE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-A"
    "(DEFUN (IS-A BOOLEAN) ((OBJECT OBJECT) (CONCEPT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :DOCUMENTATION \"Deprecated - use `is-instance' instead.\" :PUBLIC? TRUE)"
    (CL:FUNCTION IS-A) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-CONCEPT-INSTANCES"
    "(DEFUN (GET-CONCEPT-INSTANCES PL-ITERATOR) ((CONCEPT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return instances of the concept `concept'.
Include instances of subconcepts of `concept'.  Depending on `concept',
the return values could be (wrapped) literals.\")"
    (CL:FUNCTION GET-CONCEPT-INSTANCES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-CONCEPT-INSTANCES"
    "(DEFUN (S-GET-CONCEPT-INSTANCES PL-ITERATOR) ((CONCEPT-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return instances of concept `concept-name'.
Include instances of subconcepts of `concept-name'.  Depending on `concept-name',
the return values could be (wrapped) literals.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-GET-CONCEPT-INSTANCES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-DIRECT-CONCEPT-INSTANCES"
    "(DEFUN (GET-DIRECT-CONCEPT-INSTANCES PL-ITERATOR) ((CONCEPT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return instances of concept `concept'.
Exclude instances of subconcepts of `concept'.  Depending on `concept',
the return values could be (wrapped) literals.\")"
    (CL:FUNCTION GET-DIRECT-CONCEPT-INSTANCES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-DIRECT-CONCEPT-INSTANCES"
    "(DEFUN (S-GET-DIRECT-CONCEPT-INSTANCES PL-ITERATOR) ((CONCEPT-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return instances of concept `concept-name'.
Exclude instances of subconcepts of `concept-name'.  Depending on `concept-name',
the return values could be (wrapped) literals.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-GET-DIRECT-CONCEPT-INSTANCES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT
    "GET-CONCEPT-INSTANCES-MATCHING-VALUE"
    "(DEFUN (GET-CONCEPT-INSTANCES-MATCHING-VALUE PL-ITERATOR) ((CONCEPT LOGIC-OBJECT) (RELATION LOGIC-OBJECT) (VALUE OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return members of concept `concept' that
have an attribute matching `value' for the binary relation `relation', i.e.,
`(relation <result> value)' holds.\")"
    (CL:FUNCTION GET-CONCEPT-INSTANCES-MATCHING-VALUE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT
    "GET-CONCEPT-INSTANCE-MATCHING-VALUE"
    "(DEFUN (GET-CONCEPT-INSTANCE-MATCHING-VALUE OBJECT) ((CONCEPT LOGIC-OBJECT) (RELATION LOGIC-OBJECT) (VALUE OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return a member of concept `concept' that
has an attribute matching `value' for the binary relation `relation', i.e.,
`(relation <result> value)' holds.\")"
    (CL:FUNCTION GET-CONCEPT-INSTANCE-MATCHING-VALUE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "HELP-GET-TYPES"
    "(DEFUN (HELP-GET-TYPES (CONS OF LOGIC-OBJECT)) ((OBJECT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? FALSE)"
    (CL:FUNCTION HELP-GET-TYPES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-TYPES"
    "(DEFUN (GET-TYPES (PL-ITERATOR OF LOGIC-OBJECT)) ((OBJECT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return all named concepts that `object' belongs to.\")"
    (CL:FUNCTION GET-TYPES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-DIRECT-TYPES"
    "(DEFUN (GET-DIRECT-TYPES (PL-ITERATOR OF LOGIC-OBJECT)) ((OBJECT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return most specific concepts that `object' belongs to.\")"
    (CL:FUNCTION GET-DIRECT-TYPES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-RELATION-EXTENSION"
    "(DEFUN (GET-RELATION-EXTENSION (PL-ITERATOR OF PROPOSITION)) ((RELATION LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :DOCUMENTATION \"Return propositions that satisfy `relation'.
Include propositions that satisfy subrelations of `relation'.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION GET-RELATION-EXTENSION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-RELATION-EXTENSION"
    "(DEFUN (S-GET-RELATION-EXTENSION (PL-ITERATOR OF PROPOSITION)) ((RELATION-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return propositions that satisfy the relation named
`relation-name'.  Include propositions that satisfy subrelations of the relation.\")"
    (CL:FUNCTION S-GET-RELATION-EXTENSION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-MODULE"
    "(DEFUN (GET-MODULE MODULE) ((NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return a module named `name' or NULL if no such module exists.\")"
    (CL:FUNCTION GET-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-EXISTING-MODULE"
    "(DEFUN (GET-EXISTING-MODULE MODULE) ((NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return the module named `name' or raise a STELLA `no-such-context-exception' if it doesn't exist.\")"
    (CL:FUNCTION GET-EXISTING-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-CURRENT-MODULE"
    "(DEFUN (GET-CURRENT-MODULE MODULE) ((ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return the currently set module\")"
    (CL:FUNCTION GET-CURRENT-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-HOME-MODULE"
    "(DEFUN (GET-HOME-MODULE MODULE) ((OBJECT LOGIC-OBJECT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return the module in which `object' was created.\")"
    (CL:FUNCTION GET-HOME-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-MODULES"
    "(DEFUN (GET-MODULES (PL-ITERATOR OF MODULE)) ((KB-MODULES-ONLY? BOOLEAN)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return all modules currently loaded into PowerLoom.  If `kb-modules-only?'
is `true', then Stella modules that are used only for program code are
not included in the list.\")" (CL:FUNCTION GET-MODULES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-MODULE"
    "(DEFUN (CREATE-MODULE MODULE) ((NAME STRING) (PARENT MODULE) (CASE-SENSITIVE? BOOLEAN)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Creates a new module `name' as a child of `parent'.  The flag
`case-sensitive?' controls whether names read in this module will be
case sensitive or not.\")" (CL:FUNCTION CREATE-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-CREATE-MODULE"
    "(DEFUN (S-CREATE-MODULE MODULE) ((NAME STRING) (PARENT-NAME STRING) (CASE-SENSITIVE? BOOLEAN) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Creates a new module `name' as a child of `parent-name'.  The flag
`case-sensitive?' controls whether names read in this module will be
case sensitive or not.\")" (CL:FUNCTION S-CREATE-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CHANGE-MODULE"
    "(DEFUN (CHANGE-MODULE MODULE) ((MODULE MODULE)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Set the current module to `module' and return it.
If `module' is `null', then no switch is performed and the current
module is returned.\")" (CL:FUNCTION CHANGE-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-CHANGE-MODULE"
    "(DEFUN (S-CHANGE-MODULE MODULE) ((NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Set the current module to the module named `name'.
The return value is the module named `name' unless `name' is null or
the empty string.  In that case, the current module is returned.
If no module named `name' exists, a Stella `no-such-context-exception'
is thrown.\")" (CL:FUNCTION S-CHANGE-MODULE) STELLA::NULL)))

(CL:DEFUN HELP-STARTUP-PLI4 ()
  (CL:PROGN
   (STELLA::DEFINE-FUNCTION-OBJECT "CLEAR-MODULE"
    "(DEFUN (CLEAR-MODULE MODULE) ((MODULE MODULE)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Destroy the contents of the module `module' as well as
the contents of all of its children, recursively.\")"
    (CL:FUNCTION CLEAR-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-CLEAR-MODULE"
    "(DEFUN (S-CLEAR-MODULE MODULE) ((NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Destroy the contents of the module named `name', as
well as the contents of all of its children, recursively.  If no module
named `name' exists, a Stella `no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-CLEAR-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-CHILD-MODULES"
    "(DEFUN (GET-CHILD-MODULES (PL-ITERATOR OF MODULE)) ((MODULE MODULE)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return the modules that are immediate children of `module'.\")"
    (CL:FUNCTION GET-CHILD-MODULES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-CHILD-MODULES"
    "(DEFUN (S-GET-CHILD-MODULES (PL-ITERATOR OF MODULE)) ((NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return the modules that are immediate children of module `name'.
If no module named `name' exists, a Stella `no-such-context-exception'
is thrown.\")" (CL:FUNCTION S-GET-CHILD-MODULES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-PARENT-MODULES"
    "(DEFUN (GET-PARENT-MODULES (PL-ITERATOR OF MODULE)) ((MODULE MODULE)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return the modules that are immediate parents of `module'.\")"
    (CL:FUNCTION GET-PARENT-MODULES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-PARENT-MODULES"
    "(DEFUN (S-GET-PARENT-MODULES (PL-ITERATOR OF MODULE)) ((NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return the modules that are immediate parents of module `name'.
If no module named `name' exists, a Stella `no-such-context-exception'
is thrown.\")" (CL:FUNCTION S-GET-PARENT-MODULES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GENERATE-UNIQUE-NAME"
    "(DEFUN (GENERATE-UNIQUE-NAME STRING) ((PREFIX STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Generates a name based on `prefix' with a number appended that
is not currently in use in `module.'  In a non-case-sensitive module, the returned
name will be all upper case (This latter feature may change!)\")"
    (CL:FUNCTION GENERATE-UNIQUE-NAME) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-KEYWORD"
    "(DEFUN (CREATE-KEYWORD KEYWORD) ((NAME STRING)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Returns the Stella keyword `name', creating it if
necessary.  `name' is treated literally and case-sensitively.
This should generally not be necessary to do.\")"
    (CL:FUNCTION CREATE-KEYWORD) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-SYMBOL"
    "(DEFUN (CREATE-SYMBOL SYMBOL) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Returns the Stella symbol `name' visible in `module',
creating it if necessary.  `name' is treated literally and ALWAYS case-sensitively,
even if `module' is case insensitive. This should generally not be necessary to do.\")"
    (CL:FUNCTION CREATE-SYMBOL) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-OBJECT"
    "(DEFUN (CREATE-OBJECT LOGIC-OBJECT) ((NAME STRING) (CONCEPT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Create an object named `name' of type `concept' in the designated
module.  Both `name' and `concept' can be `null'.  If `name' is `null' then an
object will be created with a new, non-conflicting name based on the name of
`concept', or system-generated if no concept is specified.  If `concept' is
`null', then the object will be of type THING.  It is an error to create an
object with the same name as an existing object.

Note that the string can be a qualified name, in which case the object
will be created in the module specified, but with a name as determined
by the qualified name.  Vertical bars in the name string are interpreted
as Stella escape characters.

Note that because names in modules that are not case-sensitive are
canonicalized, the name of the returned object may not match `name'
exactly.

Return the object.\")" (CL:FUNCTION CREATE-OBJECT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-CREATE-OBJECT"
    "(DEFUN (S-CREATE-OBJECT LOGIC-OBJECT) ((NAME STRING) (CONCEPT-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Create an object named `name' of type `concept-name' in the designated
module.  Both `name' and `concept-name' can be null strings.  If `name' is a null string
then an object will be created with a new, non-conflicting name based on `concept-name', or
system-generated if no concept nameis specified.  If `concept-name' is the null string, then
the object will be of type THING.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly.

Return the object.\")" (CL:FUNCTION S-CREATE-OBJECT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-CONCEPT"
    "(DEFUN (CREATE-CONCEPT LOGIC-OBJECT) ((NAME STRING) (PARENT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Create a concept named `name' in the designated `module', with the
designated `parent' superconcept (which can be left undefined).  Additional
superconcepts can be added via assertions of the `subset-of' relation.  Note
that a specified `parent' concept needs to be created separately.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly.\")"
    (CL:FUNCTION CREATE-CONCEPT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-CREATE-CONCEPT"
    "(DEFUN (S-CREATE-CONCEPT LOGIC-OBJECT) ((NAME STRING) (PARENT-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Create a concept named `name' in the designated module, with
with the concept named `parent-name' as superconcept (which can be left
undefined).  Additional superconcepts can be added via assertions of the
`subset-of' relation.  Note that a specified parent concept needs to be
created separately.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly.\")"
    (CL:FUNCTION S-CREATE-CONCEPT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-RELATION"
    "(DEFUN (CREATE-RELATION LOGIC-OBJECT) ((NAME STRING) (ARITY INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Create a relation named `name' with arity `arity' in the
designated module.  Domain and range information can be added via assertions
of `nth-domain' (or `domain' and `range') relations.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly.\")"
    (CL:FUNCTION CREATE-RELATION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-CREATE-RELATION"
    "(DEFUN (S-CREATE-RELATION LOGIC-OBJECT) ((NAME STRING) (ARITY INTEGER) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Create a relation named `name' with arity `arity' in the
designated module.  Domain and range information can be added via assertions
of `nth-domain' (or `domain' and `range') relations.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly.\")"
    (CL:FUNCTION S-CREATE-RELATION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-FUNCTION"
    "(DEFUN (CREATE-FUNCTION LOGIC-OBJECT) ((NAME STRING) (ARITY INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Create a function named `name' with arity `arity'  in the designated 
`module'.  Domain and range information can be added via assertions of
`nth-domain' (or `domain' and `range') relations.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly.\")"
    (CL:FUNCTION CREATE-FUNCTION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-CREATE-FUNCTION"
    "(DEFUN (S-CREATE-FUNCTION LOGIC-OBJECT) ((NAME STRING) (ARITY INTEGER) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Create a function named `name' with arity `arity' in the designated 
module.  Domain and range information can be added via assertions of
`domain', `nth-domain' and `range' relations.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly.\")"
    (CL:FUNCTION S-CREATE-FUNCTION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "REGISTER-SPECIALIST-FUNCTION"
    "(DEFUN REGISTER-SPECIALIST-FUNCTION ((NAME STRING) (FUNCTION-REFERENCE FUNCTION-CODE) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Register `name' as a function name in `module' which will invoke the
native code procedure described by `function-reference.'  The `name'
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The function must conform
to the signature for specialist functions.

The exact form of `function-reference' depends on the underlying
programming language.  The following type mappings are used:
          C++:  
  Common Lisp:  FUNCTION   (result of #' or (FUNCTION ...))
         Java:  java.lang.reflect.Method\")"
    (CL:FUNCTION REGISTER-SPECIALIST-FUNCTION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-REGISTER-SPECIALIST-FUNCTION"
    "(DEFUN S-REGISTER-SPECIALIST-FUNCTION ((NAME STRING) (NATIVE-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Register `name' as a function name in the module named `module-name'.
This function will the native code named `native-name'.  The `name'
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The `native-name' will be
processed in a manner that depends on the underlying programming
language.  The following type mappings are used:
          C++:  Not available.  Error signaled.
  Common Lisp:  The native-name is read by READ-FROM-STRING and then
                the SYMBOL-FUNCTION is taken.
         Java:  A fully package-qualified name is required.  It is
                looked up using the Reflection tools.
The function found must conform to the signature for specialist functions.\")"
    (CL:FUNCTION S-REGISTER-SPECIALIST-FUNCTION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "REGISTER-COMPUTATION-FUNCTION"
    "(DEFUN REGISTER-COMPUTATION-FUNCTION ((NAME STRING) (FUNCTION-REFERENCE FUNCTION-CODE) (ARITY INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Register `name' as a function name in `module' which will invoke the
native code procedure described by `function-reference.'  The `name'
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The function must conform
to the signature for computation functions used by the computation
specialist.  Arity specifies the number of arguments the computation
accepts.

The exact form of `function-reference' depends on the underlying
programming language.  The following type mappings are used:
          C++:  cpp_function_code (a pointer to the function code)
  Common Lisp:  FUNCTION   (result of #' or (FUNCTION ...))
         Java:  java.lang.reflect.Method\")"
    (CL:FUNCTION REGISTER-COMPUTATION-FUNCTION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-REGISTER-COMPUTATION-FUNCTION"
    "(DEFUN S-REGISTER-COMPUTATION-FUNCTION ((NAME STRING) (NATIVE-NAME STRING) (ARITY INTEGER) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Register `name' as a function name in the module named `module-name'.
This function will the native code named `native-name'.  The `name'
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The `native-name' will be
processed in a manner that depends on the underlying programming
language.  The following type mappings are used:
          C++:  Not available.  Error signaled.
  Common Lisp:  The native-name is read by READ-FROM-STRING and then
                the SYMBOL-FUNCTION is taken.
         Java:  A fully package-qualified name is required.  It is
                looked up using the Reflection tools.
The function found must conform to the signature for computation functions.
Arity specifies the number of arguments the computation accepts.\")"
    (CL:FUNCTION S-REGISTER-COMPUTATION-FUNCTION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-ENUMERATED-LIST"
    "(DEFUN (CREATE-ENUMERATED-LIST LOGIC-OBJECT) ((MEMBERS CONS) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Create a logical term that denotes a list containing `members' in
`module' using `environment'.  Useful for passing lists as arguments
to parameterized queries.\")" (CL:FUNCTION CREATE-ENUMERATED-LIST)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-ENUMERATED-SET"
    "(DEFUN (CREATE-ENUMERATED-SET LOGIC-OBJECT) ((MEMBERS CONS) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Create a logical term that denotes the enumerated set containing `members'
in `module' using `environment'.\")"
    (CL:FUNCTION CREATE-ENUMERATED-SET) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "DESTROY-OBJECT"
    "(DEFUN DESTROY-OBJECT ((OBJECT OBJECT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Delete the object `object', retracting all facts attached to it.\")"
    (CL:FUNCTION DESTROY-OBJECT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-DESTROY-OBJECT"
    "(DEFUN S-DESTROY-OBJECT ((OBJECT-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Delete the object named `object-name', retracting all facts
attached to it.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-DESTROY-OBJECT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "ASSERT-UNARY-PROPOSITION"
    "(DEFUN (ASSERT-UNARY-PROPOSITION PROPOSITION) ((RELATION LOGIC-OBJECT) (ARG OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Assert that the proposition (`relation' `arg') is TRUE in `module'.  Return the asserted proposition.\")"
    (CL:FUNCTION ASSERT-UNARY-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "ASSERT-BINARY-PROPOSITION"
    "(DEFUN (ASSERT-BINARY-PROPOSITION PROPOSITION) ((RELATION LOGIC-OBJECT) (ARG OBJECT) (VALUE OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Assert that the proposition (`relation' `arg' `value') is TRUE
in `module'.  Return the asserted proposition.\")"
    (CL:FUNCTION ASSERT-BINARY-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "ASSERT-NARY-PROPOSITION"
    "(DEFUN (ASSERT-NARY-PROPOSITION PROPOSITION) ((RELATION-AND-ARGUMENTS OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Assert that the proposition represented by the list ` relation-and-arguments' satisfies
the relation `relation'.\")" (CL:FUNCTION ASSERT-NARY-PROPOSITION)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "RETRACT-UNARY-PROPOSITION"
    "(DEFUN (RETRACT-UNARY-PROPOSITION PROPOSITION) ((RELATION LOGIC-OBJECT) (ARG OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Retract that the proposition (`relation' `arg') is TRUE in `module'.  Return the asserted proposition.\")"
    (CL:FUNCTION RETRACT-UNARY-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "RETRACT-BINARY-PROPOSITION"
    "(DEFUN (RETRACT-BINARY-PROPOSITION PROPOSITION) ((RELATION LOGIC-OBJECT) (ARG OBJECT) (VALUE OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Retract that the proposition (`relation' `arg' `value') is TRUE
in `module'.  Return the asserted proposition.\")"
    (CL:FUNCTION RETRACT-BINARY-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "RETRACT-NARY-PROPOSITION"
    "(DEFUN (RETRACT-NARY-PROPOSITION PROPOSITION) ((RELATION-AND-ARGUMENTS OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Retract the proposition that `arguments' satisfies
the relation `relation'.\")" (CL:FUNCTION RETRACT-NARY-PROPOSITION)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "ASSERT-PROPOSITION"
    "(DEFUN (ASSERT-PROPOSITION PROPOSITION) ((PROPOSITION PROPOSITION) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Assert that the proposition `proposition' is true in `module'.
Return the asserted proposition.\")" (CL:FUNCTION ASSERT-PROPOSITION)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-ASSERT-PROPOSITION"
    "(DEFUN (S-ASSERT-PROPOSITION (PL-ITERATOR OF PROPOSITION)) ((SENTENCE STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Assert that the logical sentence `sentence' is true in the module
named `module-name'.  A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.

Return an iterator of the propositions resulting from sentence.\")"
    (CL:FUNCTION S-ASSERT-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "RETRACT-PROPOSITION"
    "(DEFUN (RETRACT-PROPOSITION PROPOSITION) ((PROPOSITION PROPOSITION) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Retract the truth of the proposition `proposition' in `module'.
Return the retracted proposition.\")" (CL:FUNCTION RETRACT-PROPOSITION)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-RETRACT-PROPOSITION"
    "(DEFUN (S-RETRACT-PROPOSITION (PL-ITERATOR OF PROPOSITION)) ((SENTENCE STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Retract the truth of the logical sentence `sentence' in the module named
`module-name'.  A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.

Return an iterator of the retracted propositions resulting from sentence.\")"
    (CL:FUNCTION S-RETRACT-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CONCEIVE"
    "(DEFUN (CONCEIVE (PL-ITERATOR OF PROPOSITION)) ((SENTENCE OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Create one or more proposition objects from the sentence `sentence'
in the  module `module'.  Return an iterator of the propositions.
If any of the new propositions has the same structure as an already existing
proposition, an automatic check for duplicates will return the pre-existing
proposition.  Multiple propositions may be returned for a single sentence
because of normalization of equivalences, conjunctions, etc.

Signals a `Proposition-Error' if PowerLoom could not conceive `sentence'.\")"
    (CL:FUNCTION CONCEIVE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-CONCEIVE"
    "(DEFUN (S-CONCEIVE (PL-ITERATOR OF PROPOSITION)) ((SENTENCE STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Create one or more proposition objects from the sentence `sentence'
in the  module named `module-name'.  Return an iterator of the propositions.
If any of the new propositions has the same structure as an already existing
proposition, an automatic check for duplicates will return the pre-existing
proposition.  Multiple propositions may be returned for a single sentence
because of normalization of equivalences, conjunctions, etc.

A module name of `null' or the empty string refers to the current module.
If no module can be found with the name `module-name', then a Stella
`No-Such-Context-Exception' is thrown.

Signals a `Proposition-Error' if PowerLoom could not conceive `sentence'.\")"
    (CL:FUNCTION S-CONCEIVE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-RULES"
    "(DEFUN (GET-RULES (PL-ITERATOR OF PROPOSITION)) ((RELATION LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return rules attached to the concept/relation `relation'
in either antecedent or consequent position.\")"
    (CL:FUNCTION GET-RULES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-RULES"
    "(DEFUN (S-GET-RULES (PL-ITERATOR OF PROPOSITION)) ((RELATION-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return rules attached to the concept/relation named
`relation-name' found in the module named `module-name'.
A module name of `null' or the empty string refers to the current module.
If no module can be found with the name `module-name', then a Stella
`No-Such-Context-Exception' is thrown.\")" (CL:FUNCTION S-GET-RULES)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-PRINT-RULES"
    "(DEFUN S-PRINT-RULES ((NAME STRING) (STREAM OUTPUT-STREAM) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :DOCUMENTATION \"Print rules attached to the concept/relation named `name'.
A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.\" :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION S-PRINT-RULES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "RUN-FORWARD-RULES"
    "(DEFUN RUN-FORWARD-RULES ((MODULE OBJECT) (LOCAL? BOOLEAN) (FORCE? BOOLEAN)) :DOCUMENTATION \"Run forward inference rules in module `module' which defaults
to the current module.  See `run-forward-rules' command for more information.\" :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION RUN-FORWARD-RULES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-ARITY"
    "(DEFUN (GET-ARITY INTEGER) ((RELATION LOGIC-OBJECT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return the arity of the relation `relation'.\")"
    (CL:FUNCTION GET-ARITY) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-ARITY"
    "(DEFUN (S-GET-ARITY INTEGER) ((RELATION-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return the arity of the relation named `relation-name'.

 A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-GET-ARITY) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-DOMAIN"
    "(DEFUN (GET-DOMAIN LOGIC-OBJECT) ((RELATION LOGIC-OBJECT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return the type (a concept) for the first argument to the binary
relation `relation'.\")" (CL:FUNCTION GET-DOMAIN) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-DOMAIN"
    "(DEFUN (S-GET-DOMAIN LOGIC-OBJECT) ((RELATION-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return the type (concept) for the first argument to the binary
relation `relation-name'.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-GET-DOMAIN) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-RANGE"
    "(DEFUN (GET-RANGE LOGIC-OBJECT) ((RELATION LOGIC-OBJECT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return the type (a concept) for fillers of the binary relation
`relation'.\")" (CL:FUNCTION GET-RANGE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-RANGE"
    "(DEFUN (S-GET-RANGE LOGIC-OBJECT) ((RELATION-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return the type (a concept) for fillers of the binary relation
`relation-name'.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-GET-RANGE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-NTH-DOMAIN"
    "(DEFUN (GET-NTH-DOMAIN LOGIC-OBJECT) ((RELATION LOGIC-OBJECT) (N INTEGER)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return the type (a concept) for the the nth argument of the
relation `relation'.  Counting starts at zero.  NOTE: if there are multiple
`nth-domain' propositions for `relation', this arbitrarily returns one of them;
it does not look for the most specific one (which might have to be created).\")"
    (CL:FUNCTION GET-NTH-DOMAIN) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-NTH-DOMAIN"
    "(DEFUN (S-GET-NTH-DOMAIN LOGIC-OBJECT) ((RELATION-NAME STRING) (N INTEGER) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return the type (a concept) for the nth argument of the relation
named `relation-name'.  Counting starts at zero.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-GET-NTH-DOMAIN) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "LOAD"
    "(DEFUN LOAD ((FILENAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Read logic commands from the file named `filename' and evaluate them.
See `load' command help for more information.\")" (CL:FUNCTION LOAD)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "LOAD-IN-MODULE"
    "(DEFUN LOAD-IN-MODULE ((FILENAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Read logic commands from the file named `filename' and evaluate them.
Binds the `load' command's :module option to `module'.  See `load' command help for more information.\")"
    (CL:FUNCTION LOAD-IN-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "LOAD-STREAM"
    "(DEFUN LOAD-STREAM ((STREAM INPUT-STREAM) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Read logic commands from the STELLA stream `stream' and evaluate them.
See `load' command help for more information.\")"
    (CL:FUNCTION LOAD-STREAM) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "LOAD-STREAM-IN-MODULE"
    "(DEFUN LOAD-STREAM-IN-MODULE ((STREAM INPUT-STREAM) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Read logic commands from the STELLA stream `stream' and evaluate them.
Binds the `load' command's :module option to `module'.  See `load' command help for more information.\")"
    (CL:FUNCTION LOAD-STREAM-IN-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "LOAD-NATIVE-STREAM"
    "(DEFUN LOAD-NATIVE-STREAM ((STREAM NATIVE-INPUT-STREAM) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Read logic commands from the native input stream `stream' and evaluate them.
Assumes `stream' is a line-buffered stream which is a safe compromise but does
not generate the best efficiency for block-buffered streams such as files.
See `load' command help for more information.\")"
    (CL:FUNCTION LOAD-NATIVE-STREAM) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "LOAD-NATIVE-STREAM-IN-MODULE"
    "(DEFUN LOAD-NATIVE-STREAM-IN-MODULE ((STREAM NATIVE-INPUT-STREAM) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Read logic commands from the native input stream `stream' and evaluate them.
Assumes `stream' is a line-buffered stream which is a safe compromise but does
not generate the best efficiency for block-buffered streams such as files.
Binds the `load' command's :module option to `module'.  See `load' command help for more information.\")"
    (CL:FUNCTION LOAD-NATIVE-STREAM-IN-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "SAVE-MODULE"
    "(DEFUN SAVE-MODULE ((MODULE MODULE) (FILENAME STRING) (IFEXISTS STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Save the contents of the module `mod' into a file named `filename'.
If a file named `filename' already exists, then the action taken depends on the
value of `ifexists'.  Possible values are \\\"ASK\\\", \\\"REPLACE\\\", \\\"WARN\\\" and \\\"ERROR\\\":

  REPLACE => Means overwrite without warning.
  WARN    => Means overwrite with a warning.
  ERROR   => Means don't overwrite, signal an error instead.
  ASK     => Ask the user whether to overwrite or not.  If not overwritten, an 
             exception is thrown.\")" (CL:FUNCTION SAVE-MODULE)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-SAVE-MODULE"
    "(DEFUN S-SAVE-MODULE ((MODULE-NAME STRING) (FILENAME STRING) (IFEXISTS STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Save the contents of the module `module-name' into a file named `filename'.
If a file named `filename' already exists, then the action taken depends on the
value of `ifexists'.  Possible values are \\\"ASK\\\", \\\"REPLACE\\\", \\\"WARN\\\" and \\\"ERROR\\\":

  REPLACE => Means overwrite without warning.
  WARN    => Means overwrite with a warning.
  ERROR   => Means don't overwrite, signal an error instead.
  ASK     => Ask the user whether to overwrite or not.  If not overwritten, an
             exception is thrown.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-SAVE-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-PREDICATE"
    "(DEFUN (GET-PREDICATE LOGIC-OBJECT) ((PROP PROPOSITION)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return the concept or relation predicate for
the proposition `prop'.\")" (CL:FUNCTION GET-PREDICATE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-COLUMN-COUNT"
    "(DEFUN (GET-COLUMN-COUNT INTEGER) ((OBJ OBJECT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Return the number of columns in `obj', which must
be of type proposition, skolem, cons, vector or PL-iterator.  For a proposition,
the number includes both the predicate and arguments. For the PL-iterator
case,the number of columns is for the current value of the iterator. For the
skolem case, if the skolem is a function term, the column count of its defining
proposition will be returned, otherwise it is treated as a non-sequence object.

For a null item, the column count is zero.
For non sequence objects, the column count is one.\")"
    (CL:FUNCTION GET-COLUMN-COUNT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-NTH-VALUE"
    "(DEFUN (GET-NTH-VALUE OBJECT) ((SEQUENCE OBJECT) (N INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return the value in the `nth' column of `sequence'.
Counting starts at zero.  Unless `n' is zero, `sequence' must be of type
proposition, skolem, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the number
of columns is for the current value of the iterator.   For the skolem case,
if the skolem is a function term, the nth value of its defining proposition
will be returned, otherwise it is treated as a non-sequence object.

As a special case, a column number of zero will also return `sequence' itself
if it is not one of the types enumerated above.  This is done to allow the
use of `get-nth-value' on PL-iterators with only a single return variable.\")"
    (CL:FUNCTION GET-NTH-VALUE) STELLA::NULL)))

(CL:DEFUN HELP-STARTUP-PLI5 ()
  (CL:PROGN
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-NTH-STRING"
    "(DEFUN (GET-NTH-STRING STRING) ((SEQUENCE OBJECT) (N INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return a string representation of the value in the `nth' column of
`sequence'. Counting starts at zero.   Unless `n' is zero, `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  This will always
succeed, even if the `nth' value is not a string object.  In that case, a
string reprensentation will be returned.

As a special case, a column number of zero will also return `sequence' itself
as a string if it is not one of the types enumerated above.  This is done to 
allow the use of `get-nth-string' on PL-iterators with only a single return variable.\")"
    (CL:FUNCTION GET-NTH-STRING) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-NTH-INTEGER"
    "(DEFUN (GET-NTH-INTEGER INTEGER) ((SEQUENCE OBJECT) (N INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return an integer representation of the value in the `nth' column of
`sequence'. Counting starts at zero.   Unless `n' is zero, `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  If this is not
an integer value, then an exception will be thrown.

As a special case, a column number of zero will also return the integer
value of `sequence' itself if it is not one of the types enumerated
above.   This allows the use of `get-nth-integer' on PL-iterators with
only a single return variable.  If  `sequence' cannot be turned into an
integer, an exception will be thrown.\")" (CL:FUNCTION GET-NTH-INTEGER)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-NTH-FLOAT"
    "(DEFUN (GET-NTH-FLOAT FLOAT) ((SEQUENCE OBJECT) (N INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return the floating point value in the `nth' column of
`sequence'. Counting starts at zero.  `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  If this is not
a floating point value, then an exception will be thrown.

As a special case, a column number of zero will also return the floating
point value of `sequence' itself if it is not one of the types enumerated
above.  This allows the use of `get-nth-float' on PL-iterators with only
a single return variable.    If  `sequence' cannot be turned into a floating
point value, an exception will be thrown.\")"
    (CL:FUNCTION GET-NTH-FLOAT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-NTH-LOGIC-OBJECT"
    "(DEFUN (GET-NTH-LOGIC-OBJECT LOGIC-OBJECT) ((SEQUENCE OBJECT) (N INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Return a logic object representation of the value in the `nth' column
of `sequence'.  Counting starts at zero.   Unless `n' is zero, `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  A zero column number
returns the proposition's relational predicate.  If the return value is
not a LOGIC-OBJECT, an exception is thrown.

As a special case, a column number of zero will also return `sequence' itself
if it is not one of the types enumerated above.  This is done to allow the
use of `get-nth-value' on PL-iterators with only a single return variable.
If `sequence' is not a LOGIC-OBJECT, an exception is thrown.\")"
    (CL:FUNCTION GET-NTH-LOGIC-OBJECT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-ENUMERATED-COLLECTION-MEMBERS"
    "(DEFUN (GET-ENUMERATED-COLLECTION-MEMBERS CONS) ((COLLECTION OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Returns the members of an enumerated collection.  This works on all types
of collection, i.e., sets and lists\")"
    (CL:FUNCTION GET-ENUMERATED-COLLECTION-MEMBERS) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "EVALUATE"
    "(DEFUN (EVALUATE OBJECT) ((COMMAND OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Evaluate the command `command' within `module' and return
the result. Currently, only the evaluation of (possibly nested) commands and
global variables is supported.  Commands are simple to program in Common Lisp,
since they are built into the language, and relatively awkward in Java and C++.
Users of either of those languages are more likely to want to call `s-evaluate'.\")"
    (CL:FUNCTION EVALUATE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-EVALUATE"
    "(DEFUN (S-EVALUATE OBJECT) ((COMMAND STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Evaluate the command represented by the string `command' within `module' and
return the result.  Currently, only the evaluation of (possibly nested) commands and
global variables is supported.

 A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-EVALUATE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "POWERLOOM"
    "(DEFUN POWERLOOM ((MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :DOCUMENTATION \"Run the PowerLoom read/eval/print loop.\" :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION POWERLOOM) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-LOGIC-OBJECT"
    "(DEFUN (IS-LOGIC-OBJECT BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Test whether `obj' is of type LOGIC-OBJECT\")"
    (CL:FUNCTION IS-LOGIC-OBJECT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-SKOLEM"
    "(DEFUN (IS-SKOLEM BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Test whether `obj' is of type SKOLEM (which subsumes pattern variables).\")"
    (CL:FUNCTION IS-SKOLEM) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-VARIABLE"
    "(DEFUN (IS-VARIABLE BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Test whether `obj' is of type PATTERN-VARIABLE.\")"
    (CL:FUNCTION IS-VARIABLE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-INTEGER"
    "(DEFUN (IS-INTEGER BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Test whether `obj' is of type INTEGER\")"
    (CL:FUNCTION IS-INTEGER) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-FLOAT"
    "(DEFUN (IS-FLOAT BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Test whether `obj' is of type FLOAT (double)\")"
    (CL:FUNCTION IS-FLOAT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-NUMBER"
    "(DEFUN (IS-NUMBER BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Test whether `obj' is of type NUMBER.  This can
be either an integer or a floating point number.  One key characteristic
is that 'object-to-integer' and `object-to-float' will both work on it.\")"
    (CL:FUNCTION IS-NUMBER) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-STRING"
    "(DEFUN (IS-STRING BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Test whether `obj' is of type STRING\")"
    (CL:FUNCTION IS-STRING) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-ENUMERATED-COLLECTION"
    "(DEFUN (IS-ENUMERATED-COLLECTION BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Test whether `obj' is an enumerated collection.  This
subsumes both sets and lists.\")"
    (CL:FUNCTION IS-ENUMERATED-COLLECTION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-ENUMERATED-SET"
    "(DEFUN (IS-ENUMERATED-SET BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Test whether `obj' is an enumerated set.\")"
    (CL:FUNCTION IS-ENUMERATED-SET) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-ENUMERATED-LIST"
    "(DEFUN (IS-ENUMERATED-LIST BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Test whether `obj' is an enumerated list\")"
    (CL:FUNCTION IS-ENUMERATED-LIST) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-TRUE"
    "(DEFUN (IS-TRUE BOOLEAN) ((TV TRUTH-VALUE)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Tests whether `tv' is a true truth value.  It can be true
either absolutely or by default.\")" (CL:FUNCTION IS-TRUE)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-FALSE"
    "(DEFUN (IS-FALSE BOOLEAN) ((TV TRUTH-VALUE)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Tests whether `tv' is a false truth value.  It can be false
either absolutely or by default.\")" (CL:FUNCTION IS-FALSE)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-UNKNOWN"
    "(DEFUN (IS-UNKNOWN BOOLEAN) ((TV TRUTH-VALUE)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Tests whether `tv' is an unknown truth value.\")"
    (CL:FUNCTION IS-UNKNOWN) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-KNOWN"
    "(DEFUN (IS-KNOWN BOOLEAN) ((TV TRUTH-VALUE)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Tests whether `tv' is a known truth value (i.e., true or false).\")"
    (CL:FUNCTION IS-KNOWN) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-INCONSISTENT"
    "(DEFUN (IS-INCONSISTENT BOOLEAN) ((TV TRUTH-VALUE)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Tests whether `tv' is an inconsistent truth value.\")"
    (CL:FUNCTION IS-INCONSISTENT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-STRICT"
    "(DEFUN (IS-STRICT BOOLEAN) ((TV TRUTH-VALUE)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Tests whether `tv' is a strict (non-default) truth value.\")"
    (CL:FUNCTION IS-STRICT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-DEFAULT"
    "(DEFUN (IS-DEFAULT BOOLEAN) ((TV TRUTH-VALUE)) :PUBLIC? TRUE :C-CALLABLE? TRUE :DOCUMENTATION \"Tests whether `tv' is a default truth value.\")"
    (CL:FUNCTION IS-DEFAULT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "ASK"
    "(DEFUN (ASK TRUTH-VALUE) ((QUERY CONS) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :DOCUMENTATION \"Returns a truth value for `query' in `module' and `environment'.
`query' has the same syntax as the PowerLoom `ask' command (which see)
but with the `ask' operator omitted.  For example, here are some legal
`query' arguments:
	 
    ((happy Fred))
    ((happy Fred) :inference-level :assertion)
    ((happy Fred) :inference-level :assertion :timeout 1.0)
	
As a convenience, a `query' argument whose first element is a symbol is
interpreted as a sentence that is queried without any options.  For example:
	 
    (happy Fred)
	
is a legal `query' argument.  Note that for a sentence whose relation is a list
itself, e.g., `((FruitFn BananaTree) MyBanana)' this shortcut is not available,
that is, in that case an extra level of list nesting is always necessary.
The returned truth value represents the logical truth of the queried sentence
as determined by PowerLoom.  It can be be tested via the functions `is-true',
`is-false' and `is-unknown' (which see).\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION ASK) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-ASK"
    "(DEFUN (S-ASK TRUTH-VALUE) ((QUERY STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :DOCUMENTATION \"Returns a truth value for `query' in module `module-name' and `environment'.
`query' has the same syntax as the PowerLoom `ask' command (which see) but
with the `ask' operator omitted.  Different from the PLI `ask' function, `s-ask'
does not expect a top-level pair of parentheses.  For example, here are some legal
`query' arguments:
	 
    \\\"(happy Fred)\\\"
    \\\"(happy Fred) :inference-level :assertion\\\"
    \\\"(happy Fred) :inference-level :assertion :timeout 1.0\\\"
	
Names in `query' will be interpreted relative to module `module-name'.
A null `module-name' or the empty string refers to the current module.
If no module can be found with the name `module-name', then a STELLA
`no-such-context-exception' is thrown.
The returned truth value represents the logical truth of the queried sentence
as determined by PowerLoom.  It can be be tested via the functions `is-true',
`is-false' and `is-unknown' (which see).\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION S-ASK) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "RETRIEVE"
    "(DEFUN (RETRIEVE PL-ITERATOR) ((QUERY CONS) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :DOCUMENTATION \"Returns an iterator of variable bindings that when substituted for the
open variables in `query' satisfy the query proposition.  The query is
run in `module' and relative to `environment'.  `query' has the same syntax
as the PowerLoom `retrieve' command (which see) but with the `retrieve'
operator omitted.    For example, here are some legal `query' arguments:
	 
    ((happy ?x))
    (10 (happy ?x))
    (all (happy ?x))
    (all ?x (happy ?x))
    (10 (happy ?x) :inference-level :assertion)
    (10 (happy ?x) :inference-level :assertion :timeout 1.0)
	
If there is only a single output variable (as in all the examples above)
each element generated by the returned iterator will be a binding for
that variable - unless, the output variable was declared with a surrounding
pair of parentheses.  For example:
	 
    (all (?x) (happy ?x))
	
In that case, the generated elements will be one-element lists.  If there
are multiple output variables, each element generated by the returned
iterator will be a list of variable bindings that can be accessed using
the various `get-nth-...' functions.  The list of output variables does
not need to be declared in which case they are taken to be the open variables
in the query proposition in the order in which they were encountered.  If
order does matter or should be different from its default, it can be forced
by declaring the set of output variables.\" :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION RETRIEVE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-RETRIEVE"
    "(DEFUN (S-RETRIEVE PL-ITERATOR) ((QUERY STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE :DOCUMENTATION \"Returns an iterator of variable bindings that when substituted for the
open variables in `query' satisfy the query proposition.  The query is
run in `module' and relative to `environment'.  `query' has the same syntax
as the PowerLoom `retrieve' command (which see) but with the `retrieve'
operator omitted.  Different from the PLI `retrieve' function, `s-retrieve'
does not expect a top-level pair of parentheses.  For example, here are some
legal `query' arguments:
	 
    \\\"(happy ?x)\\\"
    \\\"10 (happy ?x)\\\"
    \\\"all (happy ?x)\\\"
    \\\"all ?x (happy ?x)\\\"
    \\\"10 (happy ?x) :inference-level :assertion\\\"
    \\\"10 (happy ?x) :inference-level :assertion :timeout 1.0\\\"
	
If there is only a single output variable (as in all the examples above)
each element generated by the returned iterator will be a binding for
that variable - unless, the output variable was declared with a surrounding
pair of parentheses.  For example:
	 
    \\\"all (?x) (happy ?x)\\\"
	
In that case, the generated elements will be one-element lists.  If there
are multiple output variables, each element generated by the returned
iterator will be a list of variable bindings that can be accessed using
the various `get-nth-...' functions.  The list of output variables does
not need to be declared in which case they are taken to be the open variables
in the query proposition in the order in which they were encountered.  If
order does matter or should be different from its default, it can be forced
by declaring the set of output variables.

Names in `query' will be interpreted relative to module `module-name'.
A null `module-name' or the empty string refers to the current module.
If no module can be found with the name `module-name', then a STELLA
`no-such-context-exception' is thrown.\" :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION S-RETRIEVE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-FRAME-PROPOSITION"
    "(DEFUN (GET-FRAME-PROPOSITION PROPOSITION) ((FRAME CONTROL-FRAME)) :DOCUMENTATION \"Return the proposition currently being inferred by this control `frame'.
This proposition will generally have bound and/or unbound pattern variables as its arguments.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION GET-FRAME-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-FRAME-ARITY"
    "(DEFUN (GET-FRAME-ARITY INTEGER) ((FRAME CONTROL-FRAME)) :DOCUMENTATION \"Return the arity of the proposition currently being inferred by `frame'.
This will be the actual number of arguments, even if the proposition is of variable arity.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION GET-FRAME-ARITY) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-FRAME-ITERATOR"
    "(DEFUN (GET-FRAME-ITERATOR PL-ITERATOR) ((FRAME CONTROL-FRAME)) :DOCUMENTATION \"Return the iterator generating successive bindings for the proposition
that is currently being inferred by `frame'.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION GET-FRAME-ITERATOR) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "SET-FRAME-ITERATOR"
    "(DEFUN SET-FRAME-ITERATOR ((FRAME CONTROL-FRAME) (ITERATOR PL-ITERATOR)) :DOCUMENTATION \"Set the iterator for generating successive bindings for the proposition
that is currently being inferred by `frame' to `iterator'.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION SET-FRAME-ITERATOR) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-NTH-FRAME-ARGUMENT"
    "(DEFUN (GET-NTH-FRAME-ARGUMENT OBJECT) ((FRAME CONTROL-FRAME) (N INTEGER)) :DOCUMENTATION \"Return the `n'-th argument of the proposition that is currently being inferred
by `frame'.  This will generally be a pattern variable that might be unbound or bound.\" :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION GET-NTH-FRAME-ARGUMENT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-NTH-FRAME-BINDING"
    "(DEFUN (GET-NTH-FRAME-BINDING OBJECT) ((FRAME CONTROL-FRAME) (N INTEGER)) :DOCUMENTATION \"Return the binding of the `n'-th argument of the proposition that is currently
being inferred by `frame'.  This will be NULL if the argument is unbound, otherwise, the object
bound to the variable.\" :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION GET-NTH-FRAME-BINDING) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "SET-NTH-FRAME-BINDING"
    "(DEFUN (SET-NTH-FRAME-BINDING BOOLEAN) ((FRAME CONTROL-FRAME) (N INTEGER) (VALUE OBJECT)) :DOCUMENTATION \"Set the binding of the `n'-th argument of the proposition that is currently
being inferred by `frame' to `value'.  If the binding was successful, that is if the argument
was unbound or is already bound to `binding', the function returns TRUE.  Otherwise, the
argument will keep its current binding and FALSE will be returned.\" :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION SET-NTH-FRAME-BINDING) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-FRAME-BINDING-PATTERN"
    "(DEFUN (IS-FRAME-BINDING-PATTERN BOOLEAN) ((FRAME CONTROL-FRAME) (PATTERN STRING)) :DOCUMENTATION \"Return TRUE if the arguments of `frame' are bound according to `pattern'.
Each character in pattern corresponds to an argument at the particular position and  must be
either `B' (for bound) or `_' for unbound.  The function returns TRUE if `frame' has at least
as many arguments as `pattern' has characters and their bindings match `pattern'.  If `frame'
has additional arguments, they will be ignored.  If `pattern' has more positions than `frame'
has arguments, the function returns FALSE.\" :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION IS-FRAME-BINDING-PATTERN) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-FRAME-BINDING-PATTERN"
    "(DEFUN (GET-FRAME-BINDING-PATTERN STRING) ((FRAME CONTROL-FRAME)) :DOCUMENTATION \"Return a string representation of the argument binding pattern of `frame'.
The syntax of the pattern is the same as used for `is-frame-binding-pattern' (which see).\" :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION GET-FRAME-BINDING-PATTERN) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-FRAME-BINDING-STATE"
    "(DEFUN (GET-FRAME-BINDING-STATE CONS) ((FRAME CONTROL-FRAME)) :DOCUMENTATION \"Return a frame variable binding stack state that can be used to unbind
all frame variables to the state they were in when the binding stack state was recorded.\" :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION GET-FRAME-BINDING-STATE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "SET-FRAME-BINDING-STATE"
    "(DEFUN SET-FRAME-BINDING-STATE ((FRAME CONTROL-FRAME) (STATE CONS)) :DOCUMENTATION \"Reset the frame variable binding stack state to `state'.  This will set
all frame variables to the state they were in when the binding stack state was recorded.\" :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION SET-FRAME-BINDING-STATE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-PROPERTY-OBJECT"
    "(DEFUN (GET-PROPERTY-OBJECT OBJECT) ((PROPERTY STRING) (DEFAULTVALUE OBJECT)) :DOCUMENTATION \"Return the value of the global STELLA configuration `property'
or `defaultValue' if it is undefined.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION GET-PROPERTY-OBJECT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-PROPERTY-STRING"
    "(DEFUN (GET-PROPERTY-STRING STRING) ((PROPERTY STRING) (DEFAULTVALUE STRING)) :DOCUMENTATION \"Return the value of the global STELLA configuration `property'
as a string or `defaultValue' if it is undefined.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION GET-PROPERTY-STRING) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-PROPERTY"
    "(DEFUN (GET-PROPERTY STRING) ((PROPERTY STRING) (DEFAULTVALUE STRING)) :DOCUMENTATION \"Synonym for `get-property-string' (which see).\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION GET-PROPERTY) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-PROPERTY-INTEGER"
    "(DEFUN (GET-PROPERTY-INTEGER INTEGER) ((PROPERTY STRING) (DEFAULTVALUE INTEGER)) :DOCUMENTATION \"Return the value of the global STELLA configuration `property'
as an integer or `defaultValue' if it is undefined.  Raises an error if the defined
value is not an integer.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION GET-PROPERTY-INTEGER) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-PROPERTY-FLOAT"
    "(DEFUN (GET-PROPERTY-FLOAT FLOAT) ((PROPERTY STRING) (DEFAULTVALUE FLOAT)) :DOCUMENTATION \"Return the value of the global STELLA configuration `property'
as a float or `defaultValue' if it is undefined.  Raises an error if the defined
value is not a float.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION GET-PROPERTY-FLOAT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-PROPERTY-BOOLEAN"
    "(DEFUN (GET-PROPERTY-BOOLEAN BOOLEAN) ((PROPERTY STRING) (DEFAULTVALUE BOOLEAN)) :DOCUMENTATION \"Return the value of the global STELLA configuration `property'
as a boolean or `defaultValue' if it is undefined.  Raises an error if the defined
value is not a boolean.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION GET-PROPERTY-BOOLEAN) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "SET-PROPERTY-OBJECT"
    "(DEFUN SET-PROPERTY-OBJECT ((PROPERTY STRING) (VALUE OBJECT)) :DOCUMENTATION \"Set the global STELLA configuration `property' to `value'.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION SET-PROPERTY-OBJECT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "SET-PROPERTY-STRING"
    "(DEFUN SET-PROPERTY-STRING ((PROPERTY STRING) (VALUE STRING)) :DOCUMENTATION \"Set the global STELLA configuration `property' to a string `value'.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION SET-PROPERTY-STRING) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "SET-PROPERTY"
    "(DEFUN SET-PROPERTY ((PROPERTY STRING) (VALUE STRING)) :DOCUMENTATION \"Synonym for `set-property-string' (which see).\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION SET-PROPERTY) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "SET-PROPERTY-INTEGER"
    "(DEFUN SET-PROPERTY-INTEGER ((PROPERTY STRING) (VALUE INTEGER)) :DOCUMENTATION \"Set the global STELLA configuration `property' to an integer `value'.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION SET-PROPERTY-INTEGER) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "SET-PROPERTY-FLOAT"
    "(DEFUN SET-PROPERTY-FLOAT ((PROPERTY STRING) (VALUE FLOAT)) :DOCUMENTATION \"Set the global STELLA configuration `property' to a float `value'.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION SET-PROPERTY-FLOAT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "SET-PROPERTY-BOOLEAN"
    "(DEFUN SET-PROPERTY-BOOLEAN ((PROPERTY STRING) (VALUE BOOLEAN)) :DOCUMENTATION \"Set the global STELLA configuration `property' to a boolean `value'.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION SET-PROPERTY-BOOLEAN) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-DEFINED-PROPERTY"
    "(DEFUN (IS-DEFINED-PROPERTY BOOLEAN) ((PROPERTY STRING)) :DOCUMENTATION \"Return TRUE if `property' has a defined value.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION IS-DEFINED-PROPERTY) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "PRINT-PROPERTIES"
    "(DEFUN PRINT-PROPERTIES () :DOCUMENTATION \"Print all currently defined STELLA configuration properties and values.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION PRINT-PROPERTIES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-EXCEPTION-HANDLER"
    "(DEFUN (GET-EXCEPTION-HANDLER FUNCTION-CODE) () :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION GET-EXCEPTION-HANDLER) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "SET-EXCEPTION-HANDLER"
    "(DEFUN SET-EXCEPTION-HANDLER ((HANDLER FUNCTION-CODE)) :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION SET-EXCEPTION-HANDLER) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "REGISTER-OBJECT"
    "(DEFUN (REGISTER-OBJECT CONS) ((OBJECT OBJECT)) :DOCUMENTATION \"Register `object' to prevent it from being garbage-collected by the PowerLoom GC.
The result of registration is a handle for `object' which can later be used to unregister it.
Currently it is assumed that calling this immediately after an object was returned by a PLI function
is safe; however, we might have to handle registration in PLI functions before objects are returned.
This is not thread safe and needs to be explicitly synchronized in a threaded environment.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION REGISTER-OBJECT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "UNREGISTER-OBJECT"
    "(DEFUN UNREGISTER-OBJECT ((OBJECTHANDLE CONS)) :DOCUMENTATION \"Unregister the object whose registered handle is `objectHandle' to make it available
for PowerLoom garbage collection.  This also is not thread safe and needs to be explicitly synchronized
in a threaded environment.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION UNREGISTER-OBJECT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "MAIN"
    "(DEFUN MAIN () :PUBLIC? TRUE)" (CL:FUNCTION MAIN) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "STARTUP-PLI"
    "(DEFUN STARTUP-PLI () :PUBLIC? TRUE)" (CL:FUNCTION STARTUP-PLI)
    STELLA::NULL)
   (CL:LET*
    ((FUNCTION (STELLA::LOOKUP-FUNCTION SYM-PLI-PLI-STARTUP-PLI)))
    (STELLA::SET-DYNAMIC-SLOT-VALUE
     (STELLA::%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
     SYM-PLI-STELLA-METHOD-STARTUP-CLASSNAME
     (STELLA::WRAP-STRING "_StartupPli") STELLA::NULL-STRING-WRAPPER))))

(CL:DEFUN STARTUP-PLI ()
  (CL:LET*
   ((STELLA::*MODULE*
     (STELLA::GET-STELLA-MODULE "/PLI"
      (STELLA::> STELLA::*STARTUP-TIME-PHASE* 1)))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:WHEN (STELLA::CURRENT-STARTUP-TIME-PHASE? 2)
    (HELP-STARTUP-PLI1))
   (CL:WHEN (STELLA::CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:LET* ((SELF-062 (NEW-ENVIRONMENT)))
     (CL:SETF (%ENVIRONMENT.LEVEL SELF-062) "ASSERTION")
     (CL:SETQ ASSERTION-ENV SELF-062))
    (CL:LET* ((SELF-063 (NEW-ENVIRONMENT)))
     (CL:SETF (%ENVIRONMENT.LEVEL SELF-063) "TAXONOMIC")
     (CL:SETQ TAXONOMIC-ENV SELF-063))
    (CL:LET* ((SELF-064 (NEW-ENVIRONMENT)))
     (CL:SETF (%ENVIRONMENT.LEVEL SELF-064) "INFERENCE")
     (CL:SETQ INFERENCE-ENV SELF-064))
    (CL:LET* ((SELF-065 (NEW-PL-ITERATOR)))
     (CL:SETF (%PL-ITERATOR.CURSOR SELF-065) STELLA::NIL)
     (CL:SETQ EMPTY-PL-ITERATOR SELF-065))
    (CL:SETQ *OBJECT-REGISTRY* (NEW-OBJECT-REGISTRY-LIST)))
   (CL:WHEN (STELLA::CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (STELLA::DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "ENVIRONMENT"
        "(DEFCLASS ENVIRONMENT (STANDARD-OBJECT) :PUBLIC? TRUE :SLOTS ((LEVEL :TYPE STRING)) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"|ENV|\" (LEVEL SELF)))")))
     (CL:SETF (STELLA::%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-ENVIRONMENT))
     (CL:SETF (STELLA::%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-ENVIRONMENT-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (STELLA::DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PL-ITERATOR"
        "(DEFCLASS PL-ITERATOR (ITERATOR) :PUBLIC? TRUE :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((CURSOR :TYPE CONS)))")))
     (CL:SETF (STELLA::%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-PL-ITERATOR))
     (CL:SETF (STELLA::%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-PL-ITERATOR-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (STELLA::DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "OBJECT-REGISTRY-LIST"
        "(DEFCLASS OBJECT-REGISTRY-LIST (LIST) :SLOTS ((REGISTRY-LENGTH :TYPE INTEGER :INITIALLY 0) (N-FREE-CELLS :TYPE INTEGER :INITIALLY 0)))")))
     (CL:SETF (STELLA::%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-OBJECT-REGISTRY-LIST))
     (CL:SETF (STELLA::%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-OBJECT-REGISTRY-LIST-SLOT-VALUE))))
   (CL:WHEN (STELLA::CURRENT-STARTUP-TIME-PHASE? 6)
    (STELLA::FINALIZE-CLASSES))
   (CL:WHEN (STELLA::CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-PLI2)
    (HELP-STARTUP-PLI3) (HELP-STARTUP-PLI4) (HELP-STARTUP-PLI5))
   (CL:WHEN (STELLA::CURRENT-STARTUP-TIME-PHASE? 8)
    (STELLA::FINALIZE-SLOTS) (STELLA::CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (STELLA::CURRENT-STARTUP-TIME-PHASE? 9)
    (STELLA::%IN-MODULE
     (STELLA::COPY-CONS-TREE (STELLA::WRAP-STRING "PLI")))
    (STELLA::DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *POWERLOOM-INITIALIZED?* BOOLEAN FALSE)" STELLA::NULL)
    (CL:SETQ *POWERLOOM-INITIALIZED?* CL:T)
    (STELLA::DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFCONSTANT ASSERTION-ENV ENVIRONMENT (NEW ENVIRONMENT :LEVEL \"ASSERTION\") :PUBLIC? TRUE)"
     STELLA::NULL)
    (STELLA::DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFCONSTANT TAXONOMIC-ENV ENVIRONMENT (NEW ENVIRONMENT :LEVEL \"TAXONOMIC\") :PUBLIC? TRUE)"
     STELLA::NULL)
    (STELLA::DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFCONSTANT INFERENCE-ENV ENVIRONMENT (NEW ENVIRONMENT :LEVEL \"INFERENCE\") :PUBLIC? TRUE)"
     STELLA::NULL)
    (STELLA::DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL EMPTY-PL-ITERATOR PL-ITERATOR (NEW PL-ITERATOR :CURSOR NIL) :PUBLIC? FALSE :DOCUMENTATION \"Iterator that generates no values.\")"
     STELLA::NULL)
    (STELLA::DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *LITERAL-CONCEPT* NAMED-DESCRIPTION NULL :PUBLIC? FALSE)"
     STELLA::NULL)
    (STELLA::DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *STRING-CONCEPT* NAMED-DESCRIPTION NULL :PUBLIC? FALSE)"
     STELLA::NULL)
    (STELLA::DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *INTEGER-CONCEPT* NAMED-DESCRIPTION NULL :PUBLIC? FALSE)"
     STELLA::NULL)
    (STELLA::DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *FLOAT-CONCEPT* NAMED-DESCRIPTION NULL :PUBLIC? FALSE)"
     STELLA::NULL)
    (CL:SETQ *LITERAL-CONCEPT*
     (S-GET-CONCEPT "LITERAL" "PL-USER" STELLA::NULL))
    (CL:SETQ *STRING-CONCEPT*
     (S-GET-CONCEPT "STRING" "PL-USER" STELLA::NULL))
    (CL:SETQ *INTEGER-CONCEPT*
     (S-GET-CONCEPT "INTEGER" "PL-USER" STELLA::NULL))
    (CL:SETQ *FLOAT-CONCEPT*
     (S-GET-CONCEPT "FLOAT" "PL-USER" STELLA::NULL))
    (STELLA::DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *OBJECT-REGISTRY* OBJECT-REGISTRY-LIST (NEW OBJECT-REGISTRY-LIST))"
     STELLA::NULL))))
