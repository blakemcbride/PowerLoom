;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; inference-caches.lisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2023      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-INFERENCE-CACHES-LOGIC-INFERENCE-CACHE-OF NULL)
(CL:DEFVAR SYM-INFERENCE-CACHES-LOGIC-MONOTONIC? NULL)
(CL:DEFVAR SGT-INFERENCE-CACHES-STELLA-WORLD NULL)
(CL:DEFVAR KWD-INFERENCE-CACHES-JUST-IN-TIME NULL)
(CL:DEFVAR SYM-INFERENCE-CACHES-LOGIC-JUST-IN-TIME-INFERENCE-CACHE NULL)
(CL:DEFVAR KWD-INFERENCE-CACHES-META NULL)
(CL:DEFVAR SYM-INFERENCE-CACHES-LOGIC-META-INFERENCE-CACHE NULL)
(CL:DEFVAR KWD-INFERENCE-CACHES-TMS NULL)
(CL:DEFVAR SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED-INFERENCE-CACHE NULL)
(CL:DEFVAR KWD-INFERENCE-CACHES-PREORDER NULL)
(CL:DEFVAR KWD-INFERENCE-CACHES-FUNCTION NULL)
(CL:DEFVAR SGT-INFERENCE-CACHES-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SGT-INFERENCE-CACHES-STELLA-LITERAL-WRAPPER NULL)
(CL:DEFVAR SGT-INFERENCE-CACHES-LOGIC-SKOLEM NULL)
(CL:DEFVAR SGT-INFERENCE-CACHES-PL-KERNEL-KB-HIDDEN-RELATION NULL)
(CL:DEFVAR KWD-INFERENCE-CACHES-RETRACT NULL)
(CL:DEFVAR SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED? NULL)
(CL:DEFVAR KWD-INFERENCE-CACHES-PERFORMANCE-CLUES NULL)
(CL:DEFVAR SYM-INFERENCE-CACHES-LOGIC-UP-TO-DATE-INFERENCES? NULL)
(CL:DEFVAR SYM-INFERENCE-CACHES-LOGIC-PROPAGATE-CONSTRAINTS NULL)
(CL:DEFVAR KWD-INFERENCE-CACHES-COMMON-LISP NULL)
(CL:DEFVAR SYM-INFERENCE-CACHES-LOGIC-REPROPAGATE-CONSTRAINTS NULL)
(CL:DEFVAR KWD-INFERENCE-CACHES-EXTENSIONAL-ASSERTION NULL)
(CL:DEFVAR SGT-INFERENCE-CACHES-LOGIC-LOGIC-OBJECT NULL)
(CL:DEFVAR KWD-INFERENCE-CACHES-MODULE NULL)
(CL:DEFVAR KWD-INFERENCE-CACHES-FORCE? NULL)
(CL:DEFVAR KWD-INFERENCE-CACHES-FORCE NULL)
(CL:DEFVAR SGT-INFERENCE-CACHES-STELLA-MODULE NULL)
(CL:DEFVAR KWD-INFERENCE-CACHES-LOCAL? NULL)
(CL:DEFVAR SGT-INFERENCE-CACHES-STELLA-BOOLEAN NULL)
(CL:DEFVAR KWD-INFERENCE-CACHES-DISABLE-JIT? NULL)
(CL:DEFVAR KWD-INFERENCE-CACHES-JUST-IN-TIME-INFERENCE NULL)
(CL:DEFVAR SYM-INFERENCE-CACHES-STELLA-RUN-FORWARD-RULES NULL)
(CL:DEFVAR SYM-INFERENCE-CACHES-LOGIC-STARTUP-INFERENCE-CACHES NULL)
(CL:DEFVAR SYM-INFERENCE-CACHES-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *REVERSEPOLARITY?*
  DEFAULT-TRUE-TRUTH-VALUE *DEFERINGDEFAULTFORWARDINFERENCES?*
  *CLASH-EXCEPTIONS* STANDARD-ERROR TRUE-WRAPPER *MODULE*
  *QUERYITERATOR* *TRACED-KEYWORDS* STANDARD-OUTPUT EOL
  *JUST-IN-TIME-FORWARD-INFERENCE?* *CONTEXT* NIL FALSE-WRAPPER))

;;; (DEFUN (WORLD-STATE? BOOLEAN) ...)

(CL:DEFUN WORLD-STATE? (SELF)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
     SGT-INFERENCE-CACHES-STELLA-WORLD)
    (CL:PROGN
     (CL:AND
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
        SYM-INFERENCE-CACHES-LOGIC-INFERENCE-CACHE-OF NULL)
       NULL)
      (CL:NOT
       (%WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
         SYM-INFERENCE-CACHES-LOGIC-MONOTONIC? FALSE-WRAPPER))))))
   (CL:T CL:T)))

;;; (DEFUN (GET-WORLD-STATE CONTEXT) ...)

(CL:DEFUN GET-WORLD-STATE (SELF)
  (CL:IF (WORLD-STATE? SELF) SELF (%BASE-MODULE SELF)))

;;; (DEFUN (LOOKUP-INFERENCE-CACHE WORLD) ...)

(CL:DEFUN LOOKUP-INFERENCE-CACHE (CONTEXT KIND)
  (CL:LET* ((CACHEWORLD NULL))
   (CL:COND
    ((CL:EQ KIND KWD-INFERENCE-CACHES-JUST-IN-TIME)
     (CL:SETQ CACHEWORLD
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTEXT)
       SYM-INFERENCE-CACHES-LOGIC-JUST-IN-TIME-INFERENCE-CACHE NULL)))
    ((CL:EQ KIND KWD-INFERENCE-CACHES-META)
     (CL:SETQ CACHEWORLD
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTEXT)
       SYM-INFERENCE-CACHES-LOGIC-META-INFERENCE-CACHE NULL)))
    ((CL:EQ KIND KWD-INFERENCE-CACHES-TMS)
     (CL:SETQ CACHEWORLD
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTEXT)
       SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED-INFERENCE-CACHE
       NULL)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" KIND
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   CACHEWORLD))

;;; (DEFUN INITIALIZE-INFERENCE-WORLD ...)

(CL:DEFUN INITIALIZE-INFERENCE-WORLD (WORLD))

;;; (DEFUN (CREATE-INFERENCE-CACHE WORLD) ...)

(CL:DEFUN CREATE-INFERENCE-CACHE (CONTEXT KIND)
  (CL:LET*
   ((WORLD
     (CREATE-WORLD
      (CL:IF
       (MEMBER?
        (GET-QUOTED-TREE "((:JUST-IN-TIME :TMS) \"/LOGIC\")" "/LOGIC")
        KIND)
       (GET-INFERENCE-CACHE CONTEXT KWD-INFERENCE-CACHES-META) CONTEXT)
      STELLA::NULL-STRING)))
   (CL:COND
    ((CL:EQ KIND KWD-INFERENCE-CACHES-JUST-IN-TIME)
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTEXT)
      SYM-INFERENCE-CACHES-LOGIC-JUST-IN-TIME-INFERENCE-CACHE WORLD
      NULL))
    ((CL:EQ KIND KWD-INFERENCE-CACHES-META)
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTEXT)
      SYM-INFERENCE-CACHES-LOGIC-META-INFERENCE-CACHE WORLD NULL))
    ((CL:EQ KIND KWD-INFERENCE-CACHES-TMS)
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTEXT)
      SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED-INFERENCE-CACHE WORLD
      NULL))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" KIND
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLD)
    SYM-INFERENCE-CACHES-LOGIC-INFERENCE-CACHE-OF CONTEXT NULL)
   (INITIALIZE-INFERENCE-WORLD WORLD) WORLD))

;;; (DEFUN (JUST-IN-TIME-INFERENCE-CACHE? BOOLEAN) ...)

(CL:DEFUN JUST-IN-TIME-INFERENCE-CACHE? (SELF)
  "Return true if `self' is the JIT cache of some world state."
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
     SGT-INFERENCE-CACHES-STELLA-WORLD)
    (CL:PROGN
     (CL:LET*
      ((WORLDSTATE
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
         SYM-INFERENCE-CACHES-LOGIC-INFERENCE-CACHE-OF NULL)))
      (CL:AND (CL:NOT (CL:EQ WORLDSTATE NULL))
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLDSTATE)
         SYM-INFERENCE-CACHES-LOGIC-JUST-IN-TIME-INFERENCE-CACHE NULL)
        SELF)))))
   (CL:T CL:NIL)))

;;; (DEFUN (META-INFERENCE-CACHE? BOOLEAN) ...)

(CL:DEFUN META-INFERENCE-CACHE? (SELF)
  "Return true if `self' is the meta-JIT cache of some world state."
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
     SGT-INFERENCE-CACHES-STELLA-WORLD)
    (CL:PROGN
     (CL:LET*
      ((WORLDSTATE
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
         SYM-INFERENCE-CACHES-LOGIC-INFERENCE-CACHE-OF NULL)))
      (CL:AND (CL:NOT (CL:EQ WORLDSTATE NULL))
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLDSTATE)
         SYM-INFERENCE-CACHES-LOGIC-META-INFERENCE-CACHE NULL)
        SELF)))))
   (CL:T CL:NIL)))

;;; (DEFUN (GET-INFERENCE-CACHE WORLD) ...)

(CL:DEFUN GET-INFERENCE-CACHE (CONTEXT KIND)
  (CL:WHEN (CL:NOT (WORLD-STATE? CONTEXT))
   (CL:RETURN-FROM GET-INFERENCE-CACHE CONTEXT))
  (CL:LET* ((WORLD (LOOKUP-INFERENCE-CACHE CONTEXT KIND)))
   (CL:WHEN (CL:NOT (CL:EQ WORLD NULL))
    (CL:RETURN-FROM GET-INFERENCE-CACHE WORLD))
   (PROCESS-CHECK-TYPES-AGENDA)
   (CL:SETQ WORLD (CREATE-INFERENCE-CACHE CONTEXT KIND))
   (CL:COND ((CL:EQ KIND KWD-INFERENCE-CACHES-JUST-IN-TIME))
    ((CL:OR (CL:EQ KIND KWD-INFERENCE-CACHES-META)
      (CL:EQ KIND KWD-INFERENCE-CACHES-TMS))
     (CL:LET*
      ((PARENTMODULE NULL)
       (ITER-000
        (%THE-CONS-LIST (%PARENT-MODULES (%BASE-MODULE CONTEXT)))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ PARENTMODULE (%%VALUE ITER-000))
       (INHERIT-CACHED-INFERENCES
        (LOOKUP-INFERENCE-CACHE PARENTMODULE KIND) WORLD)
       (CL:SETQ ITER-000 (%%REST ITER-000)))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" KIND
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   WORLD))

;;; (DEFUN DESTROY-INFERENCE-CACHE ...)

(CL:DEFUN DESTROY-INFERENCE-CACHE (CONTEXT KIND)
  (CL:LET* ((CACHE NULL))
   (CL:COND
    ((CL:EQ KIND KWD-INFERENCE-CACHES-JUST-IN-TIME)
     (CL:SETQ CACHE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTEXT)
       SYM-INFERENCE-CACHES-LOGIC-JUST-IN-TIME-INFERENCE-CACHE NULL))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTEXT)
      SYM-INFERENCE-CACHES-LOGIC-JUST-IN-TIME-INFERENCE-CACHE NULL
      NULL))
    ((CL:EQ KIND KWD-INFERENCE-CACHES-META)
     (CL:SETQ CACHE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTEXT)
       SYM-INFERENCE-CACHES-LOGIC-META-INFERENCE-CACHE NULL))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTEXT)
      SYM-INFERENCE-CACHES-LOGIC-META-INFERENCE-CACHE NULL NULL))
    ((CL:EQ KIND KWD-INFERENCE-CACHES-TMS)
     (CL:SETQ CACHE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTEXT)
       SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED-INFERENCE-CACHE
       NULL))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTEXT)
      SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED-INFERENCE-CACHE NULL
      NULL))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" KIND
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ CACHE NULL)) (CL:NOT (DELETED? CACHE)))
    (DESTROY-WORLD CACHE))))

;;; (DEFUN DESTROY-ALL-INFERENCE-CACHES ...)

(CL:DEFUN DESTROY-ALL-INFERENCE-CACHES (CONTEXT KIND)
  (DESTROY-INFERENCE-CACHE CONTEXT KIND)
  (CL:LET*
   ((CHILD NULL)
    (ITER-000
     (ALL-SUBCONTEXTS *CONTEXT* KWD-INFERENCE-CACHES-PREORDER)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ CHILD (%VALUE ITER-000))
    (CL:WHEN (WORLD-STATE? CHILD)
     (DESTROY-INFERENCE-CACHE CHILD KIND)))))

;;; (DEFUN UNLINK-INFERENCE-CACHE ...)

(CL:DEFUN UNLINK-INFERENCE-CACHE (SELF)
  (CL:WHEN
   (CL:NOT
    (CL:EQ
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-INFERENCE-CACHES-LOGIC-INFERENCE-CACHE-OF NULL)
     NULL))
   (CL:LET*
    ((WORLDSTATE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-INFERENCE-CACHES-LOGIC-INFERENCE-CACHE-OF NULL)))
    (CL:COND
     ((CL:EQ SELF
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLDSTATE)
        SYM-INFERENCE-CACHES-LOGIC-JUST-IN-TIME-INFERENCE-CACHE NULL))
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLDSTATE)
       SYM-INFERENCE-CACHES-LOGIC-JUST-IN-TIME-INFERENCE-CACHE NULL
       NULL))
     ((CL:EQ SELF
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLDSTATE)
        SYM-INFERENCE-CACHES-LOGIC-META-INFERENCE-CACHE NULL))
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLDSTATE)
       SYM-INFERENCE-CACHES-LOGIC-META-INFERENCE-CACHE NULL NULL))
     ((CL:EQ SELF
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLDSTATE)
        SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED-INFERENCE-CACHE
        NULL))
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLDSTATE)
       SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED-INFERENCE-CACHE NULL
       NULL)))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
     SYM-INFERENCE-CACHES-LOGIC-INFERENCE-CACHE-OF NULL NULL))))

;;; (DEFUN DESTROY-INFERENCE-CACHES ...)

(CL:DEFUN DESTROY-INFERENCE-CACHES (CONTEXT)
  (DESTROY-INFERENCE-CACHE CONTEXT KWD-INFERENCE-CACHES-JUST-IN-TIME)
  (DESTROY-INFERENCE-CACHE CONTEXT KWD-INFERENCE-CACHES-META)
  (DESTROY-INFERENCE-CACHE CONTEXT KWD-INFERENCE-CACHES-TMS))

;;; (DEFSPECIAL *INVISIBLEASSERTION?* ...)

(CL:DEFVAR *INVISIBLEASSERTION?* CL:NIL
  "Used to signal an assertion that doesn't
blow away inference caches.")

;;; (DEFUN (META-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN META-PROPOSITION? (PROPOSITION)
  "Return TRUE if 'proposition' is tied only to at least one meta object
and no other objects except literals or function terms that are itself meta objects."
  (CL:WHEN (CL:EQ PROPOSITION NULL)
   (CL:RETURN-FROM META-PROPOSITION? CL:NIL))
  (CL:LET*
   ((ARGUMENTS (%ARGUMENTS PROPOSITION)) (POINTSTOMETAOBJECT? CL:NIL))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARG)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-000
         SGT-INFERENCE-CACHES-LOGIC-DESCRIPTION)
        (CL:PROGN (CL:SETQ POINTSTOMETAOBJECT? CL:T)))
       ((SUBTYPE-OF? TEST-VALUE-000
         SGT-INFERENCE-CACHES-STELLA-LITERAL-WRAPPER)
        (CL:PROGN))
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-INFERENCE-CACHES-LOGIC-SKOLEM)
        (CL:PROGN
         (CL:COND
          ((CL:AND (CL:EQ ARG (LAST ARGUMENTS))
            (CL:EQ (%KIND PROPOSITION) KWD-INFERENCE-CACHES-FUNCTION)))
          ((CL:AND (CL:NOT (CL:EQ (%DEFINING-PROPOSITION ARG) NULL))
            (META-PROPOSITION? (%DEFINING-PROPOSITION ARG)))
           (CL:SETQ POINTSTOMETAOBJECT? CL:T))
          (CL:T (CL:RETURN-FROM META-PROPOSITION? CL:NIL)))))
       (CL:T (CL:RETURN-FROM META-PROPOSITION? CL:NIL))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   POINTSTOMETAOBJECT?))

;;; (DEFUN HANDLE-OUT-OF-DATE-INFERENCE-CACHE ...)

(CL:DEFUN HANDLE-OUT-OF-DATE-INFERENCE-CACHE (ASSERTORRETRACT PROPOSITION)
  (CL:WHEN (WORLD-STATE? *CONTEXT*)
   (CL:WHEN
    (CL:OR
     (CL:EQ
      (LOOKUP-INFERENCE-CACHE *CONTEXT* KWD-INFERENCE-CACHES-META)
      NULL)
     (CL:NOT (CL:EQ *QUERYITERATOR* NULL)) (DESCRIPTION-MODE?)
     *INVISIBLEASSERTION?*)
    (CL:RETURN-FROM HANDLE-OUT-OF-DATE-INFERENCE-CACHE))
   (CL:LET*
    ((DESCRIPTION
      (CL:IF (CL:NOT (CL:EQ PROPOSITION NULL))
       (GET-DESCRIPTION (%OPERATOR PROPOSITION)) NULL)))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ DESCRIPTION NULL))
      (TEST-PROPERTY? DESCRIPTION
       SGT-INFERENCE-CACHES-PL-KERNEL-KB-HIDDEN-RELATION))
     (CL:RETURN-FROM HANDLE-OUT-OF-DATE-INFERENCE-CACHE)))
   (CL:COND
    ((CL:AND (META-PROPOSITION? PROPOSITION)
      (CL:EQ ASSERTORRETRACT KWD-INFERENCE-CACHES-RETRACT)
      (CL:NOT
       (%WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE
         (%DYNAMIC-SLOTS
          (LOOKUP-INFERENCE-CACHE *CONTEXT* KWD-INFERENCE-CACHES-META))
         SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED? FALSE-WRAPPER))))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
       (MEMB? *TRACED-KEYWORDS*
        KWD-INFERENCE-CACHES-PERFORMANCE-CLUES))
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
       "DELETING META CACHE" EOL))
     (DESTROY-INFERENCE-CACHE *CONTEXT* KWD-INFERENCE-CACHES-META))
    (*JUST-IN-TIME-FORWARD-INFERENCE?*
     (CL:WHEN
      (CL:NOT
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS *CONTEXT*)
         SYM-INFERENCE-CACHES-LOGIC-JUST-IN-TIME-INFERENCE-CACHE NULL)
        NULL))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
        (MEMB? *TRACED-KEYWORDS*
         KWD-INFERENCE-CACHES-PERFORMANCE-CLUES))
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
        "DELETING JIT CACHE" EOL))
      (DESTROY-ALL-INFERENCE-CACHES *CONTEXT*
       KWD-INFERENCE-CACHES-JUST-IN-TIME)))
    (CL:T
     (CL:LET*
      ((CACHE
        (LOOKUP-INFERENCE-CACHE *CONTEXT* KWD-INFERENCE-CACHES-TMS)))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ CACHE NULL))
        (CL:NOT
         (%WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CACHE)
           SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED?
           FALSE-WRAPPER))))
       (DESTROY-INFERENCE-CACHE *CONTEXT* KWD-INFERENCE-CACHES-TMS)))))
   (CL:RETURN-FROM HANDLE-OUT-OF-DATE-INFERENCE-CACHE))
  (CL:LET* ((WORLD *CONTEXT*))
   (CL:WHEN
    (CL:AND
     (%WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLD)
       SYM-INFERENCE-CACHES-LOGIC-MONOTONIC? FALSE-WRAPPER))
     (CL:EQ ASSERTORRETRACT KWD-INFERENCE-CACHES-RETRACT))
    (CL:IF (CL:NOT (CL:EQ PROPOSITION NULL))
     (CL:WARN
      "Retraction of `~A' occurred in world `~A' which is marked monotonic."
      PROPOSITION WORLD)
     (CL:WARN
      "Retraction occurred in world `~A' which is marked monotonic."
      WORLD)))
   (CL:WHEN
    (CL:NOT
     (%WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLD)
       SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED? FALSE-WRAPPER)))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLD)
     SYM-INFERENCE-CACHES-LOGIC-UP-TO-DATE-INFERENCES? FALSE-WRAPPER
     FALSE-WRAPPER))))

;;; (DEFUN (BEST-INFERENCE-CACHE WORLD) ...)

(CL:DEFUN BEST-INFERENCE-CACHE (CONTEXT)
  (CL:WHEN *JUST-IN-TIME-FORWARD-INFERENCE?*
   (CL:RETURN-FROM BEST-INFERENCE-CACHE
    (GET-INFERENCE-CACHE CONTEXT KWD-INFERENCE-CACHES-JUST-IN-TIME)))
  (CL:LET*
   ((CACHE (LOOKUP-INFERENCE-CACHE CONTEXT KWD-INFERENCE-CACHES-TMS)))
   (CL:IF (CL:NOT (CL:EQ CACHE NULL)) CACHE
    (LOOKUP-INFERENCE-CACHE CONTEXT KWD-INFERENCE-CACHES-META))))

;;; (DEFUN (GET-QUERY-CONTEXT CONTEXT) ...)

(CL:DEFUN GET-QUERY-CONTEXT ()
  (CL:WHEN (CL:NOT (WORLD-STATE? *CONTEXT*))
   (CL:RETURN-FROM GET-QUERY-CONTEXT *CONTEXT*))
  (CL:LET* ((CACHE (BEST-INFERENCE-CACHE *CONTEXT*)))
   (CL:IF (CL:NOT (CL:EQ CACHE NULL)) CACHE *CONTEXT*)))

;;; (DEFUN (GET-PROPERTY-TEST-CONTEXT CONTEXT) ...)

(CL:DEFUN GET-PROPERTY-TEST-CONTEXT ()
  (CL:LET*
   ((CONSTRAINTPROPAGATIONWORLD
     (LOOKUP-CONSTRAINT-PROPAGATION-WORLD *CONTEXT*)))
   (CL:IF (CL:EQ CONSTRAINTPROPAGATIONWORLD NULL) *CONTEXT*
    CONSTRAINTPROPAGATIONWORLD)))

;;; (DEFUN (GET-INFERABLE-TEST-CONTEXT CONTEXT) ...)

(CL:DEFUN GET-INFERABLE-TEST-CONTEXT ()
  (CL:IF (CL:NOT (WORLD-STATE? *CONTEXT*)) *CONTEXT*
   (CL:LET*
    ((TEMP-000
      (LOOKUP-INFERENCE-CACHE *CONTEXT* KWD-INFERENCE-CACHES-META)))
    (CL:LET*
     ((VALUE-000
       (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL)) TEMP-000 *CONTEXT*)))
     VALUE-000))))

;;; (DEFUN (GET-TOP-LEVEL-UPDATE-CONTEXT CONTEXT) ...)

(CL:DEFUN GET-TOP-LEVEL-UPDATE-CONTEXT ()
  (GET-WORLD-STATE *CONTEXT*))

;;; (DEFUN (LOOKUP-CONSTRAINT-PROPAGATION-WORLD WORLD) ...)

(CL:DEFUN LOOKUP-CONSTRAINT-PROPAGATION-WORLD (SELF)
  (CL:IF (WORLD-STATE? SELF)
   (CL:IF *JUST-IN-TIME-FORWARD-INFERENCE?*
    (CL:IF (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
     (GET-INFERENCE-CACHE SELF KWD-INFERENCE-CACHES-JUST-IN-TIME)
     (LOOKUP-INFERENCE-CACHE SELF KWD-INFERENCE-CACHES-JUST-IN-TIME))
    (LOOKUP-INFERENCE-CACHE SELF KWD-INFERENCE-CACHES-TMS))
   SELF))

;;; (DEFUN INHERIT-CACHED-INFERENCES ...)

(CL:DEFUN INHERIT-CACHED-INFERENCES (FROMWORLD TOWORLD)
  (CL:SETQ TOWORLD TOWORLD)
  (CL:WHEN (CL:EQ FROMWORLD NULL) NULL))

;;; (DEFUN INHERIT-TRUTH-VALUE-UPDATE ...)

(CL:DEFUN INHERIT-TRUTH-VALUE-UPDATE (PROPOSITION TOWORLD))

;;; (DEFUN INHERIT-VARIABLE-VALUE-UPDATE ...)

(CL:DEFUN INHERIT-VARIABLE-VALUE-UPDATE (SKOLEM TOWORLD))

;;; (DEFUN CALL-PROPAGATE-CONSTRAINTS ...)

(CL:DEFUN CALL-PROPAGATE-CONSTRAINTS (CONTEXT)
  "OBSOLETE: use `call-run-forward-rules' instead."
  (CALL-RUN-FORWARD-RULES CONTEXT CL:T CL:NIL))

;;; (DEFUN PROPAGATE-CONSTRAINTS ...)

(CL:DEFUN %PROPAGATE-CONSTRAINTS (NAME)
  "OBSOLETE: use `run-forward-rules' instead."
  (CL:LET* ((OPTIONALNAME NAME) (MODULE NULL))
   (CL:WHEN (CL:NOT (CL:EQ (%%VALUE OPTIONALNAME) NULL))
    (CL:SETQ MODULE (COERCE-TO-MODULE (%%VALUE OPTIONALNAME) CL:T)))
   (CL:WHEN (CL:EQ MODULE NULL) (CL:SETQ MODULE *MODULE*))
   (CALL-RUN-FORWARD-RULES MODULE CL:T CL:NIL)))

(CL:DEFUN PROPAGATE-CONSTRAINTS-EVALUATOR-WRAPPER (ARGUMENTS)
  (%PROPAGATE-CONSTRAINTS ARGUMENTS))

(CL:DEFMACRO PROPAGATE-CONSTRAINTS (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "OBSOLETE: use `run-forward-rules' instead."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/PROPAGATE-CONSTRAINTS|)) (CL:MACRO-FUNCTION (CL:QUOTE PROPAGATE-CONSTRAINTS)))

;;; (DEFUN REPROPAGATE-CONSTRAINTS ...)

(CL:DEFUN %REPROPAGATE-CONSTRAINTS (NAME)
  "OBSOLETE: use `run-forward-rules' instead."
  (CL:LET*
   ((OPTIONALNAME NAME)
    (CONTEXT (COERCE-TO-MODULE (%%VALUE OPTIONALNAME) CL:T)))
   (CL:WHEN (CL:EQ CONTEXT NULL) (CL:SETQ CONTEXT *CONTEXT*))
   (CALL-RUN-FORWARD-RULES CONTEXT CL:T CL:T)))

(CL:DEFUN REPROPAGATE-CONSTRAINTS-EVALUATOR-WRAPPER (ARGUMENTS)
  (%REPROPAGATE-CONSTRAINTS ARGUMENTS))

(CL:DEFMACRO REPROPAGATE-CONSTRAINTS (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "OBSOLETE: use `run-forward-rules' instead."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/REPROPAGATE-CONSTRAINTS|)) (CL:MACRO-FUNCTION (CL:QUOTE REPROPAGATE-CONSTRAINTS)))

;;; (DEFUN CALL-RUN-FORWARD-RULES ...)

(CL:DEFUN CALL-RUN-FORWARD-RULES (CONTEXT LOCAL? FORCE?)
  "Callable implementation for `run-forward-rules' (which see)."
  (CL:WHEN (CL:EQ CONTEXT NULL) (CL:SETQ CONTEXT *CONTEXT*))
  (FINALIZE-OBJECTS)
  (PROCESS-CHECK-TYPES-AGENDA)
  (CL:LET*
   ((WORLDSTATE (GET-WORLD-STATE CONTEXT)) (PROPWORLD NULL)
    (PROPENV NULL))
   (CL:WHEN FORCE?
    (DESTROY-INFERENCE-CACHES (GET-WORLD-STATE CONTEXT)))
   (GET-INFERENCE-CACHE WORLDSTATE KWD-INFERENCE-CACHES-JUST-IN-TIME)
   (CL:SETQ PROPWORLD (BEST-INFERENCE-CACHE WORLDSTATE))
   (CL:SETQ PROPENV (GET-PROPAGATION-ENVIRONMENT PROPWORLD))
   (CL:LET*
    ((*EVALUATIONMODE* KWD-INFERENCE-CACHES-EXTENSIONAL-ASSERTION)
     (*INHIBITOBJECTFINALIZATION?* CL:T) (*QUERYITERATOR* NULL)
     (*CONTEXT* PROPWORLD))
    (CL:DECLARE
     (CL:SPECIAL *EVALUATIONMODE* *INHIBITOBJECTFINALIZATION?*
      *QUERYITERATOR* *CONTEXT*))
    (CL:WHEN
     (%WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPWORLD)
       SYM-INFERENCE-CACHES-LOGIC-UP-TO-DATE-INFERENCES?
       FALSE-WRAPPER))
     (CL:RETURN-FROM CALL-RUN-FORWARD-RULES))
    (CL:HANDLER-CASE
     (CL:LET*
      ((*FILLINGCONSTRAINTPROPAGATIONQUEUES?* CL:T)
       (*DEFERINGDEFAULTFORWARDINFERENCES?* CL:T))
      (CL:DECLARE
       (CL:SPECIAL *FILLINGCONSTRAINTPROPAGATIONQUEUES?*
        *DEFERINGDEFAULTFORWARDINFERENCES?*))
      (CL:LET*
       ((PROP NULL) (ITER-000 (ALL-PROPOSITIONS WORLDSTATE LOCAL?)))
       (CL:LOOP WHILE (NEXT? ITER-000) DO
        (CL:SETQ PROP (%VALUE ITER-000))
        (CL:WHEN
         (CL:AND (CL:NOT (DELETED? PROP))
          (CL:IF *REVERSEPOLARITY?* (FALSE? PROP)
           (CL:OR (TRUE? PROP) (FUNCTION-WITH-DEFINED-VALUE? PROP))))
         (REACT-TO-KB-UPDATE PROPWORLD PROP)
         (CL:LET*
          ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROP)) (INDEX-000 0)
           (LENGTH-000 (LENGTH VECTOR-000)))
          (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
          (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
           (CL:SETQ ARG
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
             INDEX-000))
           (CL:WHEN
            (CL:AND (ISA? ARG SGT-INFERENCE-CACHES-LOGIC-LOGIC-OBJECT)
             (CL:NOT (MEMBER? (%ELABORATED-OBJECTS PROPENV) ARG)))
            (INSERT (%ELABORATED-OBJECTS PROPENV) ARG))
           (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))))
      (EXECUTE-CONSTRAINT-PROPAGATION-QUEUES)
      (CL:LET*
       ((PROP NULL)
        (ITER-001
         (%THE-CONS-LIST (%DEFERRED-DEFAULT-PROPOSITIONS PROPENV))))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:SETQ PROP (%%VALUE ITER-001))
        (ASSIGN-TRUTH-VALUE PROP DEFAULT-TRUE-TRUTH-VALUE)
        (CL:LET*
         ((ARG NULL) (VECTOR-001 (%ARGUMENTS PROP)) (INDEX-001 0)
          (LENGTH-001 (LENGTH VECTOR-001)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
         (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
          (CL:SETQ ARG
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
            INDEX-001))
          (CL:WHEN
           (CL:AND (ISA? ARG SGT-INFERENCE-CACHES-LOGIC-LOGIC-OBJECT)
            (CL:NOT (MEMBER? (%ELABORATED-OBJECTS PROPENV) ARG)))
           (INSERT (%ELABORATED-OBJECTS PROPENV) ARG))
          (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
        (CL:SETQ ITER-001 (%%REST ITER-001))))
      (CLEAR (%DEFERRED-DEFAULT-PROPOSITIONS PROPENV))
      (CL:SETQ *DEFERINGDEFAULTFORWARDINFERENCES?* CL:NIL)
      (EXECUTE-CONSTRAINT-PROPAGATION-QUEUES))
     (CLASH (E)
      (CL:LET* ((SELF-000 (NEW-EXCEPTION-RECORD)))
       (CL:SETF (%EXCEPTION SELF-000) E)
       (CL:SETF (%CONTEXT SELF-000) *CONTEXT*)
       (CL:SETF (%MODULE SELF-000) *MODULE*)
       (PUSH *CLASH-EXCEPTIONS* SELF-000))
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR)
       (EXCEPTION-MESSAGE E))
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
       "   One or more facts need to be retracted to eliminate the inconsistency."
       EOL)))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPWORLD)
     SYM-INFERENCE-CACHES-LOGIC-UP-TO-DATE-INFERENCES? TRUE-WRAPPER
     FALSE-WRAPPER))))

;;; (DEFUN RUN-FORWARD-RULES ...)

(CL:DEFUN %RUN-FORWARD-RULES (OPTIONS)
  "Run forward inference rules in the module defined by the :module option (which
defaults to the current module).  If forward inferencing is already up-to-date
in the designated module, no additional inferencing will occur, unless the :force?
option is specified as TRUE, in which case all forward rules are run or rerun (for
backwards compatibility, this command also supports the old <module> :force arguments
specified with a non-standard keyword notation).  If :local? is TRUE (the default),
only propositions asserted locally in the module will be posted for forward inference,
otherwise, all true propositions visible in the module will be posted.

Calling `run-forward-rules' with :disable-jit? TRUE will disable future just-in-time
forward inference which will preserve cached forward inference in case of monotonic
assertions that do not clip (implicitly retract) any existing values.  Subsequent calls
can then trigger new inferences based on these updates only.  If the JIT stays enabled,
even monotonic updates will throw away the JIT cache.  Also, once any retractions have
been performed, all cached inferences will be thrown away and forward inference has to
be rerun from scratch or just-in-time forward inference needs to be enabled again."
  (CL:LET*
   ((OPTIONSLIST OPTIONS)
    (THEOPTIONS
     (PARSE-OPTIONS
      (CL:IF (KEYWORD? (%%VALUE OPTIONSLIST)) OPTIONSLIST
       (CONS-LIST KWD-INFERENCE-CACHES-MODULE (%%VALUE OPTIONSLIST)
        KWD-INFERENCE-CACHES-FORCE?
        (CL:IF
         (CL:EQ (%%VALUE (%%REST OPTIONSLIST))
          KWD-INFERENCE-CACHES-FORCE)
         TRUE-WRAPPER FALSE-WRAPPER)))
      (LIST* KWD-INFERENCE-CACHES-MODULE
       SGT-INFERENCE-CACHES-STELLA-MODULE KWD-INFERENCE-CACHES-LOCAL?
       SGT-INFERENCE-CACHES-STELLA-BOOLEAN KWD-INFERENCE-CACHES-FORCE?
       SGT-INFERENCE-CACHES-STELLA-BOOLEAN
       KWD-INFERENCE-CACHES-DISABLE-JIT?
       SGT-INFERENCE-CACHES-STELLA-BOOLEAN NIL)
      CL:T CL:NIL))
    (THEMODULE
     (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-INFERENCE-CACHES-MODULE
      *MODULE*))
    (LOCAL?
     (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
      (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-INFERENCE-CACHES-LOCAL?
       TRUE-WRAPPER)))
    (FORCE?
     (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
      (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-INFERENCE-CACHES-FORCE?
       FALSE-WRAPPER)))
    (DISABLEJIT?
     (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
      (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-INFERENCE-CACHES-DISABLE-JIT?
       FALSE-WRAPPER))))
   (CL:WHEN (CL:AND *JUST-IN-TIME-FORWARD-INFERENCE?* DISABLEJIT?)
    (UNSET-POWERLOOM-FEATURE
     KWD-INFERENCE-CACHES-JUST-IN-TIME-INFERENCE)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
     "Disabled just-in-time forward inference" EOL))
   (CALL-RUN-FORWARD-RULES THEMODULE LOCAL? FORCE?)))

(CL:DEFUN RUN-FORWARD-RULES-EVALUATOR-WRAPPER (ARGUMENTS)
  (%RUN-FORWARD-RULES ARGUMENTS))

(CL:DEFMACRO RUN-FORWARD-RULES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Run forward inference rules in the module defined by the :module option (which
defaults to the current module).  If forward inferencing is already up-to-date
in the designated module, no additional inferencing will occur, unless the :force?
option is specified as TRUE, in which case all forward rules are run or rerun (for
backwards compatibility, this command also supports the old <module> :force arguments
specified with a non-standard keyword notation).  If :local? is TRUE (the default),
only propositions asserted locally in the module will be posted for forward inference,
otherwise, all true propositions visible in the module will be posted.

Calling `run-forward-rules' with :disable-jit? TRUE will disable future just-in-time
forward inference which will preserve cached forward inference in case of monotonic
assertions that do not clip (implicitly retract) any existing values.  Subsequent calls
can then trigger new inferences based on these updates only.  If the JIT stays enabled,
even monotonic updates will throw away the JIT cache.  Also, once any retractions have
been performed, all cached inferences will be thrown away and forward inference has to
be rerun from scratch or just-in-time forward inference needs to be enabled again."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/RUN-FORWARD-RULES|)) (CL:MACRO-FUNCTION (CL:QUOTE RUN-FORWARD-RULES)))

(CL:DEFUN HELP-STARTUP-INFERENCE-CACHES1 ()
  (CL:PROGN
   (CL:SETQ SYM-INFERENCE-CACHES-LOGIC-INFERENCE-CACHE-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERENCE-CACHE-OF" NULL 0))
   (CL:SETQ SYM-INFERENCE-CACHES-LOGIC-MONOTONIC?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MONOTONIC?" NULL 0))
   (CL:SETQ SGT-INFERENCE-CACHES-STELLA-WORLD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WORLD"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-INFERENCE-CACHES-JUST-IN-TIME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JUST-IN-TIME" NULL 2))
   (CL:SETQ SYM-INFERENCE-CACHES-LOGIC-JUST-IN-TIME-INFERENCE-CACHE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JUST-IN-TIME-INFERENCE-CACHE" NULL
     0))
   (CL:SETQ KWD-INFERENCE-CACHES-META
    (INTERN-RIGID-SYMBOL-WRT-MODULE "META" NULL 2))
   (CL:SETQ SYM-INFERENCE-CACHES-LOGIC-META-INFERENCE-CACHE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "META-INFERENCE-CACHE" NULL 0))
   (CL:SETQ KWD-INFERENCE-CACHES-TMS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TMS" NULL 2))
   (CL:SETQ SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED-INFERENCE-CACHE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-MAINTAINED-INFERENCE-CACHE"
     NULL 0))
   (CL:SETQ KWD-INFERENCE-CACHES-PREORDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREORDER" NULL 2))
   (CL:SETQ KWD-INFERENCE-CACHES-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SGT-INFERENCE-CACHES-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ SGT-INFERENCE-CACHES-STELLA-LITERAL-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-INFERENCE-CACHES-LOGIC-SKOLEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
   (CL:SETQ SGT-INFERENCE-CACHES-PL-KERNEL-KB-HIDDEN-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HIDDEN-RELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-INFERENCE-CACHES-RETRACT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT" NULL 2))
   (CL:SETQ SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-MAINTAINED?" NULL 0))
   (CL:SETQ KWD-INFERENCE-CACHES-PERFORMANCE-CLUES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PERFORMANCE-CLUES" NULL 2))
   (CL:SETQ SYM-INFERENCE-CACHES-LOGIC-UP-TO-DATE-INFERENCES?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-TO-DATE-INFERENCES?" NULL 0))
   (CL:SETQ SYM-INFERENCE-CACHES-LOGIC-PROPAGATE-CONSTRAINTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPAGATE-CONSTRAINTS" NULL 0))
   (CL:SETQ KWD-INFERENCE-CACHES-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ SYM-INFERENCE-CACHES-LOGIC-REPROPAGATE-CONSTRAINTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REPROPAGATE-CONSTRAINTS" NULL 0))
   (CL:SETQ KWD-INFERENCE-CACHES-EXTENSIONAL-ASSERTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTENSIONAL-ASSERTION" NULL 2))
   (CL:SETQ SGT-INFERENCE-CACHES-LOGIC-LOGIC-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
   (CL:SETQ KWD-INFERENCE-CACHES-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE" NULL 2))
   (CL:SETQ KWD-INFERENCE-CACHES-FORCE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORCE?" NULL 2))
   (CL:SETQ KWD-INFERENCE-CACHES-FORCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORCE" NULL 2))
   (CL:SETQ SGT-INFERENCE-CACHES-STELLA-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-INFERENCE-CACHES-LOCAL?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOCAL?" NULL 2))
   (CL:SETQ SGT-INFERENCE-CACHES-STELLA-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-INFERENCE-CACHES-DISABLE-JIT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DISABLE-JIT?" NULL 2))
   (CL:SETQ KWD-INFERENCE-CACHES-JUST-IN-TIME-INFERENCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JUST-IN-TIME-INFERENCE" NULL 2))
   (CL:SETQ SYM-INFERENCE-CACHES-STELLA-RUN-FORWARD-RULES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RUN-FORWARD-RULES"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-INFERENCE-CACHES-LOGIC-STARTUP-INFERENCE-CACHES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-INFERENCE-CACHES" NULL 0))
   (CL:SETQ SYM-INFERENCE-CACHES-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN STARTUP-INFERENCE-CACHES ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2)
    (HELP-STARTUP-INFERENCE-CACHES1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (DEFINE-FUNCTION-OBJECT "WORLD-STATE?"
     "(DEFUN (WORLD-STATE? BOOLEAN) ((SELF CONTEXT)) :PUBLIC? TRUE)"
     (CL:FUNCTION WORLD-STATE?) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-WORLD-STATE"
     "(DEFUN (GET-WORLD-STATE CONTEXT) ((SELF CONTEXT)) :PUBLIC? TRUE)"
     (CL:FUNCTION GET-WORLD-STATE) NULL)
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT CONTEXT META-INFERENCE-CACHE :TYPE WORLD :ALLOCATION :DYNAMIC)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT CONTEXT TRUTH-MAINTAINED-INFERENCE-CACHE :TYPE WORLD :ALLOCATION :DYNAMIC)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT CONTEXT JUST-IN-TIME-INFERENCE-CACHE :TYPE WORLD :ALLOCATION :DYNAMIC)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT WORLD INFERENCE-CACHE-OF :TYPE CONTEXT :PUBLIC? TRUE :ALLOCATION :DYNAMIC)")
    (DEFINE-FUNCTION-OBJECT "LOOKUP-INFERENCE-CACHE"
     "(DEFUN (LOOKUP-INFERENCE-CACHE WORLD) ((CONTEXT CONTEXT) (KIND KEYWORD)) :PUBLIC? TRUE)"
     (CL:FUNCTION LOOKUP-INFERENCE-CACHE) NULL)
    (DEFINE-FUNCTION-OBJECT "INITIALIZE-INFERENCE-WORLD"
     "(DEFUN INITIALIZE-INFERENCE-WORLD ((WORLD WORLD)))"
     (CL:FUNCTION INITIALIZE-INFERENCE-WORLD) NULL)
    (DEFINE-FUNCTION-OBJECT "CREATE-INFERENCE-CACHE"
     "(DEFUN (CREATE-INFERENCE-CACHE WORLD) ((CONTEXT CONTEXT) (KIND KEYWORD)) :PUBLIC? TRUE)"
     (CL:FUNCTION CREATE-INFERENCE-CACHE) NULL)
    (DEFINE-FUNCTION-OBJECT "JUST-IN-TIME-INFERENCE-CACHE?"
     "(DEFUN (JUST-IN-TIME-INFERENCE-CACHE? BOOLEAN) ((SELF CONTEXT)) :DOCUMENTATION \"Return true if `self' is the JIT cache of some world state.\" :PUBLIC? TRUE)"
     (CL:FUNCTION JUST-IN-TIME-INFERENCE-CACHE?) NULL)
    (DEFINE-FUNCTION-OBJECT "META-INFERENCE-CACHE?"
     "(DEFUN (META-INFERENCE-CACHE? BOOLEAN) ((SELF CONTEXT)) :DOCUMENTATION \"Return true if `self' is the meta-JIT cache of some world state.\" :PUBLIC? TRUE)"
     (CL:FUNCTION META-INFERENCE-CACHE?) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-INFERENCE-CACHE"
     "(DEFUN (GET-INFERENCE-CACHE WORLD) ((CONTEXT CONTEXT) (KIND KEYWORD)) :PUBLIC? TRUE)"
     (CL:FUNCTION GET-INFERENCE-CACHE) NULL)
    (DEFINE-FUNCTION-OBJECT "DESTROY-INFERENCE-CACHE"
     "(DEFUN DESTROY-INFERENCE-CACHE ((CONTEXT CONTEXT) (KIND KEYWORD)) :PUBLIC? TRUE)"
     (CL:FUNCTION DESTROY-INFERENCE-CACHE) NULL)
    (DEFINE-FUNCTION-OBJECT "DESTROY-ALL-INFERENCE-CACHES"
     "(DEFUN DESTROY-ALL-INFERENCE-CACHES ((CONTEXT CONTEXT) (KIND KEYWORD)) :PUBLIC? TRUE)"
     (CL:FUNCTION DESTROY-ALL-INFERENCE-CACHES) NULL)
    (DEFINE-FUNCTION-OBJECT "UNLINK-INFERENCE-CACHE"
     "(DEFUN UNLINK-INFERENCE-CACHE ((SELF WORLD)))"
     (CL:FUNCTION UNLINK-INFERENCE-CACHE) NULL)
    (DEFINE-FUNCTION-OBJECT "DESTROY-INFERENCE-CACHES"
     "(DEFUN DESTROY-INFERENCE-CACHES ((CONTEXT CONTEXT)) :PUBLIC? TRUE)"
     (CL:FUNCTION DESTROY-INFERENCE-CACHES) NULL)
    (DEFINE-FUNCTION-OBJECT "META-PROPOSITION?"
     "(DEFUN (META-PROPOSITION? BOOLEAN) ((PROPOSITION PROPOSITION)) :DOCUMENTATION \"Return TRUE if 'proposition' is tied only to at least one meta object
and no other objects except literals or function terms that are itself meta objects.\" :PUBLIC? TRUE)"
     (CL:FUNCTION META-PROPOSITION?) NULL)
    (DEFINE-FUNCTION-OBJECT "HANDLE-OUT-OF-DATE-INFERENCE-CACHE"
     "(DEFUN HANDLE-OUT-OF-DATE-INFERENCE-CACHE ((ASSERTORRETRACT KEYWORD) (PROPOSITION PROPOSITION)))"
     (CL:FUNCTION HANDLE-OUT-OF-DATE-INFERENCE-CACHE) NULL)
    (DEFINE-FUNCTION-OBJECT "BEST-INFERENCE-CACHE"
     "(DEFUN (BEST-INFERENCE-CACHE WORLD) ((CONTEXT CONTEXT)))"
     (CL:FUNCTION BEST-INFERENCE-CACHE) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-QUERY-CONTEXT"
     "(DEFUN (GET-QUERY-CONTEXT CONTEXT) () :PUBLIC? TRUE)"
     (CL:FUNCTION GET-QUERY-CONTEXT) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-PROPERTY-TEST-CONTEXT"
     "(DEFUN (GET-PROPERTY-TEST-CONTEXT CONTEXT) ())"
     (CL:FUNCTION GET-PROPERTY-TEST-CONTEXT) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-INFERABLE-TEST-CONTEXT"
     "(DEFUN (GET-INFERABLE-TEST-CONTEXT CONTEXT) ())"
     (CL:FUNCTION GET-INFERABLE-TEST-CONTEXT) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-TOP-LEVEL-UPDATE-CONTEXT"
     "(DEFUN (GET-TOP-LEVEL-UPDATE-CONTEXT CONTEXT) ())"
     (CL:FUNCTION GET-TOP-LEVEL-UPDATE-CONTEXT) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-CONSTRAINT-PROPAGATION-WORLD"
     "(DEFUN (LOOKUP-CONSTRAINT-PROPAGATION-WORLD WORLD) ((SELF CONTEXT)))"
     (CL:FUNCTION LOOKUP-CONSTRAINT-PROPAGATION-WORLD) NULL)
    (DEFINE-FUNCTION-OBJECT "INHERIT-CACHED-INFERENCES"
     "(DEFUN INHERIT-CACHED-INFERENCES ((FROMWORLD WORLD) (TOWORLD WORLD)))"
     (CL:FUNCTION INHERIT-CACHED-INFERENCES) NULL)
    (DEFINE-FUNCTION-OBJECT "INHERIT-TRUTH-VALUE-UPDATE"
     "(DEFUN INHERIT-TRUTH-VALUE-UPDATE ((PROPOSITION PROPOSITION) (TOWORLD WORLD)))"
     (CL:FUNCTION INHERIT-TRUTH-VALUE-UPDATE) NULL)
    (DEFINE-FUNCTION-OBJECT "INHERIT-VARIABLE-VALUE-UPDATE"
     "(DEFUN INHERIT-VARIABLE-VALUE-UPDATE ((SKOLEM SKOLEM) (TOWORLD WORLD)))"
     (CL:FUNCTION INHERIT-VARIABLE-VALUE-UPDATE) NULL)
    (DEFINE-FUNCTION-OBJECT "CALL-PROPAGATE-CONSTRAINTS"
     "(DEFUN CALL-PROPAGATE-CONSTRAINTS ((CONTEXT CONTEXT)) :DOCUMENTATION \"OBSOLETE: use `call-run-forward-rules' instead.\")"
     (CL:FUNCTION CALL-PROPAGATE-CONSTRAINTS) NULL)
    (DEFINE-FUNCTION-OBJECT "PROPAGATE-CONSTRAINTS"
     "(DEFUN PROPAGATE-CONSTRAINTS (|&REST| (NAME NAME)) :DOCUMENTATION \"OBSOLETE: use `run-forward-rules' instead.\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
     (CL:FUNCTION %PROPAGATE-CONSTRAINTS)
     (CL:FUNCTION PROPAGATE-CONSTRAINTS-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "REPROPAGATE-CONSTRAINTS"
     "(DEFUN REPROPAGATE-CONSTRAINTS (|&REST| (NAME NAME)) :DOCUMENTATION \"OBSOLETE: use `run-forward-rules' instead.\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
     (CL:FUNCTION %REPROPAGATE-CONSTRAINTS)
     (CL:FUNCTION REPROPAGATE-CONSTRAINTS-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "CALL-RUN-FORWARD-RULES"
     "(DEFUN CALL-RUN-FORWARD-RULES ((CONTEXT CONTEXT) (LOCAL? BOOLEAN) (FORCE? BOOLEAN)) :DOCUMENTATION \"Callable implementation for `run-forward-rules' (which see).\" :PUBLIC? TRUE)"
     (CL:FUNCTION CALL-RUN-FORWARD-RULES) NULL)
    (DEFINE-FUNCTION-OBJECT "RUN-FORWARD-RULES"
     "(DEFUN RUN-FORWARD-RULES (|&REST| (OPTIONS OBJECT)) :DOCUMENTATION \"Run forward inference rules in the module defined by the :module option (which
defaults to the current module).  If forward inferencing is already up-to-date
in the designated module, no additional inferencing will occur, unless the :force?
option is specified as TRUE, in which case all forward rules are run or rerun (for
backwards compatibility, this command also supports the old <module> :force arguments
specified with a non-standard keyword notation).  If :local? is TRUE (the default),
only propositions asserted locally in the module will be posted for forward inference,
otherwise, all true propositions visible in the module will be posted.

Calling `run-forward-rules' with :disable-jit? TRUE will disable future just-in-time
forward inference which will preserve cached forward inference in case of monotonic
assertions that do not clip (implicitly retract) any existing values.  Subsequent calls
can then trigger new inferences based on these updates only.  If the JIT stays enabled,
even monotonic updates will throw away the JIT cache.  Also, once any retractions have
been performed, all cached inferences will be thrown away and forward inference has to
be rerun from scratch or just-in-time forward inference needs to be enabled again.\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
     (CL:FUNCTION %RUN-FORWARD-RULES)
     (CL:FUNCTION RUN-FORWARD-RULES-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "STARTUP-INFERENCE-CACHES"
     "(DEFUN STARTUP-INFERENCE-CACHES () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-INFERENCE-CACHES) NULL)
    (CL:LET*
     ((FUNCTION
       (LOOKUP-FUNCTION
        SYM-INFERENCE-CACHES-LOGIC-STARTUP-INFERENCE-CACHES)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
      SYM-INFERENCE-CACHES-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupInferenceCaches") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "LOGIC")))
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *INVISIBLEASSERTION?* BOOLEAN FALSE :DOCUMENTATION \"Used to signal an assertion that doesn't
blow away inference caches.\")" NULL)
    (REGISTER-NATIVE-NAME
     SYM-INFERENCE-CACHES-LOGIC-PROPAGATE-CONSTRAINTS
     KWD-INFERENCE-CACHES-COMMON-LISP KWD-INFERENCE-CACHES-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-INFERENCE-CACHES-LOGIC-REPROPAGATE-CONSTRAINTS
     KWD-INFERENCE-CACHES-COMMON-LISP KWD-INFERENCE-CACHES-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-INFERENCE-CACHES-STELLA-RUN-FORWARD-RULES
     KWD-INFERENCE-CACHES-COMMON-LISP KWD-INFERENCE-CACHES-FUNCTION))))
