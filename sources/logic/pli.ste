;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;; BEGIN LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
; Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          ;
;                                                                            ;
; The contents of this file are subject to the Mozilla Public License        ;
; Version 1.1 (the "License"); you may not use this file except in           ;
; compliance with the License. You may obtain a copy of the License at       ;
; http://www.mozilla.org/MPL/                                                ;
;                                                                            ;
; Software distributed under the License is distributed on an "AS IS" basis, ;
; WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   ;
; for the specific language governing rights and limitations under the       ;
; License.                                                                   ;
;                                                                            ;
; The Original Code is the PowerLoom KR&R System.                            ;
;                                                                            ;
; The Initial Developer of the Original Code is                              ;
; UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          ;
; 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               ;
;                                                                            ;
; Portions created by the Initial Developer are Copyright (C) 1997-2019      ;
; the Initial Developer. All Rights Reserved.                                ;
;                                                                            ;
; Contributor(s):                                                            ;
;                                                                            ;
; Alternatively, the contents of this file may be used under the terms of    ;
; either the GNU General Public License Version 2 or later (the "GPL"), or   ;
; the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   ;
; in which case the provisions of the GPL or the LGPL are applicable instead ;
; of those above. If you wish to allow use of your version of this file only ;
; under the terms of either the GPL or the LGPL, and not to allow others to  ;
; use your version of this file under the terms of the MPL, indicate your    ;
; decision by deleting the provisions above and replace them with the notice ;
; and other provisions required by the GPL or the LGPL. If you do not delete ;
; the provisions above, a recipient may use your version of this file under  ;
; the terms of any one of the MPL, the GPL or the LGPL.                      ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; END LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; Version: $Id$

;;; Application Program Interface (API) for PowerLoom

(in-package "STELLA")

(in-module "PLI")


;;; TO DO:
;;; - make environments real
;;; - does TAXONOMIC mean we'll also get forward inferences?
;;; - make sure assertion commands aren't run in an inference cache
;;;   (at least by default)
;;; - all the retrieval commands should run the equivalent to
;;;   `process-definitions' - or should we instead have a PLI version
;;;   and force the user to do this?
;;; - functions such as `get-current-module' wind up in the "wrong" namespace,
;;;   since they are defined on a class defined in PLI; fix that.
;;; - get-propositions support for negated or unasserted propositions
;;; - we need support for creation and lookup of function terms
;;; - we need support for readable stringification of function terms (without the skolem prefix)
;;; - we need a find-or-create-object
;;; - load path manipulation functions
;;; - load-directory (plus filtering options)
;;; - describe (at least in Python)
;;; - object creation functions such as "evaluate/conceive/create-term"
;;; - first/second/... on PL-ITERATOR's
;;; - easier access to the value of a proposition (right now
;;;   we retrieve the set, access the right element in the
;;;   result iterator and then access the column in that)
;;; - parametric-retrieve and/or cached-retrieve
;;; - retrieve-partial
;;; - ask-partial
;;; - reset-kernel-kb (or something like that)
;;; - destroy-module
;;; - s-versions of get-proper-subrelations, get-direct-subrelations,
;;;   get-proper-superrelations, get-direct-superrelations
;;; - truth-value accessor for propositions
;;; - strict/default/asserted/inferred
;;; - is-concept/relation/function/instance/closed


  ;;
;;;;;; SETUP
  ;;

(defglobal *powerloom-initialized?* BOOLEAN FALSE)
(startup-time-progn
  (setq *powerloom-initialized?* TRUE))

(defun initialize ()
  :documentation "Initialize the PowerLoom logic system.  This function
needs to be called by all applications before using PowerLoom.  If it
is called more than once, every call after the first one is a no-op."
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  ;; NOTE: this does only protect us from multiple calls to `initialize'
  ;;    or from calling it after `startup-logic-system' has already run,
  ;;    but it does not prevent us from calling `startup-logic-system'
  ;;    multiple times (which is intentional).
  (with-process-lock *bootstrap-lock*
    (when (not *powerloom-initialized?*)
      ;; this will set `*powerloom-initialized?*' to true:
      (startup-logic-system))))

(defun reset-powerloom ()
  :documentation "Reset PowerLoom to its initial state.
CAUTION: This will destroy all loaded knowledge bases and might break other
loaded STELLA systems if they do reference PowerLoom symbols in their code."
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  (with-process-lock *powerloom-lock*
    (logic/reset-powerloom)))

(defun clear-caches ()
  :documentation "Clear all query and memoization caches."
  :public? TRUE :c-callable? TRUE
  (with-process-lock *powerloom-lock*
    (logic/clear-caches)))


  ;;
;;;;;; ENVIRONMENTS
  ;;

;;; THIS IS JUST A STUB CLASS:
(defclass ENVIRONMENT (STANDARD-OBJECT)
  :public? TRUE
  :slots ((level :type STRING))
  :print-form (print-native-stream stream "|ENV|" (level self))
  )

(defconstant ASSERTION-ENV ENVIRONMENT (new ENVIRONMENT :level "ASSERTION")
  :public? TRUE)
(defconstant TAXONOMIC-ENV ENVIRONMENT (new ENVIRONMENT :level "TAXONOMIC")
  :public? TRUE)
(defconstant INFERENCE-ENV ENVIRONMENT (new ENVIRONMENT :level "INFERENCE")
  :public? TRUE)

(defun (test-environment-level? BOOLEAN) ((env ENVIRONMENT) (level STRING))
  :public? FALSE :globally-inline? TRUE
  :documentation "Test if `env' has level set to `level'"
  (return (and (defined? env) (string-eql? (level env) level))))

  ;;
;;;;;; PL ITERATOR
  ;;

;; Bob's original PL-ITERATOR.  Replaced by code below that doesn't
;; try to handle the Java interface side of things.
;;
;; TO DO:
;; - Revisit this to insert a special class in just the Java hierarchy in order to get the
;;   appropriate inclusion that implements java.util.Iterator (or whatever the latest API is)
;; - think about creating/using/wrapping QUERY-ITERATORs more intelligently, so that we can
;;   iterate one solution at a time in the calling application, instead of first generating
;;   some/all solutions and then providing iteration over the result.  Currently, only
;;   `evaluate' can return a query iterator, but we might want to think about having `retrieve'
;;   return a non-exhausted pl-iterator that can then be advanced dynamically.  This will need
;;   to store some of the requisite environment and call `call-retrieve' or similar.

(defclass PL-ITERATOR (ITERATOR)
  :public? TRUE
  :parameters ((any-value :type OBJECT))
  :slots ((cursor :type CONS))
;;  :java-native-type "pli.PL_ITERATOR"
  )

(defmethod (next? BOOLEAN) ((self PL-ITERATOR))
  :public? TRUE :c-callable? TRUE
  :documentation "Advance the PL-Iterator `self' and return `true' if more
elements are available, `false' otherwise."
  (let ((cursor (cursor self)))
    (when (nil? cursor)
      (setf (slot-value self value) NULL)
      (return FALSE))
    (setf (slot-value self value) (value cursor)) 
    (setf (cursor self) (rest cursor))
    (return TRUE)))

(defun (pl-iterator-value OBJECT) ((self PL-ITERATOR))
  :documentation "C-callable iterator `value'-slot accessor."
  :public? TRUE :c-callable? TRUE
  (return (slot-value self value)))

(defmethod (empty? BOOLEAN) ((self PL-ITERATOR))
  :documentation "Return TRUE if the iterator `self' has no more elements."
  :public? TRUE :c-callable? TRUE
  (return (eq? (cursor self) NIL)))

(defun (pl-iterator-is-empty BOOLEAN) ((self PL-ITERATOR))
  :documentation "Return TRUE if the iterator `self' has no more elements.
This is here primarily to support the `is-...' naming convention for tests."
  :public? TRUE :c-callable? TRUE
  (return (eq? (cursor self) NIL)))

(defmethod (length INTEGER) ((self PL-ITERATOR))
  :public? TRUE :c-callable? TRUE
  :documentation "Number of items remaining in `self'.  Non destructive."
  (return (length (cursor self))))

(defglobal EMPTY-PL-ITERATOR PL-ITERATOR (new PL-ITERATOR :cursor NIL)
  :public? FALSE
  :documentation "Iterator that generates no values.")

(defun (cons-to-pl-iterator PL-ITERATOR) ((self CONS))
  :documentation "Convert a STELLA cons list into an API iterator."
  :public? TRUE :c-callable? TRUE
  (if (empty? self)
    (return EMPTY-PL-ITERATOR)
    (return (new PL-ITERATOR :cursor self))))

(defun (list-to-pl-iterator PL-ITERATOR) ((self LIST)) 
  :documentation "Convert a STELLA list into an API iterator."
  :public? TRUE :c-callable? TRUE
  (if (empty? self)
    (return EMPTY-PL-ITERATOR)
    (return (cons-to-pl-iterator (the-cons-list self)))))

(defun (iterator-to-pl-iterator PL-ITERATOR) ((self ITERATOR))
  :documentation "Convert an arbitrary STELLA iterator into an API iterator.
This will first exhaust `self' and then create an API iterator that will
iterate over the previously generated values."
  :public? TRUE :c-callable? TRUE
  ;; Strategy: Generate a cons list of values from `self' and stuff them into an iterator:
  (return (cons-to-pl-iterator (consify self))))

(defmethod (listify LIST) ((self PL-ITERATOR))
  :public? TRUE :c-callable? TRUE
  :documentation "Convert `self' into a Stella LIST."
  (return (new LIST :the-cons-list (collect x in self))))

(defmethod (consify CONS) ((self PL-ITERATOR))
  :public? TRUE :c-callable? TRUE
  :documentation "Convert `self' into a Stella CONS."
  (return (collect x in self)))


  ;;
;;;;;; STELLA lists and literals
  ;;

;;; The following functions are available to support construction and access to CONS lists
;;; in C, since those are needed as inputs to various API functions that require lists of elements.
;;; We also need to support allocation of string literals and wrapping of literal types.

(defun (create-cons CONS) ((first OBJECT) (rest CONS))
  :documentation "Create a STELLA CONS-cell whose value points to `first' and tail points to `rest'.
If `rest' is NULL, it will point to the empty list (available as a constructor in C)."
  :public? TRUE :c-callable? TRUE
  (when (null? rest)
    (setq rest NIL))
  (return (cons first rest)))

(defun (create-cons-list CONS) ((length INTEGER))
  :documentation "Create a STELLA CONS-list of `length' with elements initialized to NULL (available as a constructor in C)."
  :public? TRUE :c-callable? TRUE
  (let ((list NIL))
    (while (> length 0)
      (setq list (cons NULL list))
      (-- length))
    (return list)))

(defun (cons-length INTEGER) ((self CONS))
  :documentation "Return the length of the CONS-list `self' (available to support access in C)."
  :public? TRUE :c-callable? TRUE
  (return (length self)))

(defun (cons-is-empty BOOLEAN) ((self CONS))
  :documentation "Return TRUE if the CONS-list `self' is empty (available to support access in C)."
  :public? TRUE :c-callable? TRUE
  (return (eq? self NIL)))

(defun (cons-first (LIKE (any-value self))) ((self CONS))
  :documentation "Access the first element of the CONS-list `self' (available to support access in C)."
  :public? TRUE :c-callable? TRUE
  (return (value self)))

(defun (cons-rest (LIKE self)) ((self CONS))
  :documentation "Access the rest (tail) of the CONS-list `self' (available to support access in C)."
  :public? TRUE :c-callable? TRUE
  (return (rest self)))

(defun (cons-nth (LIKE (any-value self))) ((self CONS) (n INTEGER))
  :documentation "Access the `n'-th element of the CONS-list `self' (available to support access in C)."
  :public? TRUE :c-callable? TRUE
  (return (nth self n)))

(defun (cons-nth-rest (LIKE self)) ((self CONS) (n INTEGER))
  :documentation "Access the `n'-th rest (tail) of the CONS-list `self' (available to support access in C)."
  :public? TRUE :c-callable? TRUE
  (return (nth-rest self n)))

(defun cons-set-first ((self CONS) (value OBJECT))
  :documentation "Set the first element of the CONS-list `self' to `value' (available to support access in C)."
  :public? TRUE :c-callable? TRUE
  (setf (value self) value))

(defun cons-set-rest ((self CONS) (rest CONS))
  :documentation "Set the rest (tail) of the CONS-list `self' to `rest' (available to support access in C).
If `rest' is NULL, it will point to the empty list."
  :public? TRUE :c-callable? TRUE
  (when (null? rest)
    (setq rest NIL))
  (setf (rest self) rest))

(defun cons-set-nth ((self CONS) (n INTEGER) (value OBJECT))
  :documentation "Set the `n'-th element of the CONS-list `self' to `value' (available to support access in C).
The run-time complexity of this operation is O(n)."
  :public? TRUE :c-callable? TRUE
  (setf (nth self n) value))

(defun cons-set-nth-rest ((self CONS) (n INTEGER) (rest CONS))
  :documentation "Set the `n'-th rest (tail) of the CONS-list `self' to `rest' (available to support access in C).
If `rest' is NULL, it will point to the empty list.  The run-time complexity of this operation is O(n)."
  :public? TRUE :c-callable? TRUE
  (when (null? rest)
    (setq rest NIL))
  (setf (nth-rest self n) rest))

(defun (list-first (LIKE (any-value self))) ((self LIST))
  :documentation "Access the first element of the list `self' (available to support access in C)."
  :public? TRUE :c-callable? TRUE
  (return (first self)))

(defun (list-rest (CONS OF (LIKE (any-value self)))) ((self LIST))
  :documentation "Access the rest (tail) of the list `self' (available to support access in C).
NOTE: the rest of a STELLA list is a CONS-list not a LIST."
  :public? TRUE :c-callable? TRUE
  (return (rest self)))

(defun (list-nth (LIKE (any-value self))) ((self LIST) (n INTEGER))
  :documentation "Access the `n'-th element of the list `self' (available to support access in C)."
  :public? TRUE :c-callable? TRUE
  (return (nth self n)))

(defun (create-string STRING) ((content STRING))
  :documentation "Create a PowerLoom copy of the string `content' which uses PowerLoom memory
management and garbage collection.  This is primarily necessary in C environments when a string
is passed to a PowerLoom PLI function which might then be pointed to by a PowerLoom result
object such as a string wrapper.  If such an argument string is later explicitly freed or
overwritten, the result object would have a dangling reference or its content destroyed."
  :public? TRUE :c-callable? TRUE
  (return (copy content)))

(defun (create-string-wrapper STRING-WRAPPER) ((self STRING))
  :documentation "Create a STELLA string wrapper for `self'.  This automatically copies `self'
before the wrapper is allocated to avoid garbage collection issues in case `self' is freed."
  :public? TRUE :c-callable? TRUE
  (return (copy self)))

(defun (create-direct-string-wrapper STRING-WRAPPER) ((self STRING))
  :documentation "Create a STELLA string wrapper for `self'.  This wraps `self' directly
and does not allocate a PowerLoom copy first, hence, memory management of `self' needs to
be carefully handled by the caller."
  :public? TRUE :c-callable? TRUE
  (return self))

(defun (create-integer-wrapper INTEGER-WRAPPER) ((self INTEGER))
  :documentation "Create a STELLA integer wrapper for `self'."
  :public? TRUE :c-callable? TRUE
  (return self))

(defun (create-long-integer-wrapper LONG-INTEGER-WRAPPER) ((self LONG-INTEGER))
  :documentation "Create a STELLA long-integer wrapper for `self'."
  :public? TRUE :c-callable? TRUE
  (return self))

(defun (create-float-wrapper FLOAT-WRAPPER) ((self FLOAT))
  :documentation "Create a STELLA float wrapper for `self'."
  :public? TRUE :c-callable? TRUE
  (return self))

(defun (create-boolean-wrapper BOOLEAN-WRAPPER) ((self BOOLEAN))
  :documentation "Create a STELLA boolean wrapper for `self'."
  :public? TRUE :c-callable? TRUE
  (return self))


  ;;
;;;;;; Utility functions for PLI bodies
  ;;

(defun (safely-get-object OBJECT)
       ((name STRING) (module MODULE) (environment ENVIRONMENT))
  :public? FALSE
  ;; Helping function for API functions.  Retrieve an object
  ;;    named `name' in `module' subject to `environment' options.
  ;; If there is none, generate a suitable message.
  ;; Designed not to break if `name' is null.  Returns NULL if
  ;;    `name' is null.
  (when (null? name)
    (return NULL))
  (let ((object (get-object name module environment)))
    (if (null? object)
      (signal NO-SUCH-OBJECT-EXCEPTION "Can't find an object named " name)
      (return object))))

(defun (safely-get-concept OBJECT)
       ((name STRING) (module MODULE) (environment ENVIRONMENT))
  :public? FALSE
  ;; Helping function for API functions.  Retrieve a concept
  ;;    named `name' in `module' subject to `environment' options.
  ;; If there is none, generate a suitable message.
  ;; Designed not to break if `name' is null.  Returns NULL if
  ;;    `name' is null.
  (when (null? name)
    (return NULL))
  (let ((object (get-concept name module environment)))
    (if (null? object)
      (signal NO-SUCH-OBJECT-EXCEPTION "Can't find a concept named " name)
      (return object))))

(defun (safely-get-relation OBJECT)
       ((name STRING) (module MODULE) (environment ENVIRONMENT))
  :public? FALSE
  ;; Helping function for API functions.  Retrieve a relation or function
  ;;    named `name' in `module' subject to `environment' options.
  ;; If there is none, generate a suitable message.
  ;; Designed not to break if `module' is null.  Returns NULL if
  ;;    `module' is null.
  (when (null? name)
    (return NULL))
  (let ((object (get-relation name module environment)))
    (if (null? object)
      (signal NO-SUCH-OBJECT-EXCEPTION "Can't find a relation named " name)
      (return object))))

(defun (safely-get-module CONTEXT) ((name STRING) (environment ENVIRONMENT))
  :public? FALSE
  ;; If `name' is non-null and non-empty, look for a module named `name',
  ;;    and complain if none is found.
  ;; Otherwise, return the current module.
  (ignore environment)                  ; TEMPORARY?
  (when (or (null? name)
            (eql? name ""))
    (return *module*))
  (return (get-stella-module name TRUE)))

(defun (safely-get-object-or-null OBJECT)
       ((name STRING) (module MODULE) (environment ENVIRONMENT))
  :public? FALSE
  ;; Helping function for API functions.
  ;; Same as `safely-get-object' but tolerates a null input.
  (when (or (null? module)
            (null? name)
	    (string-eql? name "")
            (string-equal? name "null"))
    (return NULL))
  (exception-case
      (return (get-object name module environment))
    (NO-SUCH-OBJECT-EXCEPTION ()
      (return NULL))))

(defun (sequence-to-cons-list CONS) ((sequence OBJECT))
  :public? FALSE
  ;; Convert `sequence' to a cons list.
  (typecase sequence
    (CONS (return sequence))
    (LIST (return (the-cons-list sequence)))
    (VECTOR
     (let ((result nil))
       (foreach i in (interval 0 (length sequence))
	   collect (nth sequence i) into result)
       (return result)))
    (otherwise
      (signal STELLA-EXCEPTION "Don't know how to convert object of type " (primary-type sequence) " into a cons list."))))

(defun (explode-string-list CONS) ((stringList STRING) (module MODULE))
  :public? FALSE
  ;; Return a list of logic terms extracted from `stringList'.
  (within-module module
    (let ((expression CONS (unstringify stringList))
          (term OBJECT NULL)
          (result NIL))
      (foreach ref in expression
          do (setq term (choose (eql? ref (quote NULL))
                                NULL
                                (evaluate-term ref)))
          collect term into result)
      (return result))))

(defun (legal-operator? BOOLEAN) ((operator SYMBOL))
  :public? FALSE
  (return (or (member? *kif-sentence-operators* operator)
              (member? *kif-term-operators* operator)
              (member? (quote (<=>> <<=> <<=>> <~> <~>> <<~> <<~>>
                                    about <<= =>> <~ ~> <<~ ~>>))
                       operator))))


  ;;
;;;;;; Names to instances and back
  ;;

(defun (get-keyword KEYWORD) ((name STRING))
  :public? TRUE :c-callable? TRUE
  :documentation "Returns the Stella KEYWORD `name' if it exists.  Case sensitive."
  (return (lookup-keyword name)))

(defun (get-symbol SYMBOL) ((name STRING) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation "Returns the Stella SYMBOL `name' visible in `module' if it
exists.  `name' is ALWAYS treated literally and case sensitively."
  (with-logic-environment module environment
    (return (lookup-symbol name))
    #|  potentially case-insensitive version:
    ;; Additional doc string text:
    ;; "`name may be treated non case sensitively if `module' is not case sensitive."
    (let ((sym (lookup-symbol name)))
      (if (defined? sym)
        (return sym)
        (if (case-sensitive? *module*)
          (return (lookup-symbol (string-upcase name)))
          (return NULL))))
     |#
    ))

(defun (get-operator SYMBOL) ((name STRING))
  :documentation "Returns the logical operator object (a Stella SYMBOL) for `name'.
If no such operator exists then a `no-such-object' exception is thrown."
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  (unless (all-upper-case-string? name)
    (setq name (string-upcase name)))
  (let ((operator (lookup-symbol-in-module name *logic-module* false)))
    (if (and (defined? operator) (legal-operator? operator))
      (return operator)
      (signal NO-SUCH-OBJECT-EXCEPTION "No operator named " name))))

(defun (get-object OBJECT) ((name STRING) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Look for an object named `name' that is local to
or visible from the module `module'.  `name' is not taken literally
but will be parsed first with the PowerLoom symbol reader and, hence,
can contain escape characters, module prefixes, etc."
  (with-logic-environment module environment
    (return (LOGIC/get-instance (lookup-stella-name name)))))

(defun (s-get-object OBJECT) ((name STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Look for an object named `name' that is local to
or visible from the module `module-name'.  A module name of `null' or the
empty string refers to the current module.  If no module can be found
with the name `module-name', then a STELLA `no-such-context-exception' is thrown.
`name' is not taken literally but will be parsed first (see `get-object')."
  (return 
    (get-object name (safely-get-module module-name environment) environment)))

(defun (get-concept LOGIC-OBJECT) ((name STRING) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return a class/concept named `name' that is local to
or visible from the module `module'.  `name' is not taken literally but
will be parsed first (see `get-object')."
  (with-logic-environment module environment
    (return (LOGIC/get-class (lookup-stella-name name)))))

(defun (s-get-concept LOGIC-OBJECT) ((name STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return a class/concept named `name' that is local to
or visible from the module `module-name'.  A module name of `null' or the
empty string refers to the current module.  If no module can be found
with the name `module-name', then a Stella `no-such-context-exception' is thrown.
`name' is not taken literally but will be parsed first (see `get-object')."
  (return 
    (get-concept name (safely-get-module module-name environment) environment)))

(defun (get-relation LOGIC-OBJECT) ((name STRING) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return a concept or relation named `name' that is local to
or visible from the module `module'.  `name' is not taken literally but will
be parsed first (see `get-object')."
  (with-logic-environment module environment
    (return (LOGIC/get-relation (lookup-stella-name name)))))

(defun (s-get-relation LOGIC-OBJECT) ((name STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return a concept or relation named `name' that is local to
or visible from the module `module-name'.  A module name of `null' or the
empty string refers to the current module.  If no module can be found
with the name `module-name', then a Stella `no-such-context-exception' is thrown.
`name' is not taken literally but will be parsed first (see `get-object')."
  (return 
    (get-relation name (safely-get-module module-name environment) environment)))


;;;;
;;;; Multiple get section
;;;;

(defun (get-undefined-relations (PL-ITERATOR OF LOGIC-OBJECT))
    ((module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return relations that have been referenced but not defined in `module'."
  (with-logic-environment module environment
    ;; we need to evaluate `*module*' here which for the case where `module' was NULL will be
    ;; properly initialized by `with-logic-environment' (this is done throughout this file):
    (setq module *module*) 
    (return (cons-to-pl-iterator (call-list-undefined-relations module FALSE)))))


;;;;
;;;;  GET-NAME series.
;;;;  GET-NAME is always fully qualified.
;;;;  GET-SHORT-NAME is never qualified.
;;;;  GET-NAME-IN-MODULE gets the name needed to find the object as seen from the module.
;;;;

(defun (get-name-in-module STRING) ((obj OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return the name, qualified as necessary, so that `obj' can be found from
`module'.  If there is no name for the object return `null'."
  (with-logic-environment module environment
    (typecase obj
      (SKOLEM
       ;; skolems are unnamed objects:
       (return NULL))
      (LOGIC-OBJECT
       (return (stringify (object-name obj))))
      (GENERALIZED-SYMBOL
       (return (stringify obj)))
      (MODULE
       (return (module-full-name obj)))
      (CONTEXT
       (return (context-name obj)))
      (/PL-KERNEL-KB/COMPUTED-PROCEDURE
       (return (stringify (surrogate-value-inverse obj))))
      (otherwise 
       (return NULL)))))

(defun (get-name STRING) ((obj OBJECT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return the fully qualified name of `obj', if it has one.  Otherwise return `null'."
  (return (get-name-in-module obj *root-module* NULL)))

(defun (get-short-name STRING) ((obj OBJECT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return the short name of `obj', if it has one.  Otherwise return `null'."
  (typecase obj
    (SKOLEM
     (return NULL))
    (LOGIC-OBJECT
     (return (object-name-string obj)))
    ;; Do we want to do this?
    (KEYWORD
     (return (concatenate ":" (symbol-name obj))))
    (GENERALIZED-SYMBOL
     (return (symbol-name obj)))
    (CONTEXT
     (return (context-name obj)))
    (/PL-KERNEL-KB/COMPUTED-PROCEDURE
     (return (symbol-name (surrogate-value-inverse obj))))
    (otherwise 
     (return NULL))))

(defun (get-skolem-name STRING) ((skolem SKOLEM))
  :documentation "Return the fully qualified name of `skolem'.  Note that skolems are anonymous objects
which cannot be referenced by their name in logic expressions, so this function is only useful in special
circumstances such as inside specialist computations, etc."
  :public? TRUE :c-callable? TRUE
  (return (get-name-in-module (skolem-name skolem) *root-module* NULL)))

(defun (get-skolem-short-name STRING) ((skolem SKOLEM))
  :documentation "Return the unqualified name of `skolem'.  Note that skolems are anonymous objects which
cannot be referenced by their name in logic expressions, so this function is only useful in special
circumstances such as inside specialist computations, etc."
  :public? TRUE :c-callable? TRUE
  (return (symbol-name (skolem-name skolem))))

(defun (get-variable-name STRING) ((variable PATTERN-VARIABLE))
  :documentation "Return the fully qualified name of `variable'."
  :public? TRUE :c-callable? TRUE
  (return (get-name-in-module (variable-name variable) *root-module* NULL)))

(defun (get-variable-short-name STRING) ((variable PATTERN-VARIABLE))
  :documentation "Return the unqualified name of `variable'."
  :public? TRUE :c-callable? TRUE
  (return (symbol-name (variable-name variable))))


(defun (object-to-string STRING) ((self OBJECT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return a printed representation of the term `self' as a string."
  (if (null? self)
    (return NULL)
    (special ((*printReadably?* TRUE))
      (typecase self
        (STRING-WRAPPER
         (return (wrapper-value self)))
	(SKOLEM 
	 (let ((value (value-of self)))
	   (if (eql? value self)
	     (return (stringify self))
	     (return (object-to-string value)))))
	(PL-ITERATOR
	 (return (stringify (consify self))))
	(otherwise (return (stringify self)))))))

(defun (object-to-integer INTEGER) ((self OBJECT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation
  "Coerce `self' to an integer, or throw a Stella Exception if the coersion is not feasible.
Floating point values will be coerced by rounding."
  (typecase self
    (SKOLEM 
     (let ((value (value-of self)))
       (if (eql? value self)
	 (signal STELLA-EXCEPTION "Can't coerce " self " to an integer.")
	 (return (object-to-integer value)))))
    (INTEGER-WRAPPER (return self))
    (FLOAT-WRAPPER (return (round (wrapper-value self))))
    (otherwise 
     (signal STELLA-EXCEPTION "Can't coerce " self " to an integer."))))

(defun (object-to-float FLOAT) ((self OBJECT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation
  "Coerce `self' to a float, or throw a Stella Exception if the coersion is not feasible."
  (typecase self
    (SKOLEM 
     (let ((value (value-of self)))
       (if (eql? value self)
	 (signal STELLA-EXCEPTION "Can't coerce " self " to a float.")
	 (return (object-to-float value)))))
    (INTEGER-WRAPPER (return self))
    (FLOAT-WRAPPER (return self))
    (otherwise 
     (signal STELLA-EXCEPTION "Can't coerce " self " to a float."))))

(defun (object-to-parsable-string STRING) ((self OBJECT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return a string representing a printed
representation of the object `self'.  Like `object-to-string', but puts
escaped double quotes around strings."
  (typecase self
    (STRING-WRAPPER
     (return (concatenate "\"" self "\"")))
    (otherwise
     (return (object-to-string self)))))

(defun (get-stella-type SYMBOL) ((self OBJECT))
  :documentation "Return the name symbol of the STELLA class of which `self' is a direct instance."
  :public? TRUE :c-callable? TRUE
  (return (type-to-symbol (primary-type self))))

(defun (get-logic-type SYMBOL) ((self OBJECT))
  :documentation "Return the name symbol of the logic object type of `self'.  This type describes the basic
role this object plays in the logic system such as 'PROPOSITION', 'CONCEPT', 'THING', etc., as indicated by
its native object type, it does not have anything to do with type propositions asserted about `self'."
  :public? TRUE :c-callable? TRUE
  (return (type-to-symbol (logical-type self))))

;;; We explicitly implement these for efficiency, even though one can also call `get-name' on the type symbol:

(defun (get-stella-type-name STRING) ((self OBJECT))
  :documentation "Return the qualified name of the STELLA class of which `self' is a direct instance."
  :public? TRUE :c-callable? TRUE
  (let ((type (primary-type self)))
    (return (compute-full-name (symbol-name type) (interned-in type)))))

(defun (get-stella-type-short-name STRING) ((self OBJECT))
  :documentation "Return the unqualified name of the STELLA class of which `self' is a direct instance."
  :public? TRUE :c-callable? TRUE
  (return (symbol-name (primary-type self))))

(defun (get-logic-type-name STRING) ((self OBJECT))
  :documentation "Return the qualified name of the logic type of `self'."
  :public? TRUE :c-callable? TRUE
  (let ((type (logical-type self)))
    (return (compute-full-name (symbol-name type) (interned-in type)))))

(defun (get-logic-type-short-name STRING) ((self OBJECT))
  :documentation "Return the unqualified name of the logic type of `self'."
  :public? TRUE :c-callable? TRUE
  (return (symbol-name (logical-type self))))


;;; TO DO: Implement this:
;;; Note that this is different from (string-search-for-object string type)
;;; because the `type' here is a logic object, not a stella type! 
;;;
;;; Bob's intent was to use the type to help decide how to interpret the
;;; argument string, so that for example "foo" would be treated as an
;;; object of type STRING (or perhaps STRING-WRAPPER ?) if the type argument
;;; indicated that, whereas if type were Person, it would be treated as
;;; a logic object.
;;;

(defglobal *literal-concept* NAMED-DESCRIPTION NULL
  :public? FALSE)
(defglobal *string-concept* NAMED-DESCRIPTION NULL
  :public? FALSE)
(defglobal *integer-concept* NAMED-DESCRIPTION NULL
  :public? FALSE)
(defglobal *float-concept* NAMED-DESCRIPTION NULL
  :public? FALSE)

(startup-time-progn :final
  (setq *literal-concept* (s-get-concept "LITERAL" "PL-USER" NULL))
  (setq *string-concept*  (s-get-concept "STRING" "PL-USER" NULL))
  (setq *integer-concept* (s-get-concept "INTEGER" "PL-USER" NULL))
  (setq *float-concept*   (s-get-concept "FLOAT" "PL-USER" NULL)))


(defun (string-to-object OBJECT) 
    ((string STRING) (type LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Evaluate `string' with respect to `module' and `environment'
and return the corresponding logical term.  `type' is a concept used to assist the
correct interpretation of `string'.

Currently `type' only has an effect on the interpretation of literal types."
  (with-logic-environment module environment
    (setq module *module*) 
    (let ((obj (unstringify string)))
      (typecase obj
	(LITERAL-WRAPPER
	 (when (null? type)
	   (return obj))
	 (typecase obj
	   (STRING-WRAPPER
	    (if (subrelation-of? type *string-concept*)
	      (return obj)
	      (signal PARSING-ERROR "String argument found, but " type " is not a subconcept of " *string-concept*)))
	   (INTEGER-WRAPPER
	    (cond ((subrelation-of? type *integer-concept*)
		   (return obj))
		  ((subrelation-of? type *float-concept*)
		   (return (cast (wrapper-value obj) FLOAT)))
		  (otherwise
		   (return (get-object string module environment)))))
	   (FLOAT-WRAPPER
	    (cond ((subrelation-of? type *float-concept*)
		   (return obj))
		  (otherwise 
		   (return (get-object string module environment)))))))
	(otherwise
	 (cond ((null? type)
		(return (get-object string module environment)))
	       ((subrelation-of? type *string-concept*)
		(return (copy string))) ;; copy to avoid GC problems
	       ((subrelation-of? type *literal-concept*)
		(signal PARSING-ERROR string " is a non-literal, but " type " is a subconcept of " *literal-concept*))
	       (otherwise
		(return (get-object string module environment)))))))))

(defun (string-to-stella-expression OBJECT) ((expression STRING) (module MODULE) (environment ENVIRONMENT))
  :documentation "Read the STELLA `expression' in `module' and return the result.
Raises a reader exception in case of incorrect STELLA syntax."
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  (with-logic-environment module environment
    (return (unstringify expression))))


  ;;
;;;;;; Retrieval
  ;;

#|
;; syntax games - these are not all valid examples:
(get-nth-string (retrieve "(?y)" "(age Fred ?y)" *module* NULL) 1 *module* NULL)
v.
(get-nth-string (retrieve "(age ?x ?y)" "(= ?x Fred)" *module* NULL) 2)*module* NULL
v.
(get-nth-string (retrieve "(age Fred ?y)" "TRUE" *module* NULL) 2 *module* NULL)
v.
(get-nth-string (parametric-retrieve "(age ?x ?y)" "TRUE" (list "Fred" NULL) *module* NULL)
                2 *module* NULL)
v.
(get-nth-string (parametric-retrieve "(?x ?y)" "(age ?x ?y)" (list "Fred" NULL) *module* NULL)
                2 *module* NULL)
v.
(get-nth-string (s-get-proposition "(age Fred null)" *module* NULL) 2 *module* NULL)
v.
(get-nth-string (s-get-propositions "(age Fred null)" *module* NULL) 2 *module* NULL)
v.
(get-nth-string (get-binary-proposition
                 (get-relation "age") (get-object "Fred") NULL *module* NULL)
                2 *module* NULL)
|#

(defun (help-get-true-extension-members (CONS OF PROPOSITION)) 
       ((relation NAMED-DESCRIPTION) (specialize? BOOLEAN))
  :public? FALSE
  ;; Return the asserted extension of `relation'.
  ;; TO DO: REWRITE AS AN ITERATOR?
  (let ((result (collect p in (all-extension-members relation)
                         where (true-proposition? p))))
    (when specialize?
      (foreach sub in (all-subcollections relation)
          ;; Needed because all-extension-members is only defined on named-descriptions
	  where (isa? sub @NAMED-DESCRIPTION)
	  do (foreach p in (all-extension-members sub)
		 where (true-proposition? p)
		 do (pushq result p)))
      (return (remove-duplicates result)))
    (return result)))

(defun (help-get-propositions (CONS OF PROPOSITION))
       ((relation LOGIC-OBJECT) (arguments CONS) (limit INTEGER)
        (module MODULE) (environment ENVIRONMENT))
  ;; Retrieve asserted propositions with relation `relation' and arguments matching
  ;;    the bound members of `arguments'.  Retrieve at most `limit' propositions
  ;;    (zero or negative `limit' represents no bound).  If the current environment
  ;;    implies subsumption, also retrieve propositions whose relation implies `relation'.
  ;; This will not retrieve implicit or computed propositions such as `arity' or `+'.
  ;; This does not yet gracefully handle function propositions which are represented
  ;;    by a function term proposition and an equivalence linking that to a value.
  ;; Called by other API routines.
  ;; TO DO: - handle function terms, possibly use `select-relation-propositions'
  ;;        - think about what to do about negated propositions
  :public? FALSE
  (when (null? relation)
    (return NIL))
  (with-logic-environment module environment
    ;; Note: by default, all PLI routines should use the same environment as
    ;;       `test-isa?' unless we only want to look at explicit assertions.
    (let ((assertionsOnly? (test-environment-level? environment "ASSERTION"))
          (specialize? (not assertionsOnly?))
          (argumentWithBacklinks (some arg in arguments
                                       where (and (defined? arg)
                                                  (isa? arg @LOGIC-OBJECT))))
          (iterator (choose (defined? argumentWithBacklinks)
                            (all-true-dependent-propositions
                             argumentWithBacklinks (surrogate-value-inverse relation) specialize?)
                            (allocate-iterator
                             (help-get-true-extension-members relation specialize?))))
          (results NIL))
      (unless assertionsOnly?
        (setq *context* (get-property-test-context)))
      (foreach p in iterator
               where (and (forall inputArg in arguments
                                  as arg2 in (arguments p)
                                  always (or (null? inputArg)
                                             (eql? inputArg (value-of arg2))))
                          (eql? (length arguments)
                                (length (arguments p))))
               do 
               (pushq results p)
               (-- limit)
               (when (eql? limit 0)
                 (break)))
      (return results))))
    
(defun (get-proposition PROPOSITION)
       ((relation-and-arguments OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return a proposition matching `relation-and-arguments' that
has been asserted (or inferred by forward chaining).  `relation-and-arguments'
is a sequence containing objects and nulls.  The first argument must be the
name of a relation.  A null value acts like a wild card.  If more than one 
proposition matches the input criteria, the selection among satisficing
propositions is arbitrary.  This procedure is normally applied to single-valued
relations or functions."
  (let ((list (sequence-to-cons-list relation-and-arguments))
        (relation (first list))
        (arguments (rest list)))
    (return (first (help-get-propositions
                    relation arguments 1 module environment)))))

(defun (s-get-proposition PROPOSITION)
       ((relation-and-arguments STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return a proposition matching `relation-and-arguments' that
has been asserted (or inferred by forward chaining).  `relation-and-arguments'
is a string that begins with a left parenthesis, followed by a relation name, 
one or more argument identifiers, and terminated by a right parenthesis.  Each
argument identifier can be the name of a logical constant, a literal reference
such as a number, or the null identifier which acts like a wild card.
If more than one proposition matches the input criteria, the selection among
satisficing propositions is arbitrary.  This procedure is normally applied to
single-valued relations or functions.

A module name of `null' or the empty string refers to the current module.  If no module
with name `module-name' can be found, a STELLA `no-such-context-exception' is thrown."
  (let ((module (safely-get-module module-name environment))
        (elements (explode-string-list relation-and-arguments module))
        (relation (first elements))
        (arguments (rest elements)))
    (return (first (help-get-propositions relation arguments 1 module environment)))))

(defun (get-propositions (PL-ITERATOR OF PROPOSITION))
       ((relation-and-arguments OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return propositions matching `relation-and-arguments' that
have been asserted (or inferred by forward chaining).  `relation-and-arguments'
is a sequence containing objects and nulls.  The first argument must be the
name of a relation.  A null value acts like a wild card."
  (let ((list (sequence-to-cons-list relation-and-arguments))
        (relation (first list))
        (arguments (rest list)))
    (return (cons-to-pl-iterator
             (help-get-propositions relation arguments 0 module environment)))))

(defun (s-get-propositions (PL-ITERATOR OF PROPOSITION))
       ((relation-and-arguments STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return propositions matching `relation-and-arguments' that
have been asserted (or inferred by forward chaining).  `relation-and-arguments'
is a string that begins with a left parenthesis, followed by a relation name, 
one or more argument identifiers, and terminated by a right parenthesis.  Each
argument identifier can be the name of a logical constant, a literal 
reference (e.g., a number), or the null identifier which acts like a wild card.

A module name of `null' or the empty string refers to the current module.  If no module
with name `module-name' can be found, a STELLA `no-such-context-exception' is thrown."
  (let ((module (safely-get-module module-name environment))
        (elements (explode-string-list relation-and-arguments module))
        (relation (first elements))
        (arguments (rest elements)))
    (return (cons-to-pl-iterator (help-get-propositions relation arguments 0 module environment)))))


(defun (get-inconsistent-propositions (PL-ITERATOR OF PROPOSITION))
       ((module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return inconsistent propositions visible in `module'."
  (with-logic-environment module environment
    (setq module *module*) 
    (return (iterator-to-pl-iterator (all-inconsistent-propositions module FALSE)))))


(defun (get-unary-propositions (PL-ITERATOR OF PROPOSITION))
       ((relation LOGIC-OBJECT) (arg OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return propositions such that (`relation' `arg')
is true.  The `relation' argument must be bound to a relation.  `arg' may be
set to NULL, which is interpreted as a wildcard."
  (return (cons-to-pl-iterator
           (help-get-propositions 
            relation (cons-list arg) 0 module environment))))

(defun (get-binary-proposition PROPOSITION)
       ((relation LOGIC-OBJECT) (arg1 OBJECT) (arg2 OBJECT)
        (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return a proposition such that (`relation' `arg1' `arg2')
is true.  The `relation' argument must be bound to a relation.  One or both
of the `arg1' and `arg2' arguments may be set to NULL, which is interpreted
as a wildcard. If more than one proposition matches the input criteria,
the selection is arbitrary.  This procedure is normally applied to single-valued
relations or functions."
  ;; Instead of calling `help-get-propositions' immediately, a bit of extra
  ;;    code results in a small speedup.  If and when `help-get-propositions'
  ;;    is rewritten to return an iterator, the speed-up may be greater.
  (return (first (help-get-propositions relation (cons-list arg1 arg2) 1 module environment))))

(defun (get-binary-propositions (PL-ITERATOR OF PROPOSITION))
       ((relation LOGIC-OBJECT) (arg1 OBJECT) (arg2 OBJECT)
        (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return propositions such that (`relation' `arg1' `arg2')
is true.  The `relation' argument must be bound to a relation.  One or both
of the `arg1' and `arg2' arguments may be set to NULL, which is interpreted
as a wildcard."
  (return (cons-to-pl-iterator
           (help-get-propositions 
            relation (cons-list arg1 arg2) 0 module environment))))

(defun (get-inferred-binary-proposition-values PL-ITERATOR)
       ((relation LOGIC-OBJECT) (arg OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return all values `v' such that (`relation' `arg' `v')
has been asserted or can be inferred via a general PowerLoom `retrieve'.
Both `relation' and `arg' have to be non-NULL."
  (with-logic-environment module environment
    (if (all-defined? relation arg)
        (return (cons-to-pl-iterator
                 (apply-retrieve (?r ?i ?v) (?r ?i ?v) (relation arg NULL))))
        (return EMPTY-PL-ITERATOR))))

(defun (s-get-inferred-binary-proposition-values PL-ITERATOR)
       ((relation-name STRING) (arg-name STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return all values `v' such that (`relation-name' `arg-name' `v')
has been asserted or can be inferred via a general PowerLoom `retrieve'.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a STELLA
`no-such-context-exception' is thrown."
  (let ((module (safely-get-module module-name environment))
        (relation (safely-get-relation relation-name module environment))
        (object (safely-get-object arg-name module environment)))
    (return (get-inferred-binary-proposition-values relation object module environment))))

(defun (get-propositions-of (PL-ITERATOR OF PROPOSITION)) 
       ((object LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return all propositions that have `object' among their arguments,
and that are TRUE in the scope of the module `module'."
  (with-logic-environment module environment
    (if (defined? object)
        (return (list-to-pl-iterator (all-facts-of-instance object FALSE FALSE)))
        (return EMPTY-PL-ITERATOR))))

(defun (s-get-propositions-of (PL-ITERATOR OF PROPOSITION))
       ((object-name STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return all propositions that have the object named `object-name' among
their arguments, and that are TRUE in the scope of the module `module-name'.
A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown."
  (let ((module (safely-get-module module-name environment))
        (object (safely-get-object object-name module environment)))
    (return (get-propositions-of object module environment))))

(defun (get-propositions-in-module (PL-ITERATOR OF PROPOSITION))
       ((module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return propositions that have been locally conceived in
the module `module' (but are not necessarily true)."
  (with-logic-environment module environment
    (setq module *module*) 
    (return (cons-to-pl-iterator 
             (consify (all-propositions module TRUE))))))


  ;;
;;;;;; Probes
  ;;

(defun (is-true-unary-proposition BOOLEAN)
       ((relation LOGIC-OBJECT) (arg OBJECT) (module MODULE) (environment ENVIRONMENT))
  :documentation "Return TRUE if the proposition (`relation' `arg') has
been asserted (or inferred by forward chaining)."
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  (return (non-empty? (help-get-propositions relation (cons-list arg) 1 module environment))))

(defun (is-true-binary-proposition BOOLEAN)
       ((relation LOGIC-OBJECT) (arg OBJECT) (value OBJECT) (module MODULE) (environment ENVIRONMENT))
  :documentation "Return TRUE if the proposition (`relation' `arg' `value') has
been asserted (or inferred by forward chaining)."
  :public? TRUE :c-callable? TRUE
  (return (defined? (get-binary-proposition relation arg value module environment))))

(defun (is-true-nary-proposition BOOLEAN) 
       ((relation-and-arguments OBJECT) (module MODULE) (environment ENVIRONMENT))
  :documentation "Return TRUE if a proposition (`relation' `args') has
been asserted (or inferred by forward chaining)."
  :public? TRUE :c-callable? TRUE
  (return (defined? (get-proposition relation-and-arguments module environment))))

(defun (s-is-true-nary-proposition BOOLEAN)
       ((relation-and-arguments STRING) (module-name STRING) (environment ENVIRONMENT))
  :documentation "Return TRUE if a proposition that prints as the string
`relation-and-arguments' is true in the module named `module-name'.
A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown."
  :public? TRUE :c-callable? TRUE
  (return (defined? (s-get-proposition relation-and-arguments module-name environment))))

(defun (is-true-proposition BOOLEAN)
       ((proposition PROPOSITION) (module MODULE) (environment ENVIRONMENT))
  :documentation "Return TRUE if `proposition' is TRUE in the module `module'."
  :public? TRUE :c-callable? TRUE
  (with-logic-environment module environment
    (return (true-proposition? proposition))))


  ;;
;;;;;; Isa and Subsumption Hierarchies
  ;;

(defun (is-subrelation BOOLEAN)
       ((sub LOGIC-OBJECT) (super LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return TRUE if `sub' is a subconcept/subrelation of `super'."
  (when (or (null? sub) (null? super))
    (return FALSE))
  (with-logic-environment module environment
    (return
      (true-truth-value? (description-specializes-description? sub super)))))

(defun (get-proper-subrelations (PL-ITERATOR OF LOGIC-OBJECT))
       ((relation LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return relations that specialize `relation'.
Non-reflexive."
  (with-logic-environment module environment
    (return (cons-to-pl-iterator (all-subrelations relation TRUE)))))

(defun (get-direct-subrelations (PL-ITERATOR OF LOGIC-OBJECT))
       ((relation LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return relations that directly specialize `relation'.
Non-reflexive."
  (with-logic-environment module environment
    (return (cons-to-pl-iterator (all-direct-subrelations relation TRUE)))))

(defun (get-proper-superrelations (PL-ITERATOR OF LOGIC-OBJECT))
       ((relation LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return relations that generalize `relation'.
Non-reflexive."
  (with-logic-environment module environment
    (return (cons-to-pl-iterator (all-superrelations relation TRUE)))))

(defun (get-direct-superrelations (PL-ITERATOR OF LOGIC-OBJECT))
       ((relation LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return relations that directly generalize `relation'.
Non-reflexive."
  (with-logic-environment module environment
    (return (cons-to-pl-iterator (all-direct-superrelations relation TRUE)))))

(defun (is-instance BOOLEAN) ((object OBJECT) (concept LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :documentation "Return TRUE if `object' is an instance of the concept `concept'.  This uses subsumption inference only."
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  (with-logic-environment module environment
    (return (test-isa? object (surrogate-value-inverse concept)))))

(defun (is-a BOOLEAN) ((object OBJECT) (concept LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :documentation "Deprecated - use `is-instance' instead."
  :public? TRUE
  (return (is-instance object concept module environment)))

(defun (get-concept-instances PL-ITERATOR)
       ((concept LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return instances of the concept `concept'.
Include instances of subconcepts of `concept'.  Depending on `concept',
the return values could be (wrapped) literals."
  (with-logic-environment module environment
    (setq module *module*) 
    (if (test-environment-level? environment "ASSERTION")
      (return 
       (list-to-pl-iterator 
        (remove-deleted-members (asserted-collection-members concept FALSE))))
      (return
       (retrieve (bquote (all ?x (& (object-name concept) ?x))) module environment)))))

(defun (s-get-concept-instances PL-ITERATOR)
       ((concept-name STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return instances of concept `concept-name'.
Include instances of subconcepts of `concept-name'.  Depending on `concept-name',
the return values could be (wrapped) literals.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown."
  (let ((module (safely-get-module module-name environment))
        (concept (safely-get-concept concept-name module environment)))
    (if (all-defined? module concept)
      (return (get-concept-instances concept module environment))
      (return EMPTY-PL-ITERATOR))))

(defun (get-direct-concept-instances PL-ITERATOR)
       ((concept LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return instances of concept `concept'.
Exclude instances of subconcepts of `concept'.  Depending on `concept',
the return values could be (wrapped) literals."
  (with-logic-environment module environment
    (setq module *module*) 
    (if (test-environment-level? environment "ASSERTION")
      (return 
       (list-to-pl-iterator 
        (remove-deleted-members (asserted-collection-members concept TRUE))))
      (return
       (retrieve (bquote (all ?x (/LOGIC/AND (& (object-name concept) ?x)
                                             (/LOGIC/FAIL
                                              (LOGIC/EXISTS (?y)
                                                (/LOGIC/AND (PROPER-SUBRELATION & (object-name concept) ?Y)
                                                            (?Y ?X)))))))
                 module environment)))))

(defun (s-get-direct-concept-instances PL-ITERATOR)
       ((concept-name STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return instances of concept `concept-name'.
Exclude instances of subconcepts of `concept-name'.  Depending on `concept-name',
the return values could be (wrapped) literals.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown."
  (let ((module (safely-get-module module-name environment))
        (concept (safely-get-concept concept-name module environment)))
    (if (all-defined? concept)
      (return (get-direct-concept-instances concept module environment))
      (return EMPTY-PL-ITERATOR)) ))

(defun (get-concept-instances-matching-value PL-ITERATOR)
       ((concept LOGIC-OBJECT) (relation LOGIC-OBJECT) (value OBJECT)
        (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return members of concept `concept' that
have an attribute matching `value' for the binary relation `relation', i.e.,
`(relation <result> value)' holds."
  (with-logic-environment module environment
    (setq module *module*) 
    (let ((instances (get-concept-instances concept module environment))
          (answers NIL))
      (foreach i in instances
               where (is-true-binary-proposition relation i value module environment)
               do (pushq answers i))
      (return (cons-to-pl-iterator answers)))))

(defun (get-concept-instance-matching-value OBJECT)
       ((concept LOGIC-OBJECT) (relation LOGIC-OBJECT) (value OBJECT)
        (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return a member of concept `concept' that
has an attribute matching `value' for the binary relation `relation', i.e.,
`(relation <result> value)' holds."
  (with-logic-environment module environment
    (setq module *module*) 
    (let ((instances (get-concept-instances concept module environment)))
      (foreach i in instances
               where (is-true-binary-proposition relation i value module environment)
               do (return i))
      (return NULL))))

#|
;; What about?
(defun (get-types (PL-ITERATOR OF LOGIC-OBJECT))
       ((object LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :documentation "Return all named concepts that `object' belongs to."
  (with-logic-environment module environment
     (return (cons-to-pl-iterator (all-types object)))))

(defun (get-types (PL-ITERATOR OF LOGIC-OBJECT))
       ((object LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :documentation "Return all named concepts that `object' belongs to."
  (with-logic-environment module environment
    (return (cons-to-pl-iterator (all-direct-types object)))))

(defun (get-types (PL-ITERATOR OF LOGIC-OBJECT))
       ((object LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return all named concepts that `object' belongs to."
  (let ((directTypes (get-direct-types object module environment))
        (types NIL))
    (foreach d in directTypes
             do
             (when (not (member? types d))
               (pushq types d))
             (foreach c in (all-supercollections d)
                      where (isa? c @NAMED-DESCRIPTION)
                      do
                      (when (not (member? types c))
                        (pushq types c))))
    (return (cons-to-pl-iterator types))))
|#

(defun (help-get-types (CONS OF LOGIC-OBJECT))
    ((object LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? FALSE
  (with-logic-environment module environment
    (let ((derivableTypes NIL))
      (cond ((or (null? environment)
		 (test-environment-level? environment "INFERENCE"))
	     (setq derivableTypes (all-types object)))
	    ((test-environment-level? environment "ASSERTION")
	     (setq derivableTypes (all-asserted-types object)))
	    ((test-environment-level? environment "TAXONOMIC")
	     (setq derivableTypes (all-taxonomic-types object))))
      (return derivableTypes))))  

(defun (get-types (PL-ITERATOR OF LOGIC-OBJECT))
       ((object LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return all named concepts that `object' belongs to."
  (return (cons-to-pl-iterator (help-get-types object module environment))))

(defun (get-direct-types (PL-ITERATOR OF LOGIC-OBJECT))
       ((object LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return most specific concepts that `object' belongs to."
  (return (cons-to-pl-iterator 
           (most-specific-named-descriptions
            (copy-cons-list
             (help-get-types object module environment))))))

(defun (get-relation-extension (PL-ITERATOR OF PROPOSITION))
       ((relation LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :documentation "Return propositions that satisfy `relation'.
Include propositions that satisfy subrelations of `relation'."
  :public? TRUE :c-callable? TRUE
  (with-logic-environment module environment
    (return (cons-to-pl-iterator
             (help-get-true-extension-members
              relation (not (test-environment-level? environment "ASSERTION")))))))

(defun (s-get-relation-extension (PL-ITERATOR OF PROPOSITION))
       ((relation-name STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return propositions that satisfy the relation named
`relation-name'.  Include propositions that satisfy subrelations of the relation."
  (let ((module (safely-get-module module-name environment))
        (relation (safely-get-relation relation-name module environment)))
    (if (defined? relation)
      (return (get-relation-extension relation module environment))
      (return EMPTY-PL-ITERATOR))))


  ;;
;;;;;; Modules
  ;;

(defun (get-module MODULE) ((name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return a module named `name' or NULL if no such module exists."
  (ignore environment)
  (return (get-stella-module name FALSE)))

(defun (get-existing-module MODULE) ((name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return the module named `name' or raise a STELLA `no-such-context-exception' if it doesn't exist."
  (ignore environment)
  (return (get-stella-module name TRUE)))

(defun (get-current-module MODULE) ((environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return the currently set module"
  (ignore environment)
  (return *module*))

(defun (get-home-module MODULE) ((object LOGIC-OBJECT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return the module in which `object' was created."
  (return (home-module object)))

(defun (get-modules (PL-ITERATOR OF MODULE)) ((kb-modules-only? BOOLEAN))
  :public? TRUE :c-callable? TRUE
  :documentation "Return all modules currently loaded into PowerLoom.  If `kb-modules-only?'
is `true', then Stella modules that are used only for program code are
not included in the list."
  (return (cons-to-pl-iterator (list-modules kb-modules-only?))))

(defun (create-module MODULE) ((name STRING) (parent MODULE) (case-sensitive? BOOLEAN))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Creates a new module `name' as a child of `parent'.  The flag
`case-sensitive?' controls whether names read in this module will be
case sensitive or not."
  (let ((full-name (choose (defined? parent)
                           (concatenate (module-full-name parent) "/" name)
                           name))
        (case-sensitive-symbol (choose case-sensitive? (quote TRUE) (quote FALSE))))
    (return
     (define-module full-name (bquote (:case-sensitive? & case-sensitive-symbol))))))

(defun (s-create-module MODULE) ((name STRING) (parent-name STRING) (case-sensitive? BOOLEAN)
                                 (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Creates a new module `name' as a child of `parent-name'.  The flag
`case-sensitive?' controls whether names read in this module will be
case sensitive or not."
  (return
   (create-module name (safely-get-module parent-name environment) case-sensitive?)))

(defun (change-module MODULE) ((module MODULE))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Set the current module to `module' and return it.
If `module' is `null', then no switch is performed and the current
module is returned."
  (when (null? module)
    (return *module*))
  (return (LOGIC/change-module module)))

(defun (s-change-module MODULE) ((name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Set the current module to the module named `name'.
The return value is the module named `name' unless `name' is null or
the empty string.  In that case, the current module is returned.
If no module named `name' exists, a Stella `no-such-context-exception'
is thrown."
  (return (change-module (safely-get-module name environment))))

(defun (clear-module MODULE) ((module MODULE))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Destroy the contents of the module `module' as well as
the contents of all of its children, recursively."
  (call-clear-module module)
  (return module))

(defun (s-clear-module MODULE) ((name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Destroy the contents of the module named `name', as
well as the contents of all of its children, recursively.  If no module
named `name' exists, a Stella `no-such-context-exception' is thrown."
  (let ((module (safely-get-module name environment)))
    (call-clear-module module)
    (return module)))

(defun (get-child-modules (PL-ITERATOR OF MODULE)) ((module MODULE))
  :public? TRUE :c-callable? TRUE
  :documentation "Return the modules that are immediate children of `module'."
  (let ((directSubModules NIL))
    ;; Filter out non-modules:
    (foreach child in (child-contexts module)
	where (isa? child @MODULE)
	collect child into directSubModules)
    (return (cons-to-pl-iterator directSubModules)) ))

(defun (s-get-child-modules (PL-ITERATOR OF MODULE)) 
    ((name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return the modules that are immediate children of module `name'.
If no module named `name' exists, a Stella `no-such-context-exception'
is thrown."
  (return (get-child-modules (safely-get-module name environment))))

(defun (get-parent-modules (PL-ITERATOR OF MODULE)) ((module MODULE))
  :public? TRUE :c-callable? TRUE
  :documentation "Return the modules that are immediate parents of `module'."
  (return (list-to-pl-iterator (parent-modules module))))

(defun (s-get-parent-modules (PL-ITERATOR OF MODULE))
 ((name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return the modules that are immediate parents of module `name'.
If no module named `name' exists, a Stella `no-such-context-exception'
is thrown."
  (return (get-parent-modules (safely-get-module name environment))))

(defun (generate-unique-name STRING) ((prefix STRING) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation "Generates a name based on `prefix' with a number appended that
is not currently in use in `module.'  In a non-case-sensitive module, the returned
name will be all upper case (This latter feature may change!)"
  (with-logic-environment module environment
    (setq module *module*) 
    (unless (or (case-sensitive? module)
                (all-upper-case-string? prefix))
        (setq prefix (string-upcase prefix)))
    (return (yield-unique-gensym-name prefix module))))
 

  ;;
;;;;;; Update
  ;;

(defun (create-keyword KEYWORD) ((name STRING))
  :public? TRUE :c-callable? TRUE
  :documentation "Returns the Stella keyword `name', creating it if
necessary.  `name' is treated literally and case-sensitively.
This should generally not be necessary to do."
  (return (intern-rigid-symbol-wrt-module name *module* KEYWORD-SYM)))

(defun (create-symbol SYMBOL) ((name STRING) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation "Returns the Stella symbol `name' visible in `module',
creating it if necessary.  `name' is treated literally and ALWAYS case-sensitively,
even if `module' is case insensitive. This should generally not be necessary to do."
  (with-logic-environment module environment
    (setq module *module*) 
    (return (intern-symbol-in-module name module FALSE))))

(defun (create-object LOGIC-OBJECT) 
    ((name STRING) (concept LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Create an object named `name' of type `concept' in the designated
module.  Both `name' and `concept' can be `null'.  If `name' is `null' then an
object will be created with a new, non-conflicting name based on the name of
`concept', or system-generated if no concept is specified.  If `concept' is
`null', then the object will be of type THING.  It is an error to create an
object with the same name as an existing object.

Note that the string can be a qualified name, in which case the object
will be created in the module specified, but with a name as determined
by the qualified name.  Vertical bars in the name string are interpreted
as Stella escape characters.

Note that because names in modules that are not case-sensitive are
canonicalized, the name of the returned object may not match `name'
exactly.

Return the object."
  (with-logic-environment module environment
    (setq module *module*) 
    (let ((object LOGiC-OBJECT null)
          (name-symbol SYMBOL null)
          (object-surrogate SURROGATE null))
      (cond ((defined? name)
             (setq name-symbol (intern-stella-name name)))
            ((defined? concept)
             ;; Use this temporarily to get the appropriate modules.
             (setq name-symbol (get-short-name concept))
             (setq name-symbol (intern-symbol-in-module 
                                (generate-unique-name (symbol-name name-symbol)
                                                      (home-context name-symbol)
                                                      NULL)
                                (home-context name-symbol)
                                TRUE)))
            (otherwise
             (setq name-symbol (intern-symbol-in-module 
                                (generate-unique-name "I" null null)
                                module
                                TRUE))))
      (setq object-surrogate (lookup-surrogate-in-module (symbol-name name-symbol)
                                                         (home-context name-symbol)
                                                         FALSE))
      (when (null? object-surrogate)
        (setq object-surrogate (intern-surrogate-in-module (symbol-name name-symbol)
                                                           (home-context name-symbol)
                                                           FALSE)))
      (setq object (help-create-logic-instance object-surrogate NULL))
      (when (defined? concept)
        (if (defined? (assert-unary-proposition concept object module environment))
            (return object)
          (return NULL)))
      (return object) )))

(defun (s-create-object LOGIC-OBJECT)
 ((name STRING) (concept-name STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Create an object named `name' of type `concept-name' in the designated
module.  Both `name' and `concept-name' can be null strings.  If `name' is a null string
then an object will be created with a new, non-conflicting name based on `concept-name', or
system-generated if no concept nameis specified.  If `concept-name' is the null string, then
the object will be of type THING.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly.

Return the object."
  (let ((module (safely-get-module module-name environment)))
    (return 
     (create-object name 
                    (safely-get-concept concept-name module environment)
                    module
                    environment)) ))

(defun (create-concept LOGIC-OBJECT) ((name STRING) (parent LOGIC-OBJECT)
				      (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation
  "Create a concept named `name' in the designated `module', with the
designated `parent' superconcept (which can be left undefined).  Additional
superconcepts can be added via assertions of the `subset-of' relation.  Note
that a specified `parent' concept needs to be created separately.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly."
  (with-logic-environment module environment
    (return 
      (call-defconcept
       (bquote (& (intern-stella-name name)
                  && (choose (defined? parent)
                             (bquote (:subset-of & (object-name parent)))
                             NIL)))))))

(defun (s-create-concept LOGIC-OBJECT) ((name STRING) (parent-name STRING) 
					(module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation
  "Create a concept named `name' in the designated module, with
with the concept named `parent-name' as superconcept (which can be left
undefined).  Additional superconcepts can be added via assertions of the
`subset-of' relation.  Note that a specified parent concept needs to be
created separately.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly."
  (let ((module (safely-get-module module-name environment)))
    (return 
      (create-concept name
		      (safely-get-concept parent-name module environment)
		      module
		      environment))))

(defun (create-relation LOGIC-OBJECT) ((name STRING) (arity INTEGER)
				       (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Create a relation named `name' with arity `arity' in the
designated module.  Domain and range information can be added via assertions
of `nth-domain' (or `domain' and `range') relations.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly."
  (unless (> arity 0)
    (signal-parsing-error "Relations must have arity of at least 1"))
  (let ((args NIL))
    (with-logic-environment module environment
      (setq module *module*) 
      (foreach i in (interval 0 (1- arity))
          collect (yield-system-defined-parameter-name i module)
          into args)
      (return
        (call-defrelation (bquote (& (intern-stella-name name) & args)))))))

(defun (s-create-relation LOGIC-OBJECT) ((name STRING) (arity INTEGER) 
                                         (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Create a relation named `name' with arity `arity' in the
designated module.  Domain and range information can be added via assertions
of `nth-domain' (or `domain' and `range') relations.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly."
  (return 
    (create-relation name arity
                     (safely-get-module module-name environment)
                     environment)))

(defun (create-function LOGIC-OBJECT) ((name STRING) (arity INTEGER)
				       (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation
  "Create a function named `name' with arity `arity'  in the designated 
`module'.  Domain and range information can be added via assertions of
`nth-domain' (or `domain' and `range') relations.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly."
  (unless (> arity 0)
    (signal-parsing-error "Functions must have arity of at least 1"))
  (let ((args NIL))
    (with-logic-environment module environment
      (setq module *module*) 
      (foreach i in (interval 0 (1- arity))
          collect (yield-system-defined-parameter-name i module)
          into args)
      (return
        (call-deffunction (bquote (& (intern-stella-name name) & args)))))))

(defun (s-create-function LOGIC-OBJECT) ((name STRING) (arity INTEGER) 
                                         (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation
  "Create a function named `name' with arity `arity' in the designated 
module.  Domain and range information can be added via assertions of
`domain', `nth-domain' and `range' relations.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly."
  (return 
    (create-function name arity
                     (safely-get-module module-name environment)
                     environment)))

(defun register-specialist-function ((name STRING) (function-reference FUNCTION-CODE)
                                     (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation
  "Register `name' as a function name in `module' which will invoke the
native code procedure described by `function-reference.'  The `name'
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The function must conform
to the signature for specialist functions.

The exact form of `function-reference' depends on the underlying
programming language.  The following type mappings are used:
          C++:  
  Common Lisp:  FUNCTION   (result of #' or (FUNCTION ...))
         Java:  java.lang.reflect.Method"
  (with-logic-environment module environment
    (/logic/register-specialist-function name function-reference)))

(defun s-register-specialist-function ((name STRING) (native-name STRING)
                                       (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation
  "Register `name' as a function name in the module named `module-name'.
This function will the native code named `native-name'.  The `name'
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The `native-name' will be
processed in a manner that depends on the underlying programming
language.  The following type mappings are used:
          C++:  Not available.  Error signaled.
  Common Lisp:  The native-name is read by READ-FROM-STRING and then
                the SYMBOL-FUNCTION is taken.
         Java:  A fully package-qualified name is required.  It is
                looked up using the Reflection tools.
The function found must conform to the signature for specialist functions."
  (with-logic-environment (safely-get-module module-name environment) environment
    (/logic/register-specialist-function-name name native-name)))


(defun register-computation-function ((name STRING) (function-reference FUNCTION-CODE)
				      (arity INTEGER) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation
  "Register `name' as a function name in `module' which will invoke the
native code procedure described by `function-reference.'  The `name'
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The function must conform
to the signature for computation functions used by the computation
specialist.  Arity specifies the number of arguments the computation
accepts.

The exact form of `function-reference' depends on the underlying
programming language.  The following type mappings are used:
          C++:  cpp_function_code (a pointer to the function code)
  Common Lisp:  FUNCTION   (result of #' or (FUNCTION ...))
         Java:  java.lang.reflect.Method"
  (with-logic-environment module environment
    (/logic/register-computation-function name function-reference arity)))

(defun s-register-computation-function ((name STRING) (native-name STRING) (arity INTEGER)
                                       (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation
  "Register `name' as a function name in the module named `module-name'.
This function will the native code named `native-name'.  The `name'
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The `native-name' will be
processed in a manner that depends on the underlying programming
language.  The following type mappings are used:
          C++:  Not available.  Error signaled.
  Common Lisp:  The native-name is read by READ-FROM-STRING and then
                the SYMBOL-FUNCTION is taken.
         Java:  A fully package-qualified name is required.  It is
                looked up using the Reflection tools.
The function found must conform to the signature for computation functions.
Arity specifies the number of arguments the computation accepts."
  (with-logic-environment (safely-get-module module-name environment) environment
    (/logic/register-computation-function-name name native-name arity)))


(defun (create-enumerated-list LOGIC-OBJECT) 
       ((members CONS) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation
  "Create a logical term that denotes a list containing `members' in
`module' using `environment'.  Useful for passing lists as arguments
to parameterized queries."
  (with-logic-environment module environment
    (return (create-logical-list (new LIST :the-cons-list members)))))

(defun (create-enumerated-set LOGIC-OBJECT) 
       ((members CONS) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation
  "Create a logical term that denotes the enumerated set containing `members'
in `module' using `environment'."
  (with-logic-environment module environment
    (return (/logic/create-enumerated-set (new LIST :the-cons-list members)))))

(defun destroy-object ((object OBJECT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Delete the object `object', retracting all facts attached to it."
  (with-process-lock *powerloom-lock*
    (/logic/destroy-object object)))

(defun s-destroy-object
 ((object-name STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Delete the object named `object-name', retracting all facts
attached to it.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown."
  (let ((module (safely-get-module module-name environment))
        (object (safely-get-object object-name module environment)))
    (when (all-defined? object)
      (destroy-object object))))

(defun (assert-unary-proposition PROPOSITION) 
    ((relation LOGIC-OBJECT) (arg OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Assert that the proposition (`relation' `arg') is TRUE in `module'.  Return the asserted proposition."
  (with-logic-environment module environment
    (if (class? relation)
      (return (assert-isa-proposition arg (surrogate-value-inverse relation)))
      (return (assert-property arg (surrogate-value-inverse relation))))))

(defun (assert-binary-proposition PROPOSITION)
       ((relation LOGIC-OBJECT) (arg OBJECT) (value OBJECT)
	(module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Assert that the proposition (`relation' `arg' `value') is TRUE
in `module'.  Return the asserted proposition."
  (with-logic-environment module environment
    (return (assert-binary-value (surrogate-value-inverse relation) arg value))))

(defun (assert-nary-proposition PROPOSITION) 
       ((relation-and-arguments OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Assert that the proposition represented by the list ` relation-and-arguments' satisfies
the relation `relation'."
  (let ((list (sequence-to-cons-list relation-and-arguments))
        (relation NAMED-DESCRIPTION (first list))
        (relationSurrogate (surrogate-value-inverse relation))
        (arguments (rest list)))
    (with-logic-environment module environment
      (return (assert-tuple relationSurrogate arguments)))))

(defun (retract-unary-proposition PROPOSITION) 
    ((relation LOGIC-OBJECT) (arg OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Retract that the proposition (`relation' `arg') is TRUE in `module'.  Return the asserted proposition."
  (with-logic-environment 
    module environment
    (if (class? relation)
      (return (retract-isa-proposition arg (surrogate-value-inverse relation)))
      (return (retract-property arg (surrogate-value-inverse relation))))))

(defun (retract-binary-proposition PROPOSITION)
       ((relation LOGIC-OBJECT) (arg OBJECT) (value OBJECT)
	(module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Retract that the proposition (`relation' `arg' `value') is TRUE
in `module'.  Return the asserted proposition."
  (with-logic-environment module environment
    (return (retract-binary-value (surrogate-value-inverse relation) arg value))))

(defun (retract-nary-proposition PROPOSITION) 
       ((relation-and-arguments OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Retract the proposition that `arguments' satisfies
the relation `relation'."
  (let ((list (sequence-to-cons-list relation-and-arguments))
        (relation NAMED-DESCRIPTION (first list))
        (relationSurrogate (surrogate-value-inverse relation))
        (arguments (rest list)))
    (with-logic-environment module environment
      (return (update-tuple relationSurrogate arguments :RETRACT-TRUE)))))

(defun (assert-proposition PROPOSITION) 
    ((proposition PROPOSITION) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Assert that the proposition `proposition' is true in `module'.
Return the asserted proposition."
  (with-logic-environment module environment
    (help-update-top-level-proposition proposition :ASSERT-TRUE)
    (return proposition)))

(defun (s-assert-proposition (PL-ITERATOR OF PROPOSITION))
    ((sentence STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Assert that the logical sentence `sentence' is true in the module
named `module-name'.  A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.

Return an iterator of the propositions resulting from sentence."
  (let ((module (safely-get-module module-name environment))
        (propositions (PL-ITERATOR OF PROPOSITION) NULL)
	(return-value (PL-ITERATOR OF PROPOSITION) NULL))
    (with-logic-environment module environment
      (setq propositions (s-conceive sentence module-name environment))
      (setq return-value (cons-to-pl-iterator (cursor propositions))) ; Preserve for return
      (foreach proposition in propositions
	  do (help-update-top-level-proposition proposition :ASSERT-TRUE))
      (return return-value))))

(defun (retract-proposition PROPOSITION) 
    ((proposition PROPOSITION) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Retract the truth of the proposition `proposition' in `module'.
Return the retracted proposition."
  (with-logic-environment module environment
    (help-update-top-level-proposition proposition :RETRACT-TRUE)
    (return proposition)))

(defun (s-retract-proposition (PL-ITERATOR OF PROPOSITION)) 
    ((sentence STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Retract the truth of the logical sentence `sentence' in the module named
`module-name'.  A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.

Return an iterator of the retracted propositions resulting from sentence."
  (let ((module (safely-get-module module-name environment))
        (propositions (PL-ITERATOR OF PROPOSITION) NULL)
	(return-value (PL-ITERATOR OF PROPOSITION) NULL))
    (with-logic-environment module environment
      (setq propositions (s-conceive sentence module-name environment))
      (setq return-value (cons-to-pl-iterator (cursor propositions))) ; Preserve for return
      (foreach proposition in propositions
	  do (help-update-top-level-proposition proposition :RETRACT-TRUE))
      (return return-value))))

(defun (conceive (PL-ITERATOR OF PROPOSITION))
    ((sentence OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Create one or more proposition objects from the sentence `sentence'
in the  module `module'.  Return an iterator of the propositions.
If any of the new propositions has the same structure as an already existing
proposition, an automatic check for duplicates will return the pre-existing
proposition.  Multiple propositions may be returned for a single sentence
because of normalization of equivalences, conjunctions, etc.

Signals a `Proposition-Error' if PowerLoom could not conceive `sentence'."
  (if (null? sentence)
    (return NULL)
    (with-logic-environment module environment
      (let ((propositions (conceive-formula sentence)))
	(when (null? propositions)
	  (signal-proposition-error "Failed to conceive " sentence))
	(typecase propositions
	  (PROPOSITION
	   (return (cons-to-pl-iterator (cons propositions NIL))))
	  (CONS
	   (return (cons-to-pl-iterator propositions)))
          (otherwise
           (signal-proposition-error "Formula is not a sentence: " sentence)))) )))

(defun (s-conceive (PL-ITERATOR OF PROPOSITION))
    ((sentence STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Create one or more proposition objects from the sentence `sentence'
in the  module named `module-name'.  Return an iterator of the propositions.
If any of the new propositions has the same structure as an already existing
proposition, an automatic check for duplicates will return the pre-existing
proposition.  Multiple propositions may be returned for a single sentence
because of normalization of equivalences, conjunctions, etc.

A module name of `null' or the empty string refers to the current module.
If no module can be found with the name `module-name', then a Stella
`No-Such-Context-Exception' is thrown.

Signals a `Proposition-Error' if PowerLoom could not conceive `sentence'."
  (let ((module (safely-get-module module-name environment)))
    (with-logic-environment module environment
      (setq module *module*) 
      (return (conceive (unstringify sentence) module environment))) ))


  ;;
;;;;;; Rules
  ;;

;;; ISSUE: figure out what `module' means here, i.e., do we look for
;;; true rules only, or rules whose home module is `module'?

(defun (get-rules (PL-ITERATOR OF PROPOSITION)) 
    ((relation LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return rules attached to the concept/relation `relation'
in either antecedent or consequent position."
  (if (null? relation)
    (return EMPTY-PL-ITERATOR)
    (with-logic-environment module environment
       (return (cons-to-pl-iterator (call-get-rules relation))))))

(defun (s-get-rules (PL-ITERATOR OF PROPOSITION)) 
       ((relation-name STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return rules attached to the concept/relation named
`relation-name' found in the module named `module-name'.
A module name of `null' or the empty string refers to the current module.
If no module can be found with the name `module-name', then a Stella
`No-Such-Context-Exception' is thrown."
  (let ((module (safely-get-module module-name environment))
        (relation (safely-get-relation relation-name module environment)))
    (return (get-rules relation module environment))))

(defun s-print-rules ((name STRING) (stream OUTPUT-STREAM)
		      (module-name STRING) (environment ENVIRONMENT))
  :documentation "Print rules attached to the concept/relation named `name'.
A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  (when (null? stream)
    (setq stream STANDARD-OUTPUT))
  (foreach rule in (s-get-rules name
				module-name
				environment)
      do (print-logical-form rule stream)
         (print-stream stream EOL EOL)))

(defun run-forward-rules ((module OBJECT) (local? BOOLEAN) (force? BOOLEAN))
  :documentation "Run forward inference rules in module `module' which defaults
to the current module.  See `run-forward-rules' command for more information."
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  (when (null? module)
    (setq module *module*))
  (when (defined? module)
    (call-run-forward-rules module local? force?)))


  ;;
;;;;;; Frame queries
  ;;

(defun (get-arity INTEGER) ((relation LOGIC-OBJECT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return the arity of the relation `relation'."
  (typecase relation
    (DESCRIPTION (return (arity relation)))
    (otherwise (return 0))))

(defun (s-get-arity INTEGER) ((relation-name STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return the arity of the relation named `relation-name'.

 A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (let ((module (safely-get-module module-name environment))
        (relation (safely-get-relation relation-name module environment)))
    (if (all-defined? relation)
      (return (get-arity relation))
      (return NULL))))

(defun (get-domain LOGIC-OBJECT) ((relation LOGIC-OBJECT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return the type (a concept) for the first argument to the binary
relation `relation'."
  (typecase relation
    (NAMED-DESCRIPTION (return (get-nth-domain relation 0)))
    (otherwise (return NULL))))

(defun (s-get-domain LOGIC-OBJECT) ((relation-name STRING) 
                                    (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return the type (concept) for the first argument to the binary
relation `relation-name'.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (let ((module (safely-get-module module-name environment))
        (relation (safely-get-relation relation-name module environment)))
    (if (all-defined? relation)
      (return (get-domain relation))
      (return NULL))))

(defun (get-range LOGIC-OBJECT) ((relation LOGIC-OBJECT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return the type (a concept) for fillers of the binary relation
`relation'."
  (typecase relation
    (NAMED-DESCRIPTION (return (get-nth-domain relation 1)))
    (otherwise (return NULL))))

(defun (s-get-range LOGIC-OBJECT) ((relation-name STRING)
                                   (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return the type (a concept) for fillers of the binary relation
`relation-name'.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (let ((module (safely-get-module module-name environment))
        (relation (safely-get-relation relation-name module environment)))
    (if (all-defined? relation)
      (return (get-range relation))
      (return NULL))))

(defun (get-nth-domain LOGIC-OBJECT) ((relation LOGIC-OBJECT) (n INTEGER))
  :public? TRUE :c-callable? TRUE
  :documentation "Return the type (a concept) for the the nth argument of the
relation `relation'.  Counting starts at zero.  NOTE: if there are multiple
`nth-domain' propositions for `relation', this arbitrarily returns one of them;
it does not look for the most specific one (which might have to be created)."
  (when (class? relation)
    (return (choose (eql? n 0) relation NULL)))
  (typecase relation
    (NAMED-DESCRIPTION
     (when (and (>= n 0)
                (< n (length (io-variable-types relation))))
       (let ((domainProp
              (first
               (help-get-propositions (surrogate-value PL-KERNEL/@nth-domain)
                                      (cons relation (cons n (cons null nil)))
                                      1 null null))))
         (when (defined? domainProp)
           (return (last-argument domainProp))))))
    (otherwise NULL))
  (return NULL))

(defun (s-get-nth-domain LOGIC-OBJECT)
       ((relation-name STRING) (n INTEGER) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation
  "Return the type (a concept) for the nth argument of the relation
named `relation-name'.  Counting starts at zero.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (let ((module (safely-get-module module-name environment))
        (relation (safely-get-relation relation-name module environment)))
    (if (all-defined? relation)
      (return (get-nth-domain relation n))
      (return NULL))))

(defun load ((filename STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Read logic commands from the file named `filename' and evaluate them.
See `load' command help for more information."
  (with-logic-environment *module* environment
    (LOGIC/load filename)))

(defun load-in-module ((filename STRING) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Read logic commands from the file named `filename' and evaluate them.
Binds the `load' command's :module option to `module'.  See `load' command help for more information."
  (with-logic-environment module environment
    (setq module *module*) 
    (LOGIC/load filename :module module)))

(defun load-stream ((stream INPUT-STREAM) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Read logic commands from the STELLA stream `stream' and evaluate them.
See `load' command help for more information."
  (with-logic-environment *module* environment
    (LOGIC/load-stream stream)))

(defun load-stream-in-module ((stream INPUT-STREAM) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Read logic commands from the STELLA stream `stream' and evaluate them.
Binds the `load' command's :module option to `module'.  See `load' command help for more information."
  (with-logic-environment module environment
    (setq module *module*) 
    (LOGIC/load-stream stream :module module)))

(defun load-native-stream ((stream NATIVE-INPUT-STREAM) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation
  "Read logic commands from the native input stream `stream' and evaluate them.
Assumes `stream' is a line-buffered stream which is a safe compromise but does
not generate the best efficiency for block-buffered streams such as files.
See `load' command help for more information."
  (with-logic-environment *module* environment
    (LOGIC/load-stream (new INPUT-STREAM :native-stream stream))))

(defun load-native-stream-in-module ((stream NATIVE-INPUT-STREAM) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation
  "Read logic commands from the native input stream `stream' and evaluate them.
Assumes `stream' is a line-buffered stream which is a safe compromise but does
not generate the best efficiency for block-buffered streams such as files.
Binds the `load' command's :module option to `module'.  See `load' command help for more information."
  (with-logic-environment module environment
    (setq module *module*) 
    (LOGIC/load-stream (new INPUT-STREAM :native-stream stream) :module module)))

(defun save-module ((module MODULE) (filename STRING) (ifexists STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Save the contents of the module `mod' into a file named `filename'.
If a file named `filename' already exists, then the action taken depends on the
value of `ifexists'.  Possible values are \"ASK\", \"REPLACE\", \"WARN\" and \"ERROR\":

  REPLACE => Means overwrite without warning.
  WARN    => Means overwrite with a warning.
  ERROR   => Means don't overwrite, signal an error instead.
  ASK     => Ask the user whether to overwrite or not.  If not overwritten, an 
             exception is thrown."
  (let ((exists? (stella/probe-file? filename)))
    (cond ((or (not exists?) (string-equal? ifexists "REPLACE"))
	   NULL)			; Do nothing, replace file if needed.
	  ((string-equal? ifexists "ASK")
	   (unless (yes-or-no? (concatenate "File `" filename 
					    "' already exists.  Overwrite it? (yes or no) "))
	     (ensure-file-does-not-exist filename "save-module")))
	  ((string-equal? ifexists "WARN")
	   (warn "File " filename " already exists, overwriting."))
	  ((string-equal? ifexists "ERROR")
	   (ensure-file-does-not-exist filename "save-module"))
	  (otherwise
            (signal BAD-ARGUMENT-EXCEPTION "Unrecognized ifexists option " ifexists)))
    (with-logic-environment module environment
      (setq module *module*) 
      (with-output-file (stream filename)
	(do-save-module module stream))) ))

(defun s-save-module ((module-name STRING) (filename STRING) (ifexists STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Save the contents of the module `module-name' into a file named `filename'.
If a file named `filename' already exists, then the action taken depends on the
value of `ifexists'.  Possible values are \"ASK\", \"REPLACE\", \"WARN\" and \"ERROR\":

  REPLACE => Means overwrite without warning.
  WARN    => Means overwrite with a warning.
  ERROR   => Means don't overwrite, signal an error instead.
  ASK     => Ask the user whether to overwrite or not.  If not overwritten, an
             exception is thrown.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (save-module (safely-get-module module-name environment) filename ifexists environment))


  ;;
;;;;;; Extracting column values from propositions and iterators
  ;;

(defun (get-predicate LOGIC-OBJECT) ((prop PROPOSITION))
  :public? TRUE :c-callable? TRUE
  :documentation "Return the concept or relation predicate for
the proposition `prop'."
  ;; Called by `get-nth-value'.
  (let ((relation LOGIC-OBJECT (get-description (relationref prop))))
    (when (null? relation)
      ;; if we can't return a NAMED-DESCRIPTION, we settle for returning
      ;;    a LOGIC-OBJECT:
      (setq relation (surrogate-value (relationref prop))))
    (return relation)))

(defun (get-column-count INTEGER) ((obj OBJECT))
  :public? TRUE :c-callable? TRUE
  :documentation "Return the number of columns in `obj', which must
be of type proposition, skolem, cons, vector or PL-iterator.  For a proposition,
the number includes both the predicate and arguments. For the PL-iterator
case,the number of columns is for the current value of the iterator. For the
skolem case, if the skolem is a function term, the column count of its defining
proposition will be returned, otherwise it is treated as a non-sequence object.

For a null item, the column count is zero.
For non sequence objects, the column count is one."
  (when (null? obj)
    (return 0))
  (typecase obj
    (PROPOSITION
     (return (1+ (length (arguments obj)))))
    (PL-ITERATOR
     (return (get-column-count (value obj))))
    (CONS
     (return (length obj)))
    (VECTOR
     (return (length obj)))
    (SKOLEM
     (if (function-output-skolem? obj)
         (return (get-column-count (defining-proposition obj)))
       (return 1)))
    (otherwise 
     (return 1))))

(defun (get-nth-value OBJECT) ((sequence OBJECT) (n INTEGER) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return the value in the `nth' column of `sequence'.
Counting starts at zero.  Unless `n' is zero, `sequence' must be of type
proposition, skolem, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the number
of columns is for the current value of the iterator.   For the skolem case,
if the skolem is a function term, the nth value of its defining proposition
will be returned, otherwise it is treated as a non-sequence object.

As a special case, a column number of zero will also return `sequence' itself
if it is not one of the types enumerated above.  This is done to allow the
use of `get-nth-value' on PL-iterators with only a single return variable."
  (when (or (>= n (get-column-count sequence))
	    (< n 0))
    (signal LOGIC-EXCEPTION "Column index " n " is out of range for " sequence))
  (typecase sequence
    (PROPOSITION
     (if (eql? n 0)
       (return (get-predicate sequence))
       (let ((value (nth (arguments sequence) (1- n))))
         (typecase value
           (SKOLEM
            (with-logic-environment module environment
              (return (value-of value))))
           (otherwise
            (return value))))))
    (PL-ITERATOR
     (return (get-nth-value (value sequence) n module environment)))
    (CONS
     (return (nth sequence n)))
    (VECTOR
     (return (nth sequence n)))
    (SKOLEM
     (if (function-output-skolem? sequence)
         (return (get-nth-value (defining-proposition sequence) n module environment))
       (return sequence)))
    (otherwise
     (return sequence)) ))

(defun (get-nth-string STRING) ((sequence OBJECT) (n INTEGER) (module MODULE)(environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Return a string representation of the value in the `nth' column of
`sequence'. Counting starts at zero.   Unless `n' is zero, `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  This will always
succeed, even if the `nth' value is not a string object.  In that case, a
string reprensentation will be returned.

As a special case, a column number of zero will also return `sequence' itself
as a string if it is not one of the types enumerated above.  This is done to 
allow the use of `get-nth-string' on PL-iterators with only a single return variable."
  (return (object-to-string (get-nth-value sequence n module environment))))

(defun (get-nth-integer INTEGER) ((sequence OBJECT) (n INTEGER) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation  "Return an integer representation of the value in the `nth' column of
`sequence'. Counting starts at zero.   Unless `n' is zero, `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  If this is not
an integer value, then an exception will be thrown.

As a special case, a column number of zero will also return the integer
value of `sequence' itself if it is not one of the types enumerated
above.   This allows the use of `get-nth-integer' on PL-iterators with
only a single return variable.  If  `sequence' cannot be turned into an
integer, an exception will be thrown."
  (return (object-to-integer (get-nth-value sequence n module environment))))

(defun (get-nth-float FLOAT) ((sequence OBJECT) (n INTEGER) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation  "Return the floating point value in the `nth' column of
`sequence'. Counting starts at zero.  `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  If this is not
a floating point value, then an exception will be thrown.

As a special case, a column number of zero will also return the floating
point value of `sequence' itself if it is not one of the types enumerated
above.  This allows the use of `get-nth-float' on PL-iterators with only
a single return variable.    If  `sequence' cannot be turned into a floating
point value, an exception will be thrown."
  (return (object-to-float (get-nth-value sequence n module environment))))

(defun (get-nth-logic-object LOGIC-OBJECT) ((sequence OBJECT) (n INTEGER) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation
  "Return a logic object representation of the value in the `nth' column
of `sequence'.  Counting starts at zero.   Unless `n' is zero, `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  A zero column number
returns the proposition's relational predicate.  If the return value is
not a LOGIC-OBJECT, an exception is thrown.

As a special case, a column number of zero will also return `sequence' itself
if it is not one of the types enumerated above.  This is done to allow the
use of `get-nth-value' on PL-iterators with only a single return variable.
If `sequence' is not a LOGIC-OBJECT, an exception is thrown."
  (let ((value (get-nth-value sequence n module environment)))
    (if (isa? value @LOGIC-OBJECT)
      (return value)
      (signal STELLA-EXCEPTION "Can't coerce " value " to a LOGIC-OBJECT."))))

(defun (get-enumerated-collection-members CONS) ((collection OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE
  :documentation
  "Returns the members of an enumerated collection.  This works on all types
of collection, i.e., sets and lists"
  (with-logic-environment module environment
    (let ((members (asserted-collection-members collection TRUE)))
      (if (defined? members)
        (return (the-cons-list members))
        (return NULL)))))


  ;;
;;;;;; Evaluation
  ;;

(defun (evaluate OBJECT) ((command OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation "Evaluate the command `command' within `module' and return
the result. Currently, only the evaluation of (possibly nested) commands and
global variables is supported.  Commands are simple to program in Common Lisp,
since they are built into the language, and relatively awkward in Java and C++.
Users of either of those languages are more likely to want to call `s-evaluate'."
  (when (defined? command)
    (with-logic-environment module environment
      (return (STELLA/evaluate command))))
  (return NULL))

(defun (s-evaluate OBJECT) ((command STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE 
  :documentation
  "Evaluate the command represented by the string `command' within `module' and
return the result.  Currently, only the evaluation of (possibly nested) commands and
global variables is supported.

 A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (let ((module (safely-get-module module-name environment)))
    (with-logic-environment module environment
      (setq module *module*) 
      (return (evaluate (unstringify command)
                        module
                        environment)))))

(defun powerloom ((module MODULE) (environment ENVIRONMENT))
  :documentation "Run the PowerLoom read/eval/print loop."
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  (with-logic-environment module environment
    (LOGIC/powerloom)))


  ;;
;;;;;;  Queries
  ;;

;;; Type tests for returned values:

(defun (is-logic-object BOOLEAN) ((obj OBJECT))
  :public? TRUE :c-callable? TRUE
  :documentation "Test whether `obj' is of type LOGIC-OBJECT"
  (return (isa? obj @LOGIC-OBJECT)))

(defun (is-skolem BOOLEAN) ((obj OBJECT))
  :public? TRUE :c-callable? TRUE
  :documentation "Test whether `obj' is of type SKOLEM (which subsumes pattern variables)."
  (return (isa? obj @SKOLEM)))

(defun (is-variable BOOLEAN) ((obj OBJECT))
  :public? TRUE :c-callable? TRUE
  :documentation "Test whether `obj' is of type PATTERN-VARIABLE."
  (return (isa? obj @PATTERN-VARIABLE)))

(defun (is-integer BOOLEAN) ((obj OBJECT))
  :public? TRUE :c-callable? TRUE
  :documentation "Test whether `obj' is of type INTEGER"
  (return (isa? obj @INTEGER-WRAPPER)))

(defun (is-float BOOLEAN) ((obj OBJECT))
  :public? TRUE :c-callable? TRUE
  :documentation "Test whether `obj' is of type FLOAT (double)"
  (return (isa? obj @FLOAT-WRAPPER)))

(defun (is-number BOOLEAN) ((obj OBJECT))
  :public? TRUE :c-callable? TRUE
  :documentation "Test whether `obj' is of type NUMBER.  This can
be either an integer or a floating point number.  One key characteristic
is that 'object-to-integer' and `object-to-float' will both work on it."
  (return (isa? obj @NUMBER-WRAPPER)))

(defun (is-string BOOLEAN) ((obj OBJECT))
  :public? TRUE :c-callable? TRUE
  :documentation "Test whether `obj' is of type STRING"
  (return (isa? obj @STRING-WRAPPER)))

(defun (is-enumerated-collection BOOLEAN) ((obj OBJECT))
  :public? TRUE :c-callable? TRUE
  :documentation "Test whether `obj' is an enumerated collection.  This
subsumes both sets and lists."
  (return (logical-collection? obj)))

(defun (is-enumerated-set BOOLEAN) ((obj OBJECT))
  :public? TRUE :c-callable? TRUE
  :documentation "Test whether `obj' is an enumerated set."
  (return (enumerated-set? obj)))

(defun (is-enumerated-list BOOLEAN) ((obj OBJECT))
  :public? TRUE :c-callable? TRUE
  :documentation "Test whether `obj' is an enumerated list"
  (return (enumerated-list? obj)))


;;; Interpreting truth values:

(defun (is-true BOOLEAN) ((tv TRUTH-VALUE))
  :public? TRUE :c-callable? TRUE
  :documentation "Tests whether `tv' is a true truth value.  It can be true
either absolutely or by default."
  (return (true-truth-value? tv)))

(defun (is-false BOOLEAN) ((tv TRUTH-VALUE))
  :public? TRUE :c-callable? TRUE
  :documentation "Tests whether `tv' is a false truth value.  It can be false
either absolutely or by default."
  (return (false-truth-value? tv)))

(defun (is-unknown BOOLEAN) ((tv TRUTH-VALUE))
  :public? TRUE :c-callable? TRUE
  :documentation "Tests whether `tv' is an unknown truth value."
  (return (unknown-truth-value? tv)))

(defun (is-known BOOLEAN) ((tv TRUTH-VALUE))
  :public? TRUE :c-callable? TRUE
  :documentation "Tests whether `tv' is a known truth value (i.e., true or false)."
  (return (known-truth-value? tv)))

(defun (is-inconsistent BOOLEAN) ((tv TRUTH-VALUE))
  :public? TRUE :c-callable? TRUE
  :documentation "Tests whether `tv' is an inconsistent truth value."
  (return (inconsistent-truth-value? tv)))

(defun (is-strict BOOLEAN) ((tv TRUTH-VALUE))
  :public? TRUE :c-callable? TRUE
  :documentation "Tests whether `tv' is a strict (non-default) truth value."
  (return (strict-truth-value? tv)))

(defun (is-default BOOLEAN) ((tv TRUTH-VALUE))
  :public? TRUE :c-callable? TRUE
  :documentation "Tests whether `tv' is a default truth value."
  (return (default-truth-value? tv)))

(defun (ask TRUTH-VALUE) ((query CONS) (module MODULE) (environment ENVIRONMENT))
  :documentation
  "Returns a truth value for `query' in `module' and `environment'.
`query' has the same syntax as the PowerLoom `ask' command (which see)
but with the `ask' operator omitted.  For example, here are some legal
`query' arguments:
	 
    ((happy Fred))
    ((happy Fred) :inference-level :assertion)
    ((happy Fred) :inference-level :assertion :timeout 1.0)
	
As a convenience, a `query' argument whose first element is a symbol is
interpreted as a sentence that is queried without any options.  For example:
	 
    (happy Fred)
	
is a legal `query' argument.  Note that for a sentence whose relation is a list
itself, e.g., `((FruitFn BananaTree) MyBanana)' this shortcut is not available,
that is, in that case an extra level of list nesting is always necessary.
The returned truth value represents the logical truth of the queried sentence
as determined by PowerLoom.  It can be be tested via the functions `is-true',
`is-false' and `is-unknown' (which see)."
  :public? TRUE :c-callable? TRUE
  (with-logic-environment module environment
    (setq query (deobjectify-tree query))
    ;; Test for the case where `query' is the sentence and no ASK options are
    ;;    being given and add the required extra level of nesting:
    (when (symbol? (first query))
      (setq query (cons query NIL)))
    (return (call-ask query))))

(defun (s-ask TRUTH-VALUE) ((query STRING) (module-name STRING) (environment ENVIRONMENT))
  :documentation
  "Returns a truth value for `query' in module `module-name' and `environment'.
`query' has the same syntax as the PowerLoom `ask' command (which see) but
with the `ask' operator omitted.  Different from the PLI `ask' function, `s-ask'
does not expect a top-level pair of parentheses.  For example, here are some legal
`query' arguments:
	 
    \"(happy Fred)\"
    \"(happy Fred) :inference-level :assertion\"
    \"(happy Fred) :inference-level :assertion :timeout 1.0\"
	
Names in `query' will be interpreted relative to module `module-name'.
A null `module-name' or the empty string refers to the current module.
If no module can be found with the name `module-name', then a STELLA
`no-such-context-exception' is thrown.
The returned truth value represents the logical truth of the queried sentence
as determined by PowerLoom.  It can be be tested via the functions `is-true',
`is-false' and `is-unknown' (which see)."
  :public? TRUE :c-callable? TRUE
  (let ((queryForm NIL)
        (module (safely-get-module module-name environment)))
    (with-logic-environment module environment
      (foreach sexp in (s-expressions (new STRING-INPUT-STREAM :the-string query))
          collect sexp into queryForm))
    (return (ask queryForm (safely-get-module module-name environment) environment))))

(defun (retrieve PL-ITERATOR) ((query CONS) (module MODULE) (environment ENVIRONMENT))
  :documentation
  "Returns an iterator of variable bindings that when substituted for the
open variables in `query' satisfy the query proposition.  The query is
run in `module' and relative to `environment'.  `query' has the same syntax
as the PowerLoom `retrieve' command (which see) but with the `retrieve'
operator omitted.    For example, here are some legal `query' arguments:
	 
    ((happy ?x))
    (10 (happy ?x))
    (all (happy ?x))
    (all ?x (happy ?x))
    (10 (happy ?x) :inference-level :assertion)
    (10 (happy ?x) :inference-level :assertion :timeout 1.0)
	
If there is only a single output variable (as in all the examples above)
each element generated by the returned iterator will be a binding for
that variable - unless, the output variable was declared with a surrounding
pair of parentheses.  For example:
	 
    (all (?x) (happy ?x))
	
In that case, the generated elements will be one-element lists.  If there
are multiple output variables, each element generated by the returned
iterator will be a list of variable bindings that can be accessed using
the various `get-nth-...' functions.  The list of output variables does
not need to be declared in which case they are taken to be the open variables
in the query proposition in the order in which they were encountered.  If
order does matter or should be different from its default, it can be forced
by declaring the set of output variables."
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  (with-logic-environment module environment
    (setq query (deobjectify-tree query))
    ;; NOTE: This works around the problem that query iterators would
    ;; otherwise be forced to completion by iterator-to-pl-iterator.
    ;; If that changes, then we can simplify this code.
    (return (cons-to-pl-iterator (consify-current-solutions (call-retrieve query))))))

(defun (s-retrieve PL-ITERATOR) ((query STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  :documentation
  "Returns an iterator of variable bindings that when substituted for the
open variables in `query' satisfy the query proposition.  The query is
run in `module' and relative to `environment'.  `query' has the same syntax
as the PowerLoom `retrieve' command (which see) but with the `retrieve'
operator omitted.  Different from the PLI `retrieve' function, `s-retrieve'
does not expect a top-level pair of parentheses.  For example, here are some
legal `query' arguments:
	 
    \"(happy ?x)\"
    \"10 (happy ?x)\"
    \"all (happy ?x)\"
    \"all ?x (happy ?x)\"
    \"10 (happy ?x) :inference-level :assertion\"
    \"10 (happy ?x) :inference-level :assertion :timeout 1.0\"
	
If there is only a single output variable (as in all the examples above)
each element generated by the returned iterator will be a binding for
that variable - unless, the output variable was declared with a surrounding
pair of parentheses.  For example:
	 
    \"all (?x) (happy ?x)\"
	
In that case, the generated elements will be one-element lists.  If there
are multiple output variables, each element generated by the returned
iterator will be a list of variable bindings that can be accessed using
the various `get-nth-...' functions.  The list of output variables does
not need to be declared in which case they are taken to be the open variables
in the query proposition in the order in which they were encountered.  If
order does matter or should be different from its default, it can be forced
by declaring the set of output variables.

Names in `query' will be interpreted relative to module `module-name'.
A null `module-name' or the empty string refers to the current module.
If no module can be found with the name `module-name', then a STELLA
`no-such-context-exception' is thrown."
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  (let ((queryForm NIL)
        (module (safely-get-module module-name environment)))
    (with-logic-environment module environment
      (foreach sexp in (s-expressions (new STRING-INPUT-STREAM :the-string query))
          collect sexp into queryForm))
    (return (retrieve queryForm module environment))))


  ;;
;;;;;; CLASSIFICATION API
  ;;

;; TO DO: ADD interface for
;;  classify-relations
;;  classify-instances
;;  list-unclassified-instances (use get-...)
;;  list-unclassified-relations (use get-...)


  ;;
;;;;;; Inference Engine API
  ;;

(defun (get-frame-proposition PROPOSITION) ((frame CONTROL-FRAME))
  :documentation "Return the proposition currently being inferred by this control `frame'.
This proposition will generally have bound and/or unbound pattern variables as its arguments."
  :public? TRUE :c-callable? TRUE
  (return (proposition frame)))

(defun (get-frame-arity INTEGER) ((frame CONTROL-FRAME))
  :documentation "Return the arity of the proposition currently being inferred by `frame'.
This will be the actual number of arguments, even if the proposition is of variable arity."
  :public? TRUE :c-callable? TRUE
  (return (length (arguments (proposition frame)))))

(defun (get-frame-iterator PL-ITERATOR) ((frame CONTROL-FRAME))
  :documentation "Return the iterator generating successive bindings for the proposition
that is currently being inferred by `frame'."
  :public? TRUE :c-callable? TRUE
  (return (iterator frame)))

(defun set-frame-iterator ((frame CONTROL-FRAME) (iterator PL-ITERATOR))
  :documentation "Set the iterator for generating successive bindings for the proposition
that is currently being inferred by `frame' to `iterator'."
  :public? TRUE :c-callable? TRUE
  (setf (iterator frame) iterator))

(defun (get-nth-frame-argument OBJECT) ((frame CONTROL-FRAME) (n INTEGER))
  :documentation "Return the `n'-th argument of the proposition that is currently being inferred
by `frame'.  This will generally be a pattern variable that might be unbound or bound."
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  (let ((args (arguments (proposition frame))))
    (if (and (>= n 0) (< n (length args)))
        (return (nth args n))
      (signal LOGIC-EXCEPTION "Argument index " n " is out of range for " (proposition frame)))))

(defun (get-nth-frame-binding OBJECT) ((frame CONTROL-FRAME) (n INTEGER))
  :documentation "Return the binding of the `n'-th argument of the proposition that is currently
being inferred by `frame'.  This will be NULL if the argument is unbound, otherwise, the object
bound to the variable."
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  (let ((args (arguments (proposition frame))))
    (if (and (>= n 0) (< n (length args)))
        (return (safe-argument-bound-to (nth args n)))
      (signal LOGIC-EXCEPTION "Argument index " n " is out of range for " (proposition frame)))))

(defun (set-nth-frame-binding BOOLEAN) ((frame CONTROL-FRAME) (n INTEGER) (value OBJECT))
  :documentation "Set the binding of the `n'-th argument of the proposition that is currently
being inferred by `frame' to `value'.  If the binding was successful, that is if the argument
was unbound or is already bound to `binding', the function returns TRUE.  Otherwise, the
argument will keep its current binding and FALSE will be returned."
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  (let ((args (arguments (proposition frame))))
    (if (and (>= n 0) (< n (length args)))
        (return (bind-argument-to-value? (nth args n) value TRUE))
      (signal LOGIC-EXCEPTION "Argument index " n " is out of range for " (proposition frame)))))

(defun (is-frame-binding-pattern BOOLEAN) ((frame CONTROL-FRAME) (pattern STRING))
  :documentation "Return TRUE if the arguments of `frame' are bound according to `pattern'.
Each character in pattern corresponds to an argument at the particular position and  must be
either `B' (for bound) or `_' for unbound.  The function returns TRUE if `frame' has at least
as many arguments as `pattern' has characters and their bindings match `pattern'.  If `frame'
has additional arguments, they will be ignored.  If `pattern' has more positions than `frame'
has arguments, the function returns FALSE."
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  (let ((args (arguments (proposition frame))))
    (cond ((<= (length pattern) (length args))
           (foreach ch in pattern
               as arg in args
               do (case ch
                    (#\B (when (null? (safe-argument-bound-to arg))
                           (return FALSE)))
                    (#\_ (when (defined? (safe-argument-bound-to arg))
                           (return FALSE)))
                    (otherwise
                     (signal LOGIC-EXCEPTION "Illegal binding pattern: " pattern))))
           (return TRUE))
          (otherwise
           (return FALSE)))))

(defun (get-frame-binding-pattern STRING) ((frame CONTROL-FRAME))
  :documentation "Return a string representation of the argument binding pattern of `frame'.
The syntax of the pattern is the same as used for `is-frame-binding-pattern' (which see)."
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  ;; TO DO: make this more efficient by caching and reusing patterns based on
  ;;        boolean vectors defined in query.ste (see `*boolean-vector-index*').
  (let ((args (arguments (proposition frame)))
        (pattern (make-raw-mutable-string (length args))))
    (foreach arg in args
        as i in (interval 0 NULL)
        do (if (defined? (safe-argument-bound-to arg))
               (setf (nth pattern i) #\B)
             (setf (nth pattern i) #\_)))
    (return pattern)))

(defun (get-frame-binding-state CONS) ((frame CONTROL-FRAME))
  :documentation "Return a frame variable binding stack state that can be used to unbind
all frame variables to the state they were in when the binding stack state was recorded."
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  (let ((patternRecord (current-pattern-record *queryIterator*))
        (ubStackOffset (top-unbinding-stack-offset patternRecord)))
    (return (cons patternRecord (cons ubStackOffset NIL)))))

(defun set-frame-binding-state ((frame CONTROL-FRAME) (state CONS))
  :documentation "Reset the frame variable binding stack state to `state'.  This will set
all frame variables to the state they were in when the binding stack state was recorded."
  :public? TRUE :c-callable? TRUE :throws-exceptions? TRUE
  (unbind-variables-beginning-at (first state) (1+ (second state))))


  ;;
;;;;;; Properties
  ;;

;;; For the PLI property interface, we always assume string property names which is
;;; what we most commonly use.  To access other property names such as symbols, etc.
;;; the PLI `evaluate' function can be used.

;;; To avoid GC issues, we always copy property and value strings whenever they might
;;; get wrapped and get stored in the configuration table.

(defun (get-property-object OBJECT) ((property STRING) (defaultValue OBJECT))
  :documentation "Return the value of the global STELLA configuration `property'
or `defaultValue' if it is undefined."
  :public? TRUE :c-callable? TRUE
  (return (STELLA/get-property property defaultValue)))

(defun (get-property-string STRING) ((property STRING) (defaultValue STRING))
  :documentation "Return the value of the global STELLA configuration `property'
as a string or `defaultValue' if it is undefined."
  :public? TRUE :c-callable? TRUE
  (return (object-to-string (STELLA/get-property property defaultValue))))

(defun (get-property STRING) ((property STRING) (defaultValue STRING))
  :documentation "Synonym for `get-property-string' (which see)."
  :public? TRUE :c-callable? TRUE
  (return (get-property-string property defaultValue)))

(defun (get-property-integer INTEGER) ((property STRING) (defaultValue INTEGER))
  :documentation "Return the value of the global STELLA configuration `property'
as an integer or `defaultValue' if it is undefined.  Raises an error if the defined
value is not an integer."
  :public? TRUE :c-callable? TRUE
  (return (object-to-integer (STELLA/get-property property defaultValue))))

(defun (get-property-float FLOAT) ((property STRING) (defaultValue FLOAT))
  :documentation "Return the value of the global STELLA configuration `property'
as a float or `defaultValue' if it is undefined.  Raises an error if the defined
value is not a float."
  :public? TRUE :c-callable? TRUE
  (return (object-to-float (STELLA/get-property property defaultValue))))

(defun (get-property-boolean BOOLEAN) ((property STRING) (defaultValue BOOLEAN))
  :documentation "Return the value of the global STELLA configuration `property'
as a boolean or `defaultValue' if it is undefined.  Raises an error if the defined
value is not a boolean."
  :public? TRUE :c-callable? TRUE
  (return (coerce-to-boolean (STELLA/get-property property defaultValue))))

(defun set-property-object ((property STRING) (value OBJECT))
  :documentation "Set the global STELLA configuration `property' to `value'."
  :public? TRUE :c-callable? TRUE
  (STELLA/set-property (copy property) value))

(defun set-property-string ((property STRING) (value STRING))
  :documentation "Set the global STELLA configuration `property' to a string `value'."
  :public? TRUE :c-callable? TRUE
  (STELLA/set-property (copy property) (copy value)))

(defun set-property ((property STRING) (value STRING))
  :documentation "Synonym for `set-property-string' (which see)."
  :public? TRUE :c-callable? TRUE
  (set-property-string property value))

(defun set-property-integer ((property STRING) (value INTEGER))
  :documentation "Set the global STELLA configuration `property' to an integer `value'."
  :public? TRUE :c-callable? TRUE
  (STELLA/set-property (copy property) value))

(defun set-property-float ((property STRING) (value FLOAT))
  :documentation "Set the global STELLA configuration `property' to a float `value'."
  :public? TRUE :c-callable? TRUE
  (STELLA/set-property (copy property) value))

(defun set-property-boolean ((property STRING) (value BOOLEAN))
  :documentation "Set the global STELLA configuration `property' to a boolean `value'."
  :public? TRUE :c-callable? TRUE
  (STELLA/set-property (copy property) value))

(defun (is-defined-property BOOLEAN) ((property STRING))
  :documentation "Return TRUE if `property' has a defined value."
  :public? TRUE :c-callable? TRUE
  (let ((value (STELLA/get-property property)))
    (return (and (defined? value)
                 (not (null-wrapper? value))))))

(defun print-properties ()
  :documentation "Print all currently defined STELLA configuration properties and values."
  :public? TRUE :c-callable? TRUE
  (STELLA/print-properties))


  ;;
;;;;;; Exception Handling
  ;;

;;; This is now handled by the C-callable wrapper generation, the functions here are merely entry points to that.

(defun (get-exception-handler FUNCTION-CODE) ()
  :public? TRUE :c-callable? TRUE
  (return (get-global-exception-handler)))

(defun set-exception-handler ((handler FUNCTION-CODE))
  :public? TRUE :c-callable? TRUE
  (set-global-exception-handler handler))


  ;;
;;;;;; Object Registration
  ;;

(defclass OBJECT-REGISTRY-LIST (LIST)
  :slots ((registry-length :type INTEGER :initially 0)
          (n-free-cells :type INTEGER :initially 0)))

(defglobal *object-registry* OBJECT-REGISTRY-LIST (new OBJECT-REGISTRY-LIST))

(defun (register-object CONS) ((object OBJECT))
  :documentation "Register `object' to prevent it from being garbage-collected by the PowerLoom GC.
The result of registration is a handle for `object' which can later be used to unregister it.
Currently it is assumed that calling this immediately after an object was returned by a PLI function
is safe; however, we might have to handle registration in PLI functions before objects are returned.
This is not thread safe and needs to be explicitly synchronized in a threaded environment."
  :public? TRUE :c-callable? TRUE
  (let ((registry *object-registry*))
    (push registry object)
    (++ (registry-length registry))
    (return (the-cons-list registry))))

(defun unregister-object ((objectHandle CONS))
  :documentation "Unregister the object whose registered handle is `objectHandle' to make it available
for PowerLoom garbage collection.  This also is not thread safe and needs to be explicitly synchronized
in a threaded environment."
  :public? TRUE :c-callable? TRUE
  (let ((registry *object-registry*)
        (nFree (n-free-cells registry)))
    (setf (value objectHandle) NULL)
    (++ nFree)
    (when (and (> nFree 1000)
               (>= nFree (shift-right (registry-length registry) 1)))
      ;; clean up freed cells:
      (remove registry NULL)
      (-- (registry-length registry) nFree)
      (setq nFree 0))
    (setf (n-free-cells registry) nFree)))


;;; Main entry point.
;;;

(defmain ()
  :documentation "Main PowerLoom entry point for your code in C++ and Java."
  :public? TRUE :startup-system? FALSE
  (print "Initializing STELLA..." EOL)
  (startup-stella-system)
  (print "Initializing PowerLoom..." EOL)
  (startup-logic-system)
  (STELLA/change-module "PL-USER")
  (logic/powerloom))
